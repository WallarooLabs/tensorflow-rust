// DO NOT EDIT. Generated by tensorflow-op-codegen/src/main.rs.
#![allow(
    missing_copy_implementations,
    missing_docs,
    non_snake_case,
    trivial_casts,
    unused_parens,
    unused_qualifications
)]

use tensorflow_sys as tf;

use crate::Result;
use crate::Status;

/// Abort
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Abort {
    pub error_msg: ::std::option::Option<::std::string::String>,
    pub exit_without_error: ::std::option::Option<bool>,
}

impl Abort {
    /// Creates a new `Abort`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// abort with default options.
pub fn abort(ctx: &crate::eager::Context) -> Result<()> {
    let __args = Abort::new();
    abort_with_args(ctx, &__args)
}

/// abort with options.
pub fn abort_with_args(ctx: &crate::eager::Context, __args: &Abort) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Abort")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.error_msg {
        op.set_attr_string("error_msg", value);
    }
    if let ::std::option::Option::Some(value) = &__args.exit_without_error {
        op.set_attr_bool("exit_without_error", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Abs
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Abs {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Abs {
    /// Creates a new `Abs`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// abs with default options.
pub fn abs<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Abs::new();
    abs_with_args(ctx, x, &__args)
}

/// abs with options.
pub fn abs_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Abs,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Abs")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AccumulateNV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AccumulateNV2 {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
}

impl AccumulateNV2 {
    /// Creates a new `AccumulateNV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// accumulate_nv2 with default options.
pub fn accumulate_nv2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = AccumulateNV2::new();
    accumulate_nv2_with_args(ctx, inputs, &__args)
}

/// accumulate_nv2 with options.
pub fn accumulate_nv2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &AccumulateNV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AccumulateNV2")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AccumulatorApplyGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AccumulatorApplyGradient {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl AccumulatorApplyGradient {
    /// Creates a new `AccumulatorApplyGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// accumulator_apply_gradient with default options.
pub fn accumulator_apply_gradient<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    local_step: T1,
    gradient: T2,
) -> Result<()> {
    let __args = AccumulatorApplyGradient::new();
    accumulator_apply_gradient_with_args(ctx, handle, local_step, gradient, &__args)
}

/// accumulator_apply_gradient with options.
pub fn accumulator_apply_gradient_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    local_step: T1,
    gradient: T2,
    __args: &AccumulatorApplyGradient,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AccumulatorApplyGradient")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&local_step.to_handle()?)?;
    op.add_input(&gradient.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// AccumulatorNumAccumulated
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AccumulatorNumAccumulated {}

impl AccumulatorNumAccumulated {
    /// Creates a new `AccumulatorNumAccumulated`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// accumulator_num_accumulated with default options.
pub fn accumulator_num_accumulated<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = AccumulatorNumAccumulated::new();
    accumulator_num_accumulated_with_args(ctx, handle, &__args)
}

/// accumulator_num_accumulated with options.
pub fn accumulator_num_accumulated_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &AccumulatorNumAccumulated,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AccumulatorNumAccumulated")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AccumulatorSetGlobalStep
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AccumulatorSetGlobalStep {}

impl AccumulatorSetGlobalStep {
    /// Creates a new `AccumulatorSetGlobalStep`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// accumulator_set_global_step with default options.
pub fn accumulator_set_global_step<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    new_global_step: T1,
) -> Result<()> {
    let __args = AccumulatorSetGlobalStep::new();
    accumulator_set_global_step_with_args(ctx, handle, new_global_step, &__args)
}

/// accumulator_set_global_step with options.
pub fn accumulator_set_global_step_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    new_global_step: T1,
    __args: &AccumulatorSetGlobalStep,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AccumulatorSetGlobalStep")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&new_global_step.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// AccumulatorTakeGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AccumulatorTakeGradient {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl AccumulatorTakeGradient {
    /// Creates a new `AccumulatorTakeGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// accumulator_take_gradient with default options.
pub fn accumulator_take_gradient<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    num_required: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AccumulatorTakeGradient::new();
    accumulator_take_gradient_with_args(ctx, handle, num_required, &__args)
}

/// accumulator_take_gradient with options.
pub fn accumulator_take_gradient_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    num_required: T1,
    __args: &AccumulatorTakeGradient,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AccumulatorTakeGradient")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&num_required.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Acos
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Acos {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Acos {
    /// Creates a new `Acos`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// acos with default options.
pub fn acos<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Acos::new();
    acos_with_args(ctx, x, &__args)
}

/// acos with options.
pub fn acos_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Acos,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Acos")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Acosh
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Acosh {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Acosh {
    /// Creates a new `Acosh`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// acosh with default options.
pub fn acosh<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Acosh::new();
    acosh_with_args(ctx, x, &__args)
}

/// acosh with options.
pub fn acosh_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Acosh,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Acosh")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Add
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Add {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Add {
    /// Creates a new `Add`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// add with default options.
pub fn add<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Add::new();
    add_with_args(ctx, x, y, &__args)
}

/// add with options.
pub fn add_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Add,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Add")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AddManySparseToTensorsMap
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AddManySparseToTensorsMap {
    pub T: ::std::option::Option<crate::DataType>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl AddManySparseToTensorsMap {
    /// Creates a new `AddManySparseToTensorsMap`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// add_many_sparse_to_tensors_map with default options.
pub fn add_many_sparse_to_tensors_map<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_indices: T0,
    sparse_values: T1,
    sparse_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = AddManySparseToTensorsMap::new();
    add_many_sparse_to_tensors_map_with_args(
        ctx,
        sparse_indices,
        sparse_values,
        sparse_shape,
        &__args,
    )
}

/// add_many_sparse_to_tensors_map with options.
pub fn add_many_sparse_to_tensors_map_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_indices: T0,
    sparse_values: T1,
    sparse_shape: T2,
    __args: &AddManySparseToTensorsMap,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AddManySparseToTensorsMap")?;

    // Required input arguments
    op.add_input(&sparse_indices.to_handle()?)?;
    op.add_input(&sparse_values.to_handle()?)?;
    op.add_input(&sparse_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AddN
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AddN {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl AddN {
    /// Creates a new `AddN`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// add_n with default options.
pub fn add_n<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = AddN::new();
    add_n_with_args(ctx, inputs, &__args)
}

/// add_n with options.
pub fn add_n_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &AddN,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AddN")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AddSparseToTensorsMap
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AddSparseToTensorsMap {
    pub T: ::std::option::Option<crate::DataType>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl AddSparseToTensorsMap {
    /// Creates a new `AddSparseToTensorsMap`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// add_sparse_to_tensors_map with default options.
pub fn add_sparse_to_tensors_map<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_indices: T0,
    sparse_values: T1,
    sparse_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = AddSparseToTensorsMap::new();
    add_sparse_to_tensors_map_with_args(ctx, sparse_indices, sparse_values, sparse_shape, &__args)
}

/// add_sparse_to_tensors_map with options.
pub fn add_sparse_to_tensors_map_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_indices: T0,
    sparse_values: T1,
    sparse_shape: T2,
    __args: &AddSparseToTensorsMap,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AddSparseToTensorsMap")?;

    // Required input arguments
    op.add_input(&sparse_indices.to_handle()?)?;
    op.add_input(&sparse_values.to_handle()?)?;
    op.add_input(&sparse_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AddV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AddV2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl AddV2 {
    /// Creates a new `AddV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// add_v2 with default options.
pub fn add_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AddV2::new();
    add_v2_with_args(ctx, x, y, &__args)
}

/// add_v2 with options.
pub fn add_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &AddV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AddV2")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AdjustContrast
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AdjustContrast {
    pub T: ::std::option::Option<crate::DataType>,
}

impl AdjustContrast {
    /// Creates a new `AdjustContrast`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// adjust_contrast with default options.
pub fn adjust_contrast<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    contrast_factor: T1,
    min_value: T2,
    max_value: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = AdjustContrast::new();
    adjust_contrast_with_args(ctx, images, contrast_factor, min_value, max_value, &__args)
}

/// adjust_contrast with options.
pub fn adjust_contrast_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    contrast_factor: T1,
    min_value: T2,
    max_value: T3,
    __args: &AdjustContrast,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AdjustContrast")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&contrast_factor.to_handle()?)?;
    op.add_input(&min_value.to_handle()?)?;
    op.add_input(&max_value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AdjustContrastv2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AdjustContrastv2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl AdjustContrastv2 {
    /// Creates a new `AdjustContrastv2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// adjust_contrastv2 with default options.
pub fn adjust_contrastv2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    contrast_factor: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AdjustContrastv2::new();
    adjust_contrastv2_with_args(ctx, images, contrast_factor, &__args)
}

/// adjust_contrastv2 with options.
pub fn adjust_contrastv2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    contrast_factor: T1,
    __args: &AdjustContrastv2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AdjustContrastv2")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&contrast_factor.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AdjustHue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AdjustHue {
    pub T: ::std::option::Option<crate::DataType>,
}

impl AdjustHue {
    /// Creates a new `AdjustHue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// adjust_hue with default options.
pub fn adjust_hue<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    delta: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AdjustHue::new();
    adjust_hue_with_args(ctx, images, delta, &__args)
}

/// adjust_hue with options.
pub fn adjust_hue_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    delta: T1,
    __args: &AdjustHue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AdjustHue")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&delta.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AdjustSaturation
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AdjustSaturation {
    pub T: ::std::option::Option<crate::DataType>,
}

impl AdjustSaturation {
    /// Creates a new `AdjustSaturation`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// adjust_saturation with default options.
pub fn adjust_saturation<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    scale: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AdjustSaturation::new();
    adjust_saturation_with_args(ctx, images, scale, &__args)
}

/// adjust_saturation with options.
pub fn adjust_saturation_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    scale: T1,
    __args: &AdjustSaturation,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AdjustSaturation")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&scale.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// All
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct All {
    pub keep_dims: ::std::option::Option<bool>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl All {
    /// Creates a new `All`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// all with default options.
pub fn all<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = All::new();
    all_with_args(ctx, input, reduction_indices, &__args)
}

/// all with options.
pub fn all_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
    __args: &All,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "All")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&reduction_indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AllCandidateSampler
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AllCandidateSampler {
    pub num_true: ::std::option::Option<i64>,
    pub num_sampled: ::std::option::Option<i64>,
    pub unique: ::std::option::Option<bool>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
}

impl AllCandidateSampler {
    /// Creates a new `AllCandidateSampler`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// all_candidate_sampler with default options.
pub fn all_candidate_sampler<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = AllCandidateSampler::new();
    all_candidate_sampler_with_args(ctx, true_classes, &__args)
}

/// all_candidate_sampler with options.
pub fn all_candidate_sampler_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
    __args: &AllCandidateSampler,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AllCandidateSampler")?;

    // Required input arguments
    op.add_input(&true_classes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_true {
        op.set_attr_int("num_true", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_sampled {
        op.set_attr_int("num_sampled", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.unique {
        op.set_attr_bool("unique", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// AllToAll
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AllToAll {
    pub T: ::std::option::Option<crate::DataType>,
    pub concat_dimension: ::std::option::Option<i64>,
    pub split_dimension: ::std::option::Option<i64>,
    pub split_count: ::std::option::Option<i64>,
}

impl AllToAll {
    /// Creates a new `AllToAll`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// all_to_all with default options.
pub fn all_to_all<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    group_assignment: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AllToAll::new();
    all_to_all_with_args(ctx, input, group_assignment, &__args)
}

/// all_to_all with options.
pub fn all_to_all_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    group_assignment: T1,
    __args: &AllToAll,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AllToAll")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&group_assignment.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.concat_dimension {
        op.set_attr_int("concat_dimension", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.split_dimension {
        op.set_attr_int("split_dimension", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.split_count {
        op.set_attr_int("split_count", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Angle
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Angle {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl Angle {
    /// Creates a new `Angle`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// angle with default options.
pub fn angle<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Angle::new();
    angle_with_args(ctx, input, &__args)
}

/// angle with options.
pub fn angle_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Angle,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Angle")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AnonymousIterator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AnonymousIterator {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl AnonymousIterator {
    /// Creates a new `AnonymousIterator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// anonymous_iterator with default options.
pub fn anonymous_iterator(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = AnonymousIterator::new();
    anonymous_iterator_with_args(ctx, &__args)
}

/// anonymous_iterator with options.
pub fn anonymous_iterator_with_args(
    ctx: &crate::eager::Context,
    __args: &AnonymousIterator,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AnonymousIterator")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AnonymousIteratorV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AnonymousIteratorV2 {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl AnonymousIteratorV2 {
    /// Creates a new `AnonymousIteratorV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// anonymous_iterator_v2 with default options.
pub fn anonymous_iterator_v2(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = AnonymousIteratorV2::new();
    anonymous_iterator_v2_with_args(ctx, &__args)
}

/// anonymous_iterator_v2 with options.
pub fn anonymous_iterator_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &AnonymousIteratorV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AnonymousIteratorV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// AnonymousMemoryCache
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AnonymousMemoryCache {}

impl AnonymousMemoryCache {
    /// Creates a new `AnonymousMemoryCache`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// anonymous_memory_cache with default options.
pub fn anonymous_memory_cache(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = AnonymousMemoryCache::new();
    anonymous_memory_cache_with_args(ctx, &__args)
}

/// anonymous_memory_cache with options.
pub fn anonymous_memory_cache_with_args(
    ctx: &crate::eager::Context,
    __args: &AnonymousMemoryCache,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AnonymousMemoryCache")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// AnonymousMultiDeviceIterator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AnonymousMultiDeviceIterator {
    pub devices: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl AnonymousMultiDeviceIterator {
    /// Creates a new `AnonymousMultiDeviceIterator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// anonymous_multi_device_iterator with default options.
pub fn anonymous_multi_device_iterator(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = AnonymousMultiDeviceIterator::new();
    anonymous_multi_device_iterator_with_args(ctx, &__args)
}

/// anonymous_multi_device_iterator with options.
pub fn anonymous_multi_device_iterator_with_args(
    ctx: &crate::eager::Context,
    __args: &AnonymousMultiDeviceIterator,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AnonymousMultiDeviceIterator")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.devices {
        op.set_attr_string_list("devices", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// AnonymousRandomSeedGenerator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AnonymousRandomSeedGenerator {}

impl AnonymousRandomSeedGenerator {
    /// Creates a new `AnonymousRandomSeedGenerator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// anonymous_random_seed_generator with default options.
pub fn anonymous_random_seed_generator<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    seed: T0,
    seed2: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = AnonymousRandomSeedGenerator::new();
    anonymous_random_seed_generator_with_args(ctx, seed, seed2, &__args)
}

/// anonymous_random_seed_generator with options.
pub fn anonymous_random_seed_generator_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    seed: T0,
    seed2: T1,
    __args: &AnonymousRandomSeedGenerator,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AnonymousRandomSeedGenerator")?;

    // Required input arguments
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&seed2.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// AnonymousSeedGenerator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AnonymousSeedGenerator {}

impl AnonymousSeedGenerator {
    /// Creates a new `AnonymousSeedGenerator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// anonymous_seed_generator with default options.
pub fn anonymous_seed_generator<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    seed: T0,
    seed2: T1,
    reshuffle: T2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = AnonymousSeedGenerator::new();
    anonymous_seed_generator_with_args(ctx, seed, seed2, reshuffle, &__args)
}

/// anonymous_seed_generator with options.
pub fn anonymous_seed_generator_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    seed: T0,
    seed2: T1,
    reshuffle: T2,
    __args: &AnonymousSeedGenerator,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AnonymousSeedGenerator")?;

    // Required input arguments
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&seed2.to_handle()?)?;
    op.add_input(&reshuffle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Any
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Any {
    pub keep_dims: ::std::option::Option<bool>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl Any {
    /// Creates a new `Any`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// any with default options.
pub fn any<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Any::new();
    any_with_args(ctx, input, reduction_indices, &__args)
}

/// any with options.
pub fn any_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
    __args: &Any,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Any")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&reduction_indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyAdaMax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAdaMax {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ApplyAdaMax {
    /// Creates a new `ApplyAdaMax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_ada_max with default options.
pub fn apply_ada_max<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    v: T2,
    beta1_power: T3,
    lr: T4,
    beta1: T5,
    beta2: T6,
    epsilon: T7,
    grad: T8,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyAdaMax::new();
    apply_ada_max_with_args(
        ctx,
        var,
        m,
        v,
        beta1_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad,
        &__args,
    )
}

/// apply_ada_max with options.
pub fn apply_ada_max_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    v: T2,
    beta1_power: T3,
    lr: T4,
    beta1: T5,
    beta2: T6,
    epsilon: T7,
    grad: T8,
    __args: &ApplyAdaMax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyAdaMax")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;
    op.add_input(&beta1_power.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&beta1.to_handle()?)?;
    op.add_input(&beta2.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyAdadelta
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAdadelta {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ApplyAdadelta {
    /// Creates a new `ApplyAdadelta`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_adadelta with default options.
pub fn apply_adadelta<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    accum_update: T2,
    lr: T3,
    rho: T4,
    epsilon: T5,
    grad: T6,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyAdadelta::new();
    apply_adadelta_with_args(
        ctx,
        var,
        accum,
        accum_update,
        lr,
        rho,
        epsilon,
        grad,
        &__args,
    )
}

/// apply_adadelta with options.
pub fn apply_adadelta_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    accum_update: T2,
    lr: T3,
    rho: T4,
    epsilon: T5,
    grad: T6,
    __args: &ApplyAdadelta,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyAdadelta")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&accum_update.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&rho.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyAdagrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAdagrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub update_slots: ::std::option::Option<bool>,
}

impl ApplyAdagrad {
    /// Creates a new `ApplyAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_adagrad with default options.
pub fn apply_adagrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyAdagrad::new();
    apply_adagrad_with_args(ctx, var, accum, lr, grad, &__args)
}

/// apply_adagrad with options.
pub fn apply_adagrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    __args: &ApplyAdagrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyAdagrad")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.update_slots {
        op.set_attr_bool("update_slots", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyAdagradDA
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAdagradDA {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ApplyAdagradDA {
    /// Creates a new `ApplyAdagradDA`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_adagrad_da with default options.
pub fn apply_adagrad_da<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    gradient_accumulator: T1,
    gradient_squared_accumulator: T2,
    grad: T3,
    lr: T4,
    l1: T5,
    l2: T6,
    global_step: T7,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyAdagradDA::new();
    apply_adagrad_da_with_args(
        ctx,
        var,
        gradient_accumulator,
        gradient_squared_accumulator,
        grad,
        lr,
        l1,
        l2,
        global_step,
        &__args,
    )
}

/// apply_adagrad_da with options.
pub fn apply_adagrad_da_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    gradient_accumulator: T1,
    gradient_squared_accumulator: T2,
    grad: T3,
    lr: T4,
    l1: T5,
    l2: T6,
    global_step: T7,
    __args: &ApplyAdagradDA,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyAdagradDA")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&gradient_accumulator.to_handle()?)?;
    op.add_input(&gradient_squared_accumulator.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&global_step.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyAdagradV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAdagradV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub update_slots: ::std::option::Option<bool>,
}

impl ApplyAdagradV2 {
    /// Creates a new `ApplyAdagradV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_adagrad_v2 with default options.
pub fn apply_adagrad_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    epsilon: T3,
    grad: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyAdagradV2::new();
    apply_adagrad_v2_with_args(ctx, var, accum, lr, epsilon, grad, &__args)
}

/// apply_adagrad_v2 with options.
pub fn apply_adagrad_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    epsilon: T3,
    grad: T4,
    __args: &ApplyAdagradV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyAdagradV2")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.update_slots {
        op.set_attr_bool("update_slots", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyAdam
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAdam {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub use_nesterov: ::std::option::Option<bool>,
}

impl ApplyAdam {
    /// Creates a new `ApplyAdam`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_adam with default options.
pub fn apply_adam<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    v: T2,
    beta1_power: T3,
    beta2_power: T4,
    lr: T5,
    beta1: T6,
    beta2: T7,
    epsilon: T8,
    grad: T9,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyAdam::new();
    apply_adam_with_args(
        ctx,
        var,
        m,
        v,
        beta1_power,
        beta2_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad,
        &__args,
    )
}

/// apply_adam with options.
pub fn apply_adam_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    v: T2,
    beta1_power: T3,
    beta2_power: T4,
    lr: T5,
    beta1: T6,
    beta2: T7,
    epsilon: T8,
    grad: T9,
    __args: &ApplyAdam,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyAdam")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;
    op.add_input(&beta1_power.to_handle()?)?;
    op.add_input(&beta2_power.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&beta1.to_handle()?)?;
    op.add_input(&beta2.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_nesterov {
        op.set_attr_bool("use_nesterov", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyAddSign
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAddSign {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ApplyAddSign {
    /// Creates a new `ApplyAddSign`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_add_sign with default options.
pub fn apply_add_sign<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    lr: T2,
    alpha: T3,
    sign_decay: T4,
    beta: T5,
    grad: T6,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyAddSign::new();
    apply_add_sign_with_args(ctx, var, m, lr, alpha, sign_decay, beta, grad, &__args)
}

/// apply_add_sign with options.
pub fn apply_add_sign_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    lr: T2,
    alpha: T3,
    sign_decay: T4,
    beta: T5,
    grad: T6,
    __args: &ApplyAddSign,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyAddSign")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&alpha.to_handle()?)?;
    op.add_input(&sign_decay.to_handle()?)?;
    op.add_input(&beta.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyCenteredRMSProp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyCenteredRMSProp {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ApplyCenteredRMSProp {
    /// Creates a new `ApplyCenteredRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_centered_rmsprop with default options.
pub fn apply_centered_rmsprop<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    mg: T1,
    ms: T2,
    mom: T3,
    lr: T4,
    rho: T5,
    momentum: T6,
    epsilon: T7,
    grad: T8,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyCenteredRMSProp::new();
    apply_centered_rmsprop_with_args(
        ctx, var, mg, ms, mom, lr, rho, momentum, epsilon, grad, &__args,
    )
}

/// apply_centered_rmsprop with options.
pub fn apply_centered_rmsprop_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    mg: T1,
    ms: T2,
    mom: T3,
    lr: T4,
    rho: T5,
    momentum: T6,
    epsilon: T7,
    grad: T8,
    __args: &ApplyCenteredRMSProp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyCenteredRMSProp")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&mg.to_handle()?)?;
    op.add_input(&ms.to_handle()?)?;
    op.add_input(&mom.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&rho.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyFtrl
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyFtrl {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub multiply_linear_by_lr: ::std::option::Option<bool>,
}

impl ApplyFtrl {
    /// Creates a new `ApplyFtrl`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_ftrl with default options.
pub fn apply_ftrl<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    lr: T4,
    l1: T5,
    l2: T6,
    lr_power: T7,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyFtrl::new();
    apply_ftrl_with_args(ctx, var, accum, linear, grad, lr, l1, l2, lr_power, &__args)
}

/// apply_ftrl with options.
pub fn apply_ftrl_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    lr: T4,
    l1: T5,
    l2: T6,
    lr_power: T7,
    __args: &ApplyFtrl,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyFtrl")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&linear.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&lr_power.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.multiply_linear_by_lr {
        op.set_attr_bool("multiply_linear_by_lr", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyFtrlV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyFtrlV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub multiply_linear_by_lr: ::std::option::Option<bool>,
}

impl ApplyFtrlV2 {
    /// Creates a new `ApplyFtrlV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_ftrl_v2 with default options.
pub fn apply_ftrl_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    lr: T4,
    l1: T5,
    l2: T6,
    l2_shrinkage: T7,
    lr_power: T8,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyFtrlV2::new();
    apply_ftrl_v2_with_args(
        ctx,
        var,
        accum,
        linear,
        grad,
        lr,
        l1,
        l2,
        l2_shrinkage,
        lr_power,
        &__args,
    )
}

/// apply_ftrl_v2 with options.
pub fn apply_ftrl_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    lr: T4,
    l1: T5,
    l2: T6,
    l2_shrinkage: T7,
    lr_power: T8,
    __args: &ApplyFtrlV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyFtrlV2")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&linear.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&l2_shrinkage.to_handle()?)?;
    op.add_input(&lr_power.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.multiply_linear_by_lr {
        op.set_attr_bool("multiply_linear_by_lr", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyGradientDescent
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyGradientDescent {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ApplyGradientDescent {
    /// Creates a new `ApplyGradientDescent`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_gradient_descent with default options.
pub fn apply_gradient_descent<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    alpha: T1,
    delta: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyGradientDescent::new();
    apply_gradient_descent_with_args(ctx, var, alpha, delta, &__args)
}

/// apply_gradient_descent with options.
pub fn apply_gradient_descent_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    alpha: T1,
    delta: T2,
    __args: &ApplyGradientDescent,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyGradientDescent")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&alpha.to_handle()?)?;
    op.add_input(&delta.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyMomentum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyMomentum {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub use_nesterov: ::std::option::Option<bool>,
}

impl ApplyMomentum {
    /// Creates a new `ApplyMomentum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_momentum with default options.
pub fn apply_momentum<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    momentum: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyMomentum::new();
    apply_momentum_with_args(ctx, var, accum, lr, grad, momentum, &__args)
}

/// apply_momentum with options.
pub fn apply_momentum_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    momentum: T4,
    __args: &ApplyMomentum,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyMomentum")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_nesterov {
        op.set_attr_bool("use_nesterov", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyPowerSign
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyPowerSign {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ApplyPowerSign {
    /// Creates a new `ApplyPowerSign`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_power_sign with default options.
pub fn apply_power_sign<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    lr: T2,
    logbase: T3,
    sign_decay: T4,
    beta: T5,
    grad: T6,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyPowerSign::new();
    apply_power_sign_with_args(ctx, var, m, lr, logbase, sign_decay, beta, grad, &__args)
}

/// apply_power_sign with options.
pub fn apply_power_sign_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    lr: T2,
    logbase: T3,
    sign_decay: T4,
    beta: T5,
    grad: T6,
    __args: &ApplyPowerSign,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyPowerSign")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&logbase.to_handle()?)?;
    op.add_input(&sign_decay.to_handle()?)?;
    op.add_input(&beta.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyProximalAdagrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyProximalAdagrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ApplyProximalAdagrad {
    /// Creates a new `ApplyProximalAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_proximal_adagrad with default options.
pub fn apply_proximal_adagrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    l1: T3,
    l2: T4,
    grad: T5,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyProximalAdagrad::new();
    apply_proximal_adagrad_with_args(ctx, var, accum, lr, l1, l2, grad, &__args)
}

/// apply_proximal_adagrad with options.
pub fn apply_proximal_adagrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    l1: T3,
    l2: T4,
    grad: T5,
    __args: &ApplyProximalAdagrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyProximalAdagrad")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyProximalGradientDescent
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyProximalGradientDescent {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ApplyProximalGradientDescent {
    /// Creates a new `ApplyProximalGradientDescent`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_proximal_gradient_descent with default options.
pub fn apply_proximal_gradient_descent<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    alpha: T1,
    l1: T2,
    l2: T3,
    delta: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyProximalGradientDescent::new();
    apply_proximal_gradient_descent_with_args(ctx, var, alpha, l1, l2, delta, &__args)
}

/// apply_proximal_gradient_descent with options.
pub fn apply_proximal_gradient_descent_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    alpha: T1,
    l1: T2,
    l2: T3,
    delta: T4,
    __args: &ApplyProximalGradientDescent,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyProximalGradientDescent")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&alpha.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&delta.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApplyRMSProp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyRMSProp {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ApplyRMSProp {
    /// Creates a new `ApplyRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// apply_rmsprop with default options.
pub fn apply_rmsprop<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    ms: T1,
    mom: T2,
    lr: T3,
    rho: T4,
    momentum: T5,
    epsilon: T6,
    grad: T7,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApplyRMSProp::new();
    apply_rmsprop_with_args(ctx, var, ms, mom, lr, rho, momentum, epsilon, grad, &__args)
}

/// apply_rmsprop with options.
pub fn apply_rmsprop_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    ms: T1,
    mom: T2,
    lr: T3,
    rho: T4,
    momentum: T5,
    epsilon: T6,
    grad: T7,
    __args: &ApplyRMSProp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApplyRMSProp")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&ms.to_handle()?)?;
    op.add_input(&mom.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&rho.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ApproximateEqual
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApproximateEqual {
    pub T: ::std::option::Option<crate::DataType>,
    pub tolerance: ::std::option::Option<f32>,
}

impl ApproximateEqual {
    /// Creates a new `ApproximateEqual`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// approximate_equal with default options.
pub fn approximate_equal<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ApproximateEqual::new();
    approximate_equal_with_args(ctx, x, y, &__args)
}

/// approximate_equal with options.
pub fn approximate_equal_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &ApproximateEqual,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ApproximateEqual")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tolerance {
        op.set_attr_float("tolerance", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ArgMax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ArgMax {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub output_type: ::std::option::Option<crate::DataType>,
}

impl ArgMax {
    /// Creates a new `ArgMax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// arg_max with default options.
pub fn arg_max<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    dimension: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ArgMax::new();
    arg_max_with_args(ctx, input, dimension, &__args)
}

/// arg_max with options.
pub fn arg_max_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    dimension: T1,
    __args: &ArgMax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ArgMax")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&dimension.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_type {
        op.set_attr_type("output_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ArgMin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ArgMin {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub output_type: ::std::option::Option<crate::DataType>,
}

impl ArgMin {
    /// Creates a new `ArgMin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// arg_min with default options.
pub fn arg_min<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    dimension: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ArgMin::new();
    arg_min_with_args(ctx, input, dimension, &__args)
}

/// arg_min with options.
pub fn arg_min_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    dimension: T1,
    __args: &ArgMin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ArgMin")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&dimension.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_type {
        op.set_attr_type("output_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AsString
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AsString {
    pub T: ::std::option::Option<crate::DataType>,
    pub precision: ::std::option::Option<i64>,
    pub scientific: ::std::option::Option<bool>,
    pub shortest: ::std::option::Option<bool>,
    pub width: ::std::option::Option<i64>,
    pub fill: ::std::option::Option<::std::string::String>,
}

impl AsString {
    /// Creates a new `AsString`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// as_string with default options.
pub fn as_string<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = AsString::new();
    as_string_with_args(ctx, input, &__args)
}

/// as_string with options.
pub fn as_string_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &AsString,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AsString")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.precision {
        op.set_attr_int("precision", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.scientific {
        op.set_attr_bool("scientific", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shortest {
        op.set_attr_bool("shortest", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.width {
        op.set_attr_int("width", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.fill {
        op.set_attr_string("fill", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Asin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Asin {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Asin {
    /// Creates a new `Asin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// asin with default options.
pub fn asin<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Asin::new();
    asin_with_args(ctx, x, &__args)
}

/// asin with options.
pub fn asin_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Asin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Asin")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Asinh
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Asinh {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Asinh {
    /// Creates a new `Asinh`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// asinh with default options.
pub fn asinh<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Asinh::new();
    asinh_with_args(ctx, x, &__args)
}

/// asinh with options.
pub fn asinh_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Asinh,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Asinh")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Assert
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Assert {
    pub T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub summarize: ::std::option::Option<i64>,
}

impl Assert {
    /// Creates a new `Assert`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// assert with default options.
pub fn assert<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    condition: T0,
    data: T1,
) -> Result<()> {
    let __args = Assert::new();
    assert_with_args(ctx, condition, data, &__args)
}

/// assert with options.
pub fn assert_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    condition: T0,
    data: T1,
    __args: &Assert,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Assert")?;

    // Required input arguments
    op.add_input(&condition.to_handle()?)?;
    op.add_input(&data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type_list("T", value);
    }
    if let ::std::option::Option::Some(value) = &__args.summarize {
        op.set_attr_int("summarize", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// AssertCardinalityDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssertCardinalityDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl AssertCardinalityDataset {
    /// Creates a new `AssertCardinalityDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// assert_cardinality_dataset with default options.
pub fn assert_cardinality_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    cardinality: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AssertCardinalityDataset::new();
    assert_cardinality_dataset_with_args(ctx, input_dataset, cardinality, &__args)
}

/// assert_cardinality_dataset with options.
pub fn assert_cardinality_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    cardinality: T1,
    __args: &AssertCardinalityDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AssertCardinalityDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&cardinality.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AssertNextDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssertNextDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl AssertNextDataset {
    /// Creates a new `AssertNextDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// assert_next_dataset with default options.
pub fn assert_next_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    transformations: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AssertNextDataset::new();
    assert_next_dataset_with_args(ctx, input_dataset, transformations, &__args)
}

/// assert_next_dataset with options.
pub fn assert_next_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    transformations: T1,
    __args: &AssertNextDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AssertNextDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&transformations.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Assign
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Assign {
    pub T: ::std::option::Option<crate::DataType>,
    pub validate_shape: ::std::option::Option<bool>,
    pub use_locking: ::std::option::Option<bool>,
}

impl Assign {
    /// Creates a new `Assign`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// assign with default options.
pub fn assign<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    ref_: T0,
    value: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Assign::new();
    assign_with_args(ctx, ref_, value, &__args)
}

/// assign with options.
pub fn assign_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    ref_: T0,
    value: T1,
    __args: &Assign,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Assign")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.validate_shape {
        op.set_attr_bool("validate_shape", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AssignAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssignAdd {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl AssignAdd {
    /// Creates a new `AssignAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// assign_add with default options.
pub fn assign_add<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    ref_: T0,
    value: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AssignAdd::new();
    assign_add_with_args(ctx, ref_, value, &__args)
}

/// assign_add with options.
pub fn assign_add_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    ref_: T0,
    value: T1,
    __args: &AssignAdd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AssignAdd")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AssignAddVariableOp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssignAddVariableOp {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl AssignAddVariableOp {
    /// Creates a new `AssignAddVariableOp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// assign_add_variable_op with default options.
pub fn assign_add_variable_op<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    value: T1,
) -> Result<()> {
    let __args = AssignAddVariableOp::new();
    assign_add_variable_op_with_args(ctx, resource, value, &__args)
}

/// assign_add_variable_op with options.
pub fn assign_add_variable_op_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    value: T1,
    __args: &AssignAddVariableOp,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AssignAddVariableOp")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// AssignSub
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssignSub {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl AssignSub {
    /// Creates a new `AssignSub`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// assign_sub with default options.
pub fn assign_sub<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    ref_: T0,
    value: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AssignSub::new();
    assign_sub_with_args(ctx, ref_, value, &__args)
}

/// assign_sub with options.
pub fn assign_sub_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    ref_: T0,
    value: T1,
    __args: &AssignSub,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AssignSub")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AssignSubVariableOp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssignSubVariableOp {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl AssignSubVariableOp {
    /// Creates a new `AssignSubVariableOp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// assign_sub_variable_op with default options.
pub fn assign_sub_variable_op<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    value: T1,
) -> Result<()> {
    let __args = AssignSubVariableOp::new();
    assign_sub_variable_op_with_args(ctx, resource, value, &__args)
}

/// assign_sub_variable_op with options.
pub fn assign_sub_variable_op_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    value: T1,
    __args: &AssignSubVariableOp,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AssignSubVariableOp")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// AssignVariableOp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssignVariableOp {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl AssignVariableOp {
    /// Creates a new `AssignVariableOp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// assign_variable_op with default options.
pub fn assign_variable_op<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    value: T1,
) -> Result<()> {
    let __args = AssignVariableOp::new();
    assign_variable_op_with_args(ctx, resource, value, &__args)
}

/// assign_variable_op with options.
pub fn assign_variable_op_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    value: T1,
    __args: &AssignVariableOp,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AssignVariableOp")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Atan
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Atan {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Atan {
    /// Creates a new `Atan`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// atan with default options.
pub fn atan<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Atan::new();
    atan_with_args(ctx, x, &__args)
}

/// atan with options.
pub fn atan_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Atan,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Atan")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Atan2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Atan2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Atan2 {
    /// Creates a new `Atan2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// atan2 with default options.
pub fn atan2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    x: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Atan2::new();
    atan2_with_args(ctx, y, x, &__args)
}

/// atan2 with options.
pub fn atan2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    x: T1,
    __args: &Atan2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Atan2")?;

    // Required input arguments
    op.add_input(&y.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Atanh
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Atanh {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Atanh {
    /// Creates a new `Atanh`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// atanh with default options.
pub fn atanh<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Atanh::new();
    atanh_with_args(ctx, x, &__args)
}

/// atanh with options.
pub fn atanh_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Atanh,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Atanh")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AudioSpectrogram
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AudioSpectrogram {
    pub window_size: ::std::option::Option<i64>,
    pub stride: ::std::option::Option<i64>,
    pub magnitude_squared: ::std::option::Option<bool>,
}

impl AudioSpectrogram {
    /// Creates a new `AudioSpectrogram`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// audio_spectrogram with default options.
pub fn audio_spectrogram<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = AudioSpectrogram::new();
    audio_spectrogram_with_args(ctx, input, &__args)
}

/// audio_spectrogram with options.
pub fn audio_spectrogram_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &AudioSpectrogram,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AudioSpectrogram")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.window_size {
        op.set_attr_int("window_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.stride {
        op.set_attr_int("stride", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.magnitude_squared {
        op.set_attr_bool("magnitude_squared", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AudioSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AudioSummary {
    pub sample_rate: ::std::option::Option<f32>,
    pub max_outputs: ::std::option::Option<i64>,
}

impl AudioSummary {
    /// Creates a new `AudioSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// audio_summary with default options.
pub fn audio_summary<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tag: T0,
    tensor: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AudioSummary::new();
    audio_summary_with_args(ctx, tag, tensor, &__args)
}

/// audio_summary with options.
pub fn audio_summary_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tag: T0,
    tensor: T1,
    __args: &AudioSummary,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AudioSummary")?;

    // Required input arguments
    op.add_input(&tag.to_handle()?)?;
    op.add_input(&tensor.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.sample_rate {
        op.set_attr_float("sample_rate", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_outputs {
        op.set_attr_int("max_outputs", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AudioSummaryV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AudioSummaryV2 {
    pub max_outputs: ::std::option::Option<i64>,
}

impl AudioSummaryV2 {
    /// Creates a new `AudioSummaryV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// audio_summary_v2 with default options.
pub fn audio_summary_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tag: T0,
    tensor: T1,
    sample_rate: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = AudioSummaryV2::new();
    audio_summary_v2_with_args(ctx, tag, tensor, sample_rate, &__args)
}

/// audio_summary_v2 with options.
pub fn audio_summary_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tag: T0,
    tensor: T1,
    sample_rate: T2,
    __args: &AudioSummaryV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AudioSummaryV2")?;

    // Required input arguments
    op.add_input(&tag.to_handle()?)?;
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&sample_rate.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.max_outputs {
        op.set_attr_int("max_outputs", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AutoShardDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AutoShardDataset {
    pub auto_shard_policy: ::std::option::Option<i64>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub num_replicas: ::std::option::Option<i64>,
}

impl AutoShardDataset {
    /// Creates a new `AutoShardDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// auto_shard_dataset with default options.
pub fn auto_shard_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_workers: T1,
    index: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = AutoShardDataset::new();
    auto_shard_dataset_with_args(ctx, input_dataset, num_workers, index, &__args)
}

/// auto_shard_dataset with options.
pub fn auto_shard_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_workers: T1,
    index: T2,
    __args: &AutoShardDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AutoShardDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&num_workers.to_handle()?)?;
    op.add_input(&index.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.auto_shard_policy {
        op.set_attr_int("auto_shard_policy", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.num_replicas {
        op.set_attr_int("num_replicas", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AvgPool
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AvgPool {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl AvgPool {
    /// Creates a new `AvgPool`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// avg_pool with default options.
pub fn avg_pool<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = AvgPool::new();
    avg_pool_with_args(ctx, value, &__args)
}

/// avg_pool with options.
pub fn avg_pool_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
    __args: &AvgPool,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AvgPool")?;

    // Required input arguments
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AvgPool3D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AvgPool3D {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl AvgPool3D {
    /// Creates a new `AvgPool3D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// avg_pool3_d with default options.
pub fn avg_pool3_d<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = AvgPool3D::new();
    avg_pool3_d_with_args(ctx, input, &__args)
}

/// avg_pool3_d with options.
pub fn avg_pool3_d_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &AvgPool3D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AvgPool3D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AvgPool3DGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AvgPool3DGrad {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl AvgPool3DGrad {
    /// Creates a new `AvgPool3DGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// avg_pool3_dgrad with default options.
pub fn avg_pool3_dgrad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    orig_input_shape: T0,
    grad: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AvgPool3DGrad::new();
    avg_pool3_dgrad_with_args(ctx, orig_input_shape, grad, &__args)
}

/// avg_pool3_dgrad with options.
pub fn avg_pool3_dgrad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    orig_input_shape: T0,
    grad: T1,
    __args: &AvgPool3DGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AvgPool3DGrad")?;

    // Required input arguments
    op.add_input(&orig_input_shape.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// AvgPoolGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AvgPoolGrad {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl AvgPoolGrad {
    /// Creates a new `AvgPoolGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// avg_pool_grad with default options.
pub fn avg_pool_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    orig_input_shape: T0,
    grad: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = AvgPoolGrad::new();
    avg_pool_grad_with_args(ctx, orig_input_shape, grad, &__args)
}

/// avg_pool_grad with options.
pub fn avg_pool_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    orig_input_shape: T0,
    grad: T1,
    __args: &AvgPoolGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "AvgPoolGrad")?;

    // Required input arguments
    op.add_input(&orig_input_shape.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BandedTriangularSolve
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BandedTriangularSolve {
    pub lower: ::std::option::Option<bool>,
    pub adjoint: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl BandedTriangularSolve {
    /// Creates a new `BandedTriangularSolve`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// banded_triangular_solve with default options.
pub fn banded_triangular_solve<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BandedTriangularSolve::new();
    banded_triangular_solve_with_args(ctx, matrix, rhs, &__args)
}

/// banded_triangular_solve with options.
pub fn banded_triangular_solve_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
    __args: &BandedTriangularSolve,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BandedTriangularSolve")?;

    // Required input arguments
    op.add_input(&matrix.to_handle()?)?;
    op.add_input(&rhs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.lower {
        op.set_attr_bool("lower", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adjoint {
        op.set_attr_bool("adjoint", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Barrier
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Barrier {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub capacity: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl Barrier {
    /// Creates a new `Barrier`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// barrier with default options.
pub fn barrier(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = Barrier::new();
    barrier_with_args(ctx, &__args)
}

/// barrier with options.
pub fn barrier_with_args(
    ctx: &crate::eager::Context,
    __args: &Barrier,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Barrier")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BarrierClose
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BarrierClose {
    pub cancel_pending_enqueues: ::std::option::Option<bool>,
}

impl BarrierClose {
    /// Creates a new `BarrierClose`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// barrier_close with default options.
pub fn barrier_close<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<()> {
    let __args = BarrierClose::new();
    barrier_close_with_args(ctx, handle, &__args)
}

/// barrier_close with options.
pub fn barrier_close_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &BarrierClose,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BarrierClose")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.cancel_pending_enqueues {
        op.set_attr_bool("cancel_pending_enqueues", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// BarrierIncompleteSize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BarrierIncompleteSize {}

impl BarrierIncompleteSize {
    /// Creates a new `BarrierIncompleteSize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// barrier_incomplete_size with default options.
pub fn barrier_incomplete_size<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BarrierIncompleteSize::new();
    barrier_incomplete_size_with_args(ctx, handle, &__args)
}

/// barrier_incomplete_size with options.
pub fn barrier_incomplete_size_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &BarrierIncompleteSize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BarrierIncompleteSize")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BarrierInsertMany
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BarrierInsertMany {
    pub T: ::std::option::Option<crate::DataType>,
    pub component_index: ::std::option::Option<i64>,
}

impl BarrierInsertMany {
    /// Creates a new `BarrierInsertMany`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// barrier_insert_many with default options.
pub fn barrier_insert_many<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    keys: T1,
    values: T2,
) -> Result<()> {
    let __args = BarrierInsertMany::new();
    barrier_insert_many_with_args(ctx, handle, keys, values, &__args)
}

/// barrier_insert_many with options.
pub fn barrier_insert_many_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    keys: T1,
    values: T2,
    __args: &BarrierInsertMany,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BarrierInsertMany")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&keys.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.component_index {
        op.set_attr_int("component_index", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// BarrierReadySize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BarrierReadySize {}

impl BarrierReadySize {
    /// Creates a new `BarrierReadySize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// barrier_ready_size with default options.
pub fn barrier_ready_size<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BarrierReadySize::new();
    barrier_ready_size_with_args(ctx, handle, &__args)
}

/// barrier_ready_size with options.
pub fn barrier_ready_size_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &BarrierReadySize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BarrierReadySize")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BarrierTakeMany
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BarrierTakeMany {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub allow_small_batch: ::std::option::Option<bool>,
    pub wait_for_incomplete: ::std::option::Option<bool>,
    pub timeout_ms: ::std::option::Option<i64>,
}

impl BarrierTakeMany {
    /// Creates a new `BarrierTakeMany`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// barrier_take_many with default options.
pub fn barrier_take_many<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    num_elements: T1,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = BarrierTakeMany::new();
    barrier_take_many_with_args(ctx, handle, num_elements, &__args)
}

/// barrier_take_many with options.
pub fn barrier_take_many_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    num_elements: T1,
    __args: &BarrierTakeMany,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BarrierTakeMany")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&num_elements.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.allow_small_batch {
        op.set_attr_bool("allow_small_batch", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.wait_for_incomplete {
        op.set_attr_bool("wait_for_incomplete", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_ms {
        op.set_attr_int("timeout_ms", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Batch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Batch {
    pub num_batch_threads: ::std::option::Option<i64>,
    pub max_batch_size: ::std::option::Option<i64>,
    pub max_enqueued_batches: ::std::option::Option<i64>,
    pub batch_timeout_micros: ::std::option::Option<i64>,
    pub allowed_batch_sizes: ::std::option::Option<::std::vec::Vec<i64>>,
    pub grad_timeout_micros: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub batching_queue: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl Batch {
    /// Creates a new `Batch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch with default options.
pub fn batch<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    in_tensors: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = Batch::new();
    batch_with_args(ctx, in_tensors, &__args)
}

/// batch with options.
pub fn batch_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    in_tensors: T0,
    __args: &Batch,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Batch")?;

    // Required input arguments
    op.add_input(&in_tensors.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_batch_threads {
        op.set_attr_int("num_batch_threads", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_batch_size {
        op.set_attr_int("max_batch_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_enqueued_batches {
        op.set_attr_int("max_enqueued_batches", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.batch_timeout_micros {
        op.set_attr_int("batch_timeout_micros", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.allowed_batch_sizes {
        op.set_attr_int_list("allowed_batch_sizes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.grad_timeout_micros {
        op.set_attr_int("grad_timeout_micros", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.batching_queue {
        op.set_attr_string("batching_queue", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type_list("T", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BatchCholesky
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchCholesky {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchCholesky {
    /// Creates a new `BatchCholesky`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_cholesky with default options.
pub fn batch_cholesky<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchCholesky::new();
    batch_cholesky_with_args(ctx, input, &__args)
}

/// batch_cholesky with options.
pub fn batch_cholesky_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchCholesky,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchCholesky")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchCholeskyGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchCholeskyGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchCholeskyGrad {
    /// Creates a new `BatchCholeskyGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_cholesky_grad with default options.
pub fn batch_cholesky_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    l: T0,
    grad: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchCholeskyGrad::new();
    batch_cholesky_grad_with_args(ctx, l, grad, &__args)
}

/// batch_cholesky_grad with options.
pub fn batch_cholesky_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    l: T0,
    grad: T1,
    __args: &BatchCholeskyGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchCholeskyGrad")?;

    // Required input arguments
    op.add_input(&l.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl BatchDataset {
    /// Creates a new `BatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_dataset with default options.
pub fn batch_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchDataset::new();
    batch_dataset_with_args(ctx, input_dataset, batch_size, &__args)
}

/// batch_dataset with options.
pub fn batch_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    __args: &BatchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&batch_size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchDatasetV2 {
    pub parallel_copy: ::std::option::Option<bool>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl BatchDatasetV2 {
    /// Creates a new `BatchDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_dataset_v2 with default options.
pub fn batch_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    drop_remainder: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchDatasetV2::new();
    batch_dataset_v2_with_args(ctx, input_dataset, batch_size, drop_remainder, &__args)
}

/// batch_dataset_v2 with options.
pub fn batch_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    drop_remainder: T2,
    __args: &BatchDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchDatasetV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&batch_size.to_handle()?)?;
    op.add_input(&drop_remainder.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.parallel_copy {
        op.set_attr_bool("parallel_copy", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchFFT
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchFFT {}

impl BatchFFT {
    /// Creates a new `BatchFFT`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_fft with default options.
pub fn batch_fft<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchFFT::new();
    batch_fft_with_args(ctx, input, &__args)
}

/// batch_fft with options.
pub fn batch_fft_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchFFT,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchFFT")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchFFT2D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchFFT2D {}

impl BatchFFT2D {
    /// Creates a new `BatchFFT2D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_fft2_d with default options.
pub fn batch_fft2_d<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchFFT2D::new();
    batch_fft2_d_with_args(ctx, input, &__args)
}

/// batch_fft2_d with options.
pub fn batch_fft2_d_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchFFT2D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchFFT2D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchFFT3D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchFFT3D {}

impl BatchFFT3D {
    /// Creates a new `BatchFFT3D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_fft3_d with default options.
pub fn batch_fft3_d<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchFFT3D::new();
    batch_fft3_d_with_args(ctx, input, &__args)
}

/// batch_fft3_d with options.
pub fn batch_fft3_d_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchFFT3D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchFFT3D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchFunction
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchFunction {
    pub f: ::std::option::Option<::std::string::String>,
    pub num_batch_threads: ::std::option::Option<i64>,
    pub max_batch_size: ::std::option::Option<i64>,
    pub batch_timeout_micros: ::std::option::Option<i64>,
    pub max_enqueued_batches: ::std::option::Option<i64>,
    pub allowed_batch_sizes: ::std::option::Option<::std::vec::Vec<i64>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub batching_queue: ::std::option::Option<::std::string::String>,
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tcaptured: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub enable_large_batch_splitting: ::std::option::Option<bool>,
}

impl BatchFunction {
    /// Creates a new `BatchFunction`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_function with default options.
pub fn batch_function<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    in_tensors: T0,
    captured_tensors: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchFunction::new();
    batch_function_with_args(ctx, in_tensors, captured_tensors, &__args)
}

/// batch_function with options.
pub fn batch_function_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    in_tensors: T0,
    captured_tensors: T1,
    __args: &BatchFunction,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchFunction")?;

    // Required input arguments
    op.add_input(&in_tensors.to_handle()?)?;
    op.add_input(&captured_tensors.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_batch_threads {
        op.set_attr_int("num_batch_threads", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_batch_size {
        op.set_attr_int("max_batch_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.batch_timeout_micros {
        op.set_attr_int("batch_timeout_micros", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_enqueued_batches {
        op.set_attr_int("max_enqueued_batches", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.allowed_batch_sizes {
        op.set_attr_int_list("allowed_batch_sizes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.batching_queue {
        op.set_attr_string("batching_queue", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcaptured {
        op.set_attr_type_list("Tcaptured", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }
    if let ::std::option::Option::Some(value) = &__args.enable_large_batch_splitting {
        op.set_attr_bool("enable_large_batch_splitting", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchIFFT
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchIFFT {}

impl BatchIFFT {
    /// Creates a new `BatchIFFT`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_ifft with default options.
pub fn batch_ifft<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchIFFT::new();
    batch_ifft_with_args(ctx, input, &__args)
}

/// batch_ifft with options.
pub fn batch_ifft_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchIFFT,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchIFFT")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchIFFT2D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchIFFT2D {}

impl BatchIFFT2D {
    /// Creates a new `BatchIFFT2D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_ifft2_d with default options.
pub fn batch_ifft2_d<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchIFFT2D::new();
    batch_ifft2_d_with_args(ctx, input, &__args)
}

/// batch_ifft2_d with options.
pub fn batch_ifft2_d_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchIFFT2D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchIFFT2D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchIFFT3D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchIFFT3D {}

impl BatchIFFT3D {
    /// Creates a new `BatchIFFT3D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_ifft3_d with default options.
pub fn batch_ifft3_d<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchIFFT3D::new();
    batch_ifft3_d_with_args(ctx, input, &__args)
}

/// batch_ifft3_d with options.
pub fn batch_ifft3_d_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchIFFT3D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchIFFT3D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchMatMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatMul {
    pub T: ::std::option::Option<crate::DataType>,
    pub adj_x: ::std::option::Option<bool>,
    pub adj_y: ::std::option::Option<bool>,
}

impl BatchMatMul {
    /// Creates a new `BatchMatMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_mat_mul with default options.
pub fn batch_mat_mul<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchMatMul::new();
    batch_mat_mul_with_args(ctx, x, y, &__args)
}

/// batch_mat_mul with options.
pub fn batch_mat_mul_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &BatchMatMul,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchMatMul")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adj_x {
        op.set_attr_bool("adj_x", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adj_y {
        op.set_attr_bool("adj_y", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchMatMulV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatMulV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub adj_x: ::std::option::Option<bool>,
    pub adj_y: ::std::option::Option<bool>,
}

impl BatchMatMulV2 {
    /// Creates a new `BatchMatMulV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_mat_mul_v2 with default options.
pub fn batch_mat_mul_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchMatMulV2::new();
    batch_mat_mul_v2_with_args(ctx, x, y, &__args)
}

/// batch_mat_mul_v2 with options.
pub fn batch_mat_mul_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &BatchMatMulV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchMatMulV2")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adj_x {
        op.set_attr_bool("adj_x", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adj_y {
        op.set_attr_bool("adj_y", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchMatMulV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatMulV3 {
    pub Ta: ::std::option::Option<crate::DataType>,
    pub Tb: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
    pub adj_x: ::std::option::Option<bool>,
    pub adj_y: ::std::option::Option<bool>,
}

impl BatchMatMulV3 {
    /// Creates a new `BatchMatMulV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_mat_mul_v3 with default options.
pub fn batch_mat_mul_v3<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchMatMulV3::new();
    batch_mat_mul_v3_with_args(ctx, x, y, &__args)
}

/// batch_mat_mul_v3 with options.
pub fn batch_mat_mul_v3_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &BatchMatMulV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchMatMulV3")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Ta {
        op.set_attr_type("Ta", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tb {
        op.set_attr_type("Tb", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adj_x {
        op.set_attr_bool("adj_x", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adj_y {
        op.set_attr_bool("adj_y", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchMatrixBandPart
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixBandPart {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchMatrixBandPart {
    /// Creates a new `BatchMatrixBandPart`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_matrix_band_part with default options.
pub fn batch_matrix_band_part<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    num_lower: T1,
    num_upper: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchMatrixBandPart::new();
    batch_matrix_band_part_with_args(ctx, input, num_lower, num_upper, &__args)
}

/// batch_matrix_band_part with options.
pub fn batch_matrix_band_part_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    num_lower: T1,
    num_upper: T2,
    __args: &BatchMatrixBandPart,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchMatrixBandPart")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&num_lower.to_handle()?)?;
    op.add_input(&num_upper.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchMatrixDeterminant
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixDeterminant {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchMatrixDeterminant {
    /// Creates a new `BatchMatrixDeterminant`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_matrix_determinant with default options.
pub fn batch_matrix_determinant<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchMatrixDeterminant::new();
    batch_matrix_determinant_with_args(ctx, input, &__args)
}

/// batch_matrix_determinant with options.
pub fn batch_matrix_determinant_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchMatrixDeterminant,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchMatrixDeterminant")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchMatrixDiag
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixDiag {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchMatrixDiag {
    /// Creates a new `BatchMatrixDiag`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_matrix_diag with default options.
pub fn batch_matrix_diag<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    diagonal: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchMatrixDiag::new();
    batch_matrix_diag_with_args(ctx, diagonal, &__args)
}

/// batch_matrix_diag with options.
pub fn batch_matrix_diag_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    diagonal: T0,
    __args: &BatchMatrixDiag,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchMatrixDiag")?;

    // Required input arguments
    op.add_input(&diagonal.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchMatrixDiagPart
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixDiagPart {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchMatrixDiagPart {
    /// Creates a new `BatchMatrixDiagPart`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_matrix_diag_part with default options.
pub fn batch_matrix_diag_part<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchMatrixDiagPart::new();
    batch_matrix_diag_part_with_args(ctx, input, &__args)
}

/// batch_matrix_diag_part with options.
pub fn batch_matrix_diag_part_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchMatrixDiagPart,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchMatrixDiagPart")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchMatrixInverse
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixInverse {
    pub adjoint: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchMatrixInverse {
    /// Creates a new `BatchMatrixInverse`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_matrix_inverse with default options.
pub fn batch_matrix_inverse<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchMatrixInverse::new();
    batch_matrix_inverse_with_args(ctx, input, &__args)
}

/// batch_matrix_inverse with options.
pub fn batch_matrix_inverse_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchMatrixInverse,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchMatrixInverse")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.adjoint {
        op.set_attr_bool("adjoint", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchMatrixSetDiag
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixSetDiag {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchMatrixSetDiag {
    /// Creates a new `BatchMatrixSetDiag`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_matrix_set_diag with default options.
pub fn batch_matrix_set_diag<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    diagonal: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchMatrixSetDiag::new();
    batch_matrix_set_diag_with_args(ctx, input, diagonal, &__args)
}

/// batch_matrix_set_diag with options.
pub fn batch_matrix_set_diag_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    diagonal: T1,
    __args: &BatchMatrixSetDiag,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchMatrixSetDiag")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&diagonal.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchMatrixSolve
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixSolve {
    pub adjoint: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchMatrixSolve {
    /// Creates a new `BatchMatrixSolve`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_matrix_solve with default options.
pub fn batch_matrix_solve<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchMatrixSolve::new();
    batch_matrix_solve_with_args(ctx, matrix, rhs, &__args)
}

/// batch_matrix_solve with options.
pub fn batch_matrix_solve_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
    __args: &BatchMatrixSolve,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchMatrixSolve")?;

    // Required input arguments
    op.add_input(&matrix.to_handle()?)?;
    op.add_input(&rhs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.adjoint {
        op.set_attr_bool("adjoint", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchMatrixSolveLs
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixSolveLs {
    pub T: ::std::option::Option<crate::DataType>,
    pub fast: ::std::option::Option<bool>,
}

impl BatchMatrixSolveLs {
    /// Creates a new `BatchMatrixSolveLs`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_matrix_solve_ls with default options.
pub fn batch_matrix_solve_ls<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
    l2_regularizer: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchMatrixSolveLs::new();
    batch_matrix_solve_ls_with_args(ctx, matrix, rhs, l2_regularizer, &__args)
}

/// batch_matrix_solve_ls with options.
pub fn batch_matrix_solve_ls_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
    l2_regularizer: T2,
    __args: &BatchMatrixSolveLs,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchMatrixSolveLs")?;

    // Required input arguments
    op.add_input(&matrix.to_handle()?)?;
    op.add_input(&rhs.to_handle()?)?;
    op.add_input(&l2_regularizer.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.fast {
        op.set_attr_bool("fast", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchMatrixTriangularSolve
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixTriangularSolve {
    pub lower: ::std::option::Option<bool>,
    pub adjoint: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchMatrixTriangularSolve {
    /// Creates a new `BatchMatrixTriangularSolve`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_matrix_triangular_solve with default options.
pub fn batch_matrix_triangular_solve<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchMatrixTriangularSolve::new();
    batch_matrix_triangular_solve_with_args(ctx, matrix, rhs, &__args)
}

/// batch_matrix_triangular_solve with options.
pub fn batch_matrix_triangular_solve_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
    __args: &BatchMatrixTriangularSolve,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchMatrixTriangularSolve")?;

    // Required input arguments
    op.add_input(&matrix.to_handle()?)?;
    op.add_input(&rhs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.lower {
        op.set_attr_bool("lower", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adjoint {
        op.set_attr_bool("adjoint", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchNormWithGlobalNormalization
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchNormWithGlobalNormalization {
    pub T: ::std::option::Option<crate::DataType>,
    pub variance_epsilon: ::std::option::Option<f32>,
    pub scale_after_normalization: ::std::option::Option<bool>,
}

impl BatchNormWithGlobalNormalization {
    /// Creates a new `BatchNormWithGlobalNormalization`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_norm_with_global_normalization with default options.
pub fn batch_norm_with_global_normalization<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    t: T0,
    m: T1,
    v: T2,
    beta: T3,
    gamma: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchNormWithGlobalNormalization::new();
    batch_norm_with_global_normalization_with_args(ctx, t, m, v, beta, gamma, &__args)
}

/// batch_norm_with_global_normalization with options.
pub fn batch_norm_with_global_normalization_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    t: T0,
    m: T1,
    v: T2,
    beta: T3,
    gamma: T4,
    __args: &BatchNormWithGlobalNormalization,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchNormWithGlobalNormalization")?;

    // Required input arguments
    op.add_input(&t.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;
    op.add_input(&beta.to_handle()?)?;
    op.add_input(&gamma.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.variance_epsilon {
        op.set_attr_float("variance_epsilon", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.scale_after_normalization {
        op.set_attr_bool("scale_after_normalization", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchNormWithGlobalNormalizationGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchNormWithGlobalNormalizationGrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub variance_epsilon: ::std::option::Option<f32>,
    pub scale_after_normalization: ::std::option::Option<bool>,
}

impl BatchNormWithGlobalNormalizationGrad {
    /// Creates a new `BatchNormWithGlobalNormalizationGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_norm_with_global_normalization_grad with default options.
pub fn batch_norm_with_global_normalization_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    t: T0,
    m: T1,
    v: T2,
    gamma: T3,
    backprop: T4,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let __args = BatchNormWithGlobalNormalizationGrad::new();
    batch_norm_with_global_normalization_grad_with_args(ctx, t, m, v, gamma, backprop, &__args)
}

/// batch_norm_with_global_normalization_grad with options.
pub fn batch_norm_with_global_normalization_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    t: T0,
    m: T1,
    v: T2,
    gamma: T3,
    backprop: T4,
    __args: &BatchNormWithGlobalNormalizationGrad,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchNormWithGlobalNormalizationGrad")?;

    // Required input arguments
    op.add_input(&t.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;
    op.add_input(&gamma.to_handle()?)?;
    op.add_input(&backprop.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.variance_epsilon {
        op.set_attr_float("variance_epsilon", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.scale_after_normalization {
        op.set_attr_bool("scale_after_normalization", *value);
    }

    // Execute Op
    let mut num_output = 5;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 5];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BatchSelfAdjointEig
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchSelfAdjointEig {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchSelfAdjointEig {
    /// Creates a new `BatchSelfAdjointEig`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_self_adjoint_eig with default options.
pub fn batch_self_adjoint_eig<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchSelfAdjointEig::new();
    batch_self_adjoint_eig_with_args(ctx, input, &__args)
}

/// batch_self_adjoint_eig with options.
pub fn batch_self_adjoint_eig_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchSelfAdjointEig,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchSelfAdjointEig")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchSelfAdjointEigV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchSelfAdjointEigV2 {
    pub compute_v: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchSelfAdjointEigV2 {
    /// Creates a new `BatchSelfAdjointEigV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_self_adjoint_eig_v2 with default options.
pub fn batch_self_adjoint_eig_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = BatchSelfAdjointEigV2::new();
    batch_self_adjoint_eig_v2_with_args(ctx, input, &__args)
}

/// batch_self_adjoint_eig_v2 with options.
pub fn batch_self_adjoint_eig_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchSelfAdjointEigV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchSelfAdjointEigV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.compute_v {
        op.set_attr_bool("compute_v", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BatchSvd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchSvd {
    pub compute_uv: ::std::option::Option<bool>,
    pub full_matrices: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl BatchSvd {
    /// Creates a new `BatchSvd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_svd with default options.
pub fn batch_svd<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = BatchSvd::new();
    batch_svd_with_args(ctx, input, &__args)
}

/// batch_svd with options.
pub fn batch_svd_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &BatchSvd,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchSvd")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.compute_uv {
        op.set_attr_bool("compute_uv", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.full_matrices {
        op.set_attr_bool("full_matrices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BatchToSpace
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchToSpace {
    pub T: ::std::option::Option<crate::DataType>,
    pub block_size: ::std::option::Option<i64>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl BatchToSpace {
    /// Creates a new `BatchToSpace`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_to_space with default options.
pub fn batch_to_space<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    crops: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchToSpace::new();
    batch_to_space_with_args(ctx, input, crops, &__args)
}

/// batch_to_space with options.
pub fn batch_to_space_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    crops: T1,
    __args: &BatchToSpace,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchToSpace")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&crops.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.block_size {
        op.set_attr_int("block_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BatchToSpaceND
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchToSpaceND {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tblock_shape: ::std::option::Option<crate::DataType>,
    pub Tcrops: ::std::option::Option<crate::DataType>,
}

impl BatchToSpaceND {
    /// Creates a new `BatchToSpaceND`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// batch_to_space_nd with default options.
pub fn batch_to_space_nd<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    block_shape: T1,
    crops: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = BatchToSpaceND::new();
    batch_to_space_nd_with_args(ctx, input, block_shape, crops, &__args)
}

/// batch_to_space_nd with options.
pub fn batch_to_space_nd_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    block_shape: T1,
    crops: T2,
    __args: &BatchToSpaceND,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BatchToSpaceND")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&block_shape.to_handle()?)?;
    op.add_input(&crops.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tblock_shape {
        op.set_attr_type("Tblock_shape", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcrops {
        op.set_attr_type("Tcrops", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BesselI0
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselI0 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BesselI0 {
    /// Creates a new `BesselI0`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bessel_i0 with default options.
pub fn bessel_i0<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BesselI0::new();
    bessel_i0_with_args(ctx, x, &__args)
}

/// bessel_i0 with options.
pub fn bessel_i0_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &BesselI0,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BesselI0")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BesselI0e
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselI0e {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BesselI0e {
    /// Creates a new `BesselI0e`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bessel_i0e with default options.
pub fn bessel_i0e<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BesselI0e::new();
    bessel_i0e_with_args(ctx, x, &__args)
}

/// bessel_i0e with options.
pub fn bessel_i0e_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &BesselI0e,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BesselI0e")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BesselI1
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselI1 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BesselI1 {
    /// Creates a new `BesselI1`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bessel_i1 with default options.
pub fn bessel_i1<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BesselI1::new();
    bessel_i1_with_args(ctx, x, &__args)
}

/// bessel_i1 with options.
pub fn bessel_i1_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &BesselI1,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BesselI1")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BesselI1e
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselI1e {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BesselI1e {
    /// Creates a new `BesselI1e`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bessel_i1e with default options.
pub fn bessel_i1e<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BesselI1e::new();
    bessel_i1e_with_args(ctx, x, &__args)
}

/// bessel_i1e with options.
pub fn bessel_i1e_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &BesselI1e,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BesselI1e")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BesselJ0
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselJ0 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BesselJ0 {
    /// Creates a new `BesselJ0`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bessel_j0 with default options.
pub fn bessel_j0<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BesselJ0::new();
    bessel_j0_with_args(ctx, x, &__args)
}

/// bessel_j0 with options.
pub fn bessel_j0_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &BesselJ0,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BesselJ0")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BesselJ1
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselJ1 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BesselJ1 {
    /// Creates a new `BesselJ1`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bessel_j1 with default options.
pub fn bessel_j1<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BesselJ1::new();
    bessel_j1_with_args(ctx, x, &__args)
}

/// bessel_j1 with options.
pub fn bessel_j1_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &BesselJ1,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BesselJ1")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BesselK0
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselK0 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BesselK0 {
    /// Creates a new `BesselK0`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bessel_k0 with default options.
pub fn bessel_k0<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BesselK0::new();
    bessel_k0_with_args(ctx, x, &__args)
}

/// bessel_k0 with options.
pub fn bessel_k0_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &BesselK0,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BesselK0")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BesselK0e
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselK0e {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BesselK0e {
    /// Creates a new `BesselK0e`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bessel_k0e with default options.
pub fn bessel_k0e<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BesselK0e::new();
    bessel_k0e_with_args(ctx, x, &__args)
}

/// bessel_k0e with options.
pub fn bessel_k0e_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &BesselK0e,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BesselK0e")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BesselK1
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselK1 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BesselK1 {
    /// Creates a new `BesselK1`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bessel_k1 with default options.
pub fn bessel_k1<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BesselK1::new();
    bessel_k1_with_args(ctx, x, &__args)
}

/// bessel_k1 with options.
pub fn bessel_k1_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &BesselK1,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BesselK1")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BesselK1e
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselK1e {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BesselK1e {
    /// Creates a new `BesselK1e`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bessel_k1e with default options.
pub fn bessel_k1e<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BesselK1e::new();
    bessel_k1e_with_args(ctx, x, &__args)
}

/// bessel_k1e with options.
pub fn bessel_k1e_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &BesselK1e,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BesselK1e")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BesselY0
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselY0 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BesselY0 {
    /// Creates a new `BesselY0`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bessel_y0 with default options.
pub fn bessel_y0<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BesselY0::new();
    bessel_y0_with_args(ctx, x, &__args)
}

/// bessel_y0 with options.
pub fn bessel_y0_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &BesselY0,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BesselY0")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BesselY1
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselY1 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BesselY1 {
    /// Creates a new `BesselY1`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bessel_y1 with default options.
pub fn bessel_y1<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BesselY1::new();
    bessel_y1_with_args(ctx, x, &__args)
}

/// bessel_y1 with options.
pub fn bessel_y1_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &BesselY1,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BesselY1")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Betainc
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Betainc {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Betainc {
    /// Creates a new `Betainc`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// betainc with default options.
pub fn betainc<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    x: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Betainc::new();
    betainc_with_args(ctx, a, b, x, &__args)
}

/// betainc with options.
pub fn betainc_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    x: T2,
    __args: &Betainc,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Betainc")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BiasAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BiasAdd {
    pub T: ::std::option::Option<crate::DataType>,
    pub data_format: ::std::option::Option<::std::string::String>,
}

impl BiasAdd {
    /// Creates a new `BiasAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bias_add with default options.
pub fn bias_add<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
    bias: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BiasAdd::new();
    bias_add_with_args(ctx, value, bias, &__args)
}

/// bias_add with options.
pub fn bias_add_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
    bias: T1,
    __args: &BiasAdd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BiasAdd")?;

    // Required input arguments
    op.add_input(&value.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BiasAddGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BiasAddGrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub data_format: ::std::option::Option<::std::string::String>,
}

impl BiasAddGrad {
    /// Creates a new `BiasAddGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bias_add_grad with default options.
pub fn bias_add_grad<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    out_backprop: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BiasAddGrad::new();
    bias_add_grad_with_args(ctx, out_backprop, &__args)
}

/// bias_add_grad with options.
pub fn bias_add_grad_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    out_backprop: T0,
    __args: &BiasAddGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BiasAddGrad")?;

    // Required input arguments
    op.add_input(&out_backprop.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BiasAddV1
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BiasAddV1 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BiasAddV1 {
    /// Creates a new `BiasAddV1`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bias_add_v1 with default options.
pub fn bias_add_v1<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
    bias: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BiasAddV1::new();
    bias_add_v1_with_args(ctx, value, bias, &__args)
}

/// bias_add_v1 with options.
pub fn bias_add_v1_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
    bias: T1,
    __args: &BiasAddV1,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BiasAddV1")?;

    // Required input arguments
    op.add_input(&value.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Bincount
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Bincount {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Bincount {
    /// Creates a new `Bincount`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bincount with default options.
pub fn bincount<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    arr: T0,
    size: T1,
    weights: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Bincount::new();
    bincount_with_args(ctx, arr, size, weights, &__args)
}

/// bincount with options.
pub fn bincount_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    arr: T0,
    size: T1,
    weights: T2,
    __args: &Bincount,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Bincount")?;

    // Required input arguments
    op.add_input(&arr.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;
    op.add_input(&weights.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Bitcast
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Bitcast {
    pub T: ::std::option::Option<crate::DataType>,
    pub type_: ::std::option::Option<crate::DataType>,
}

impl Bitcast {
    /// Creates a new `Bitcast`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bitcast with default options.
pub fn bitcast<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Bitcast::new();
    bitcast_with_args(ctx, input, &__args)
}

/// bitcast with options.
pub fn bitcast_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Bitcast,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Bitcast")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.type_ {
        op.set_attr_type("type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BitwiseAnd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BitwiseAnd {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BitwiseAnd {
    /// Creates a new `BitwiseAnd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bitwise_and with default options.
pub fn bitwise_and<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BitwiseAnd::new();
    bitwise_and_with_args(ctx, x, y, &__args)
}

/// bitwise_and with options.
pub fn bitwise_and_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &BitwiseAnd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BitwiseAnd")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BitwiseOr
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BitwiseOr {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BitwiseOr {
    /// Creates a new `BitwiseOr`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bitwise_or with default options.
pub fn bitwise_or<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BitwiseOr::new();
    bitwise_or_with_args(ctx, x, y, &__args)
}

/// bitwise_or with options.
pub fn bitwise_or_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &BitwiseOr,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BitwiseOr")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BitwiseXor
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BitwiseXor {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BitwiseXor {
    /// Creates a new `BitwiseXor`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bitwise_xor with default options.
pub fn bitwise_xor<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BitwiseXor::new();
    bitwise_xor_with_args(ctx, x, y, &__args)
}

/// bitwise_xor with options.
pub fn bitwise_xor_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &BitwiseXor,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BitwiseXor")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BlockLSTM
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BlockLSTM {
    pub forget_bias: ::std::option::Option<f32>,
    pub cell_clip: ::std::option::Option<f32>,
    pub use_peephole: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl BlockLSTM {
    /// Creates a new `BlockLSTM`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// block_lstm with default options.
pub fn block_lstm<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    seq_len_max: T0,
    x: T1,
    cs_prev: T2,
    h_prev: T3,
    w: T4,
    wci: T5,
    wcf: T6,
    wco: T7,
    b: T8,
) -> Result<[crate::eager::TensorHandle; 7]> {
    let __args = BlockLSTM::new();
    block_lstm_with_args(
        ctx,
        seq_len_max,
        x,
        cs_prev,
        h_prev,
        w,
        wci,
        wcf,
        wco,
        b,
        &__args,
    )
}

/// block_lstm with options.
pub fn block_lstm_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    seq_len_max: T0,
    x: T1,
    cs_prev: T2,
    h_prev: T3,
    w: T4,
    wci: T5,
    wcf: T6,
    wco: T7,
    b: T8,
    __args: &BlockLSTM,
) -> Result<[crate::eager::TensorHandle; 7]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BlockLSTM")?;

    // Required input arguments
    op.add_input(&seq_len_max.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;
    op.add_input(&cs_prev.to_handle()?)?;
    op.add_input(&h_prev.to_handle()?)?;
    op.add_input(&w.to_handle()?)?;
    op.add_input(&wci.to_handle()?)?;
    op.add_input(&wcf.to_handle()?)?;
    op.add_input(&wco.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.forget_bias {
        op.set_attr_float("forget_bias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.cell_clip {
        op.set_attr_float("cell_clip", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_peephole {
        op.set_attr_bool("use_peephole", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 7;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 7];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
                crate::eager::TensorHandle::from_tensor_handle(res[6]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BlockLSTMGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BlockLSTMGrad {
    pub use_peephole: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl BlockLSTMGrad {
    /// Creates a new `BlockLSTMGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// block_lstmgrad with default options.
pub fn block_lstmgrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
    T12: crate::eager::ToHandle,
    T13: crate::eager::ToHandle,
    T14: crate::eager::ToHandle,
    T15: crate::eager::ToHandle,
    T16: crate::eager::ToHandle,
    T17: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    seq_len_max: T0,
    x: T1,
    cs_prev: T2,
    h_prev: T3,
    w: T4,
    wci: T5,
    wcf: T6,
    wco: T7,
    b: T8,
    i: T9,
    cs: T10,
    f: T11,
    o: T12,
    ci: T13,
    co: T14,
    h: T15,
    cs_grad: T16,
    h_grad: T17,
) -> Result<[crate::eager::TensorHandle; 8]> {
    let __args = BlockLSTMGrad::new();
    block_lstmgrad_with_args(
        ctx,
        seq_len_max,
        x,
        cs_prev,
        h_prev,
        w,
        wci,
        wcf,
        wco,
        b,
        i,
        cs,
        f,
        o,
        ci,
        co,
        h,
        cs_grad,
        h_grad,
        &__args,
    )
}

/// block_lstmgrad with options.
pub fn block_lstmgrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
    T12: crate::eager::ToHandle,
    T13: crate::eager::ToHandle,
    T14: crate::eager::ToHandle,
    T15: crate::eager::ToHandle,
    T16: crate::eager::ToHandle,
    T17: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    seq_len_max: T0,
    x: T1,
    cs_prev: T2,
    h_prev: T3,
    w: T4,
    wci: T5,
    wcf: T6,
    wco: T7,
    b: T8,
    i: T9,
    cs: T10,
    f: T11,
    o: T12,
    ci: T13,
    co: T14,
    h: T15,
    cs_grad: T16,
    h_grad: T17,
    __args: &BlockLSTMGrad,
) -> Result<[crate::eager::TensorHandle; 8]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BlockLSTMGrad")?;

    // Required input arguments
    op.add_input(&seq_len_max.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;
    op.add_input(&cs_prev.to_handle()?)?;
    op.add_input(&h_prev.to_handle()?)?;
    op.add_input(&w.to_handle()?)?;
    op.add_input(&wci.to_handle()?)?;
    op.add_input(&wcf.to_handle()?)?;
    op.add_input(&wco.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;
    op.add_input(&i.to_handle()?)?;
    op.add_input(&cs.to_handle()?)?;
    op.add_input(&f.to_handle()?)?;
    op.add_input(&o.to_handle()?)?;
    op.add_input(&ci.to_handle()?)?;
    op.add_input(&co.to_handle()?)?;
    op.add_input(&h.to_handle()?)?;
    op.add_input(&cs_grad.to_handle()?)?;
    op.add_input(&h_grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.use_peephole {
        op.set_attr_bool("use_peephole", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 8;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 8];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
                crate::eager::TensorHandle::from_tensor_handle(res[6]),
                crate::eager::TensorHandle::from_tensor_handle(res[7]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BlockLSTMGradV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BlockLSTMGradV2 {
    pub use_peephole: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl BlockLSTMGradV2 {
    /// Creates a new `BlockLSTMGradV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// block_lstmgrad_v2 with default options.
pub fn block_lstmgrad_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
    T12: crate::eager::ToHandle,
    T13: crate::eager::ToHandle,
    T14: crate::eager::ToHandle,
    T15: crate::eager::ToHandle,
    T16: crate::eager::ToHandle,
    T17: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    seq_len_max: T0,
    x: T1,
    cs_prev: T2,
    h_prev: T3,
    w: T4,
    wci: T5,
    wcf: T6,
    wco: T7,
    b: T8,
    i: T9,
    cs: T10,
    f: T11,
    o: T12,
    ci: T13,
    co: T14,
    h: T15,
    cs_grad: T16,
    h_grad: T17,
) -> Result<[crate::eager::TensorHandle; 8]> {
    let __args = BlockLSTMGradV2::new();
    block_lstmgrad_v2_with_args(
        ctx,
        seq_len_max,
        x,
        cs_prev,
        h_prev,
        w,
        wci,
        wcf,
        wco,
        b,
        i,
        cs,
        f,
        o,
        ci,
        co,
        h,
        cs_grad,
        h_grad,
        &__args,
    )
}

/// block_lstmgrad_v2 with options.
pub fn block_lstmgrad_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
    T12: crate::eager::ToHandle,
    T13: crate::eager::ToHandle,
    T14: crate::eager::ToHandle,
    T15: crate::eager::ToHandle,
    T16: crate::eager::ToHandle,
    T17: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    seq_len_max: T0,
    x: T1,
    cs_prev: T2,
    h_prev: T3,
    w: T4,
    wci: T5,
    wcf: T6,
    wco: T7,
    b: T8,
    i: T9,
    cs: T10,
    f: T11,
    o: T12,
    ci: T13,
    co: T14,
    h: T15,
    cs_grad: T16,
    h_grad: T17,
    __args: &BlockLSTMGradV2,
) -> Result<[crate::eager::TensorHandle; 8]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BlockLSTMGradV2")?;

    // Required input arguments
    op.add_input(&seq_len_max.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;
    op.add_input(&cs_prev.to_handle()?)?;
    op.add_input(&h_prev.to_handle()?)?;
    op.add_input(&w.to_handle()?)?;
    op.add_input(&wci.to_handle()?)?;
    op.add_input(&wcf.to_handle()?)?;
    op.add_input(&wco.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;
    op.add_input(&i.to_handle()?)?;
    op.add_input(&cs.to_handle()?)?;
    op.add_input(&f.to_handle()?)?;
    op.add_input(&o.to_handle()?)?;
    op.add_input(&ci.to_handle()?)?;
    op.add_input(&co.to_handle()?)?;
    op.add_input(&h.to_handle()?)?;
    op.add_input(&cs_grad.to_handle()?)?;
    op.add_input(&h_grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.use_peephole {
        op.set_attr_bool("use_peephole", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 8;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 8];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
                crate::eager::TensorHandle::from_tensor_handle(res[6]),
                crate::eager::TensorHandle::from_tensor_handle(res[7]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BlockLSTMV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BlockLSTMV2 {
    pub cell_clip: ::std::option::Option<f32>,
    pub use_peephole: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl BlockLSTMV2 {
    /// Creates a new `BlockLSTMV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// block_lstmv2 with default options.
pub fn block_lstmv2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    seq_len_max: T0,
    x: T1,
    cs_prev: T2,
    h_prev: T3,
    w: T4,
    wci: T5,
    wcf: T6,
    wco: T7,
    b: T8,
) -> Result<[crate::eager::TensorHandle; 7]> {
    let __args = BlockLSTMV2::new();
    block_lstmv2_with_args(
        ctx,
        seq_len_max,
        x,
        cs_prev,
        h_prev,
        w,
        wci,
        wcf,
        wco,
        b,
        &__args,
    )
}

/// block_lstmv2 with options.
pub fn block_lstmv2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    seq_len_max: T0,
    x: T1,
    cs_prev: T2,
    h_prev: T3,
    w: T4,
    wci: T5,
    wcf: T6,
    wco: T7,
    b: T8,
    __args: &BlockLSTMV2,
) -> Result<[crate::eager::TensorHandle; 7]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BlockLSTMV2")?;

    // Required input arguments
    op.add_input(&seq_len_max.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;
    op.add_input(&cs_prev.to_handle()?)?;
    op.add_input(&h_prev.to_handle()?)?;
    op.add_input(&w.to_handle()?)?;
    op.add_input(&wci.to_handle()?)?;
    op.add_input(&wcf.to_handle()?)?;
    op.add_input(&wco.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.cell_clip {
        op.set_attr_float("cell_clip", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_peephole {
        op.set_attr_bool("use_peephole", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 7;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 7];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
                crate::eager::TensorHandle::from_tensor_handle(res[6]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesAggregateStats
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesAggregateStats {
    pub max_splits: ::std::option::Option<i64>,
    pub num_buckets: ::std::option::Option<i64>,
}

impl BoostedTreesAggregateStats {
    /// Creates a new `BoostedTreesAggregateStats`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_aggregate_stats with default options.
pub fn boosted_trees_aggregate_stats<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_ids: T0,
    gradients: T1,
    hessians: T2,
    feature: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = BoostedTreesAggregateStats::new();
    boosted_trees_aggregate_stats_with_args(ctx, node_ids, gradients, hessians, feature, &__args)
}

/// boosted_trees_aggregate_stats with options.
pub fn boosted_trees_aggregate_stats_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_ids: T0,
    gradients: T1,
    hessians: T2,
    feature: T3,
    __args: &BoostedTreesAggregateStats,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesAggregateStats")?;

    // Required input arguments
    op.add_input(&node_ids.to_handle()?)?;
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&hessians.to_handle()?)?;
    op.add_input(&feature.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.max_splits {
        op.set_attr_int("max_splits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_buckets {
        op.set_attr_int("num_buckets", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesBucketize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesBucketize {
    pub num_features: ::std::option::Option<i64>,
}

impl BoostedTreesBucketize {
    /// Creates a new `BoostedTreesBucketize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_bucketize with default options.
pub fn boosted_trees_bucketize<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    float_values: T0,
    bucket_boundaries: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BoostedTreesBucketize::new();
    boosted_trees_bucketize_with_args(ctx, float_values, bucket_boundaries, &__args)
}

/// boosted_trees_bucketize with options.
pub fn boosted_trees_bucketize_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    float_values: T0,
    bucket_boundaries: T1,
    __args: &BoostedTreesBucketize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesBucketize")?;

    // Required input arguments
    op.add_input(&float_values.to_handle()?)?;
    op.add_input(&bucket_boundaries.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int("num_features", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesCalculateBestFeatureSplit
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesCalculateBestFeatureSplit {
    pub logits_dimension: ::std::option::Option<i64>,
    pub split_type: ::std::option::Option<::std::string::String>,
}

impl BoostedTreesCalculateBestFeatureSplit {
    /// Creates a new `BoostedTreesCalculateBestFeatureSplit`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_calculate_best_feature_split with default options.
pub fn boosted_trees_calculate_best_feature_split<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_id_range: T0,
    stats_summary: T1,
    l1: T2,
    l2: T3,
    tree_complexity: T4,
    min_node_weight: T5,
) -> Result<[crate::eager::TensorHandle; 7]> {
    let __args = BoostedTreesCalculateBestFeatureSplit::new();
    boosted_trees_calculate_best_feature_split_with_args(
        ctx,
        node_id_range,
        stats_summary,
        l1,
        l2,
        tree_complexity,
        min_node_weight,
        &__args,
    )
}

/// boosted_trees_calculate_best_feature_split with options.
pub fn boosted_trees_calculate_best_feature_split_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_id_range: T0,
    stats_summary: T1,
    l1: T2,
    l2: T3,
    tree_complexity: T4,
    min_node_weight: T5,
    __args: &BoostedTreesCalculateBestFeatureSplit,
) -> Result<[crate::eager::TensorHandle; 7]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesCalculateBestFeatureSplit")?;

    // Required input arguments
    op.add_input(&node_id_range.to_handle()?)?;
    op.add_input(&stats_summary.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&tree_complexity.to_handle()?)?;
    op.add_input(&min_node_weight.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.logits_dimension {
        op.set_attr_int("logits_dimension", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.split_type {
        op.set_attr_string("split_type", value);
    }

    // Execute Op
    let mut num_output = 7;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 7];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
                crate::eager::TensorHandle::from_tensor_handle(res[6]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesCalculateBestFeatureSplitV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesCalculateBestFeatureSplitV2 {
    pub num_features: ::std::option::Option<i64>,
    pub logits_dimension: ::std::option::Option<i64>,
}

impl BoostedTreesCalculateBestFeatureSplitV2 {
    /// Creates a new `BoostedTreesCalculateBestFeatureSplitV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_calculate_best_feature_split_v2 with default options.
pub fn boosted_trees_calculate_best_feature_split_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_id_range: T0,
    stats_summaries_list: T1,
    split_types: T2,
    candidate_feature_ids: T3,
    l1: T4,
    l2: T5,
    tree_complexity: T6,
    min_node_weight: T7,
) -> Result<[crate::eager::TensorHandle; 8]> {
    let __args = BoostedTreesCalculateBestFeatureSplitV2::new();
    boosted_trees_calculate_best_feature_split_v2_with_args(
        ctx,
        node_id_range,
        stats_summaries_list,
        split_types,
        candidate_feature_ids,
        l1,
        l2,
        tree_complexity,
        min_node_weight,
        &__args,
    )
}

/// boosted_trees_calculate_best_feature_split_v2 with options.
pub fn boosted_trees_calculate_best_feature_split_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_id_range: T0,
    stats_summaries_list: T1,
    split_types: T2,
    candidate_feature_ids: T3,
    l1: T4,
    l2: T5,
    tree_complexity: T6,
    min_node_weight: T7,
    __args: &BoostedTreesCalculateBestFeatureSplitV2,
) -> Result<[crate::eager::TensorHandle; 8]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesCalculateBestFeatureSplitV2")?;

    // Required input arguments
    op.add_input(&node_id_range.to_handle()?)?;
    op.add_input(&stats_summaries_list.to_handle()?)?;
    op.add_input(&split_types.to_handle()?)?;
    op.add_input(&candidate_feature_ids.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&tree_complexity.to_handle()?)?;
    op.add_input(&min_node_weight.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int("num_features", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.logits_dimension {
        op.set_attr_int("logits_dimension", *value);
    }

    // Execute Op
    let mut num_output = 8;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 8];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
                crate::eager::TensorHandle::from_tensor_handle(res[6]),
                crate::eager::TensorHandle::from_tensor_handle(res[7]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesCalculateBestGainsPerFeature
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesCalculateBestGainsPerFeature {
    pub max_splits: ::std::option::Option<i64>,
    pub num_features: ::std::option::Option<i64>,
}

impl BoostedTreesCalculateBestGainsPerFeature {
    /// Creates a new `BoostedTreesCalculateBestGainsPerFeature`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_calculate_best_gains_per_feature with default options.
pub fn boosted_trees_calculate_best_gains_per_feature<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_id_range: T0,
    stats_summary_list: T1,
    l1: T2,
    l2: T3,
    tree_complexity: T4,
    min_node_weight: T5,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let __args = BoostedTreesCalculateBestGainsPerFeature::new();
    boosted_trees_calculate_best_gains_per_feature_with_args(
        ctx,
        node_id_range,
        stats_summary_list,
        l1,
        l2,
        tree_complexity,
        min_node_weight,
        &__args,
    )
}

/// boosted_trees_calculate_best_gains_per_feature with options.
pub fn boosted_trees_calculate_best_gains_per_feature_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_id_range: T0,
    stats_summary_list: T1,
    l1: T2,
    l2: T3,
    tree_complexity: T4,
    min_node_weight: T5,
    __args: &BoostedTreesCalculateBestGainsPerFeature,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesCalculateBestGainsPerFeature")?;

    // Required input arguments
    op.add_input(&node_id_range.to_handle()?)?;
    op.add_input(&stats_summary_list.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&tree_complexity.to_handle()?)?;
    op.add_input(&min_node_weight.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.max_splits {
        op.set_attr_int("max_splits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int("num_features", *value);
    }

    // Execute Op
    let mut num_output = 5;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 5];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesCenterBias
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesCenterBias {}

impl BoostedTreesCenterBias {
    /// Creates a new `BoostedTreesCenterBias`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_center_bias with default options.
pub fn boosted_trees_center_bias<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    mean_gradients: T1,
    mean_hessians: T2,
    l1: T3,
    l2: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = BoostedTreesCenterBias::new();
    boosted_trees_center_bias_with_args(
        ctx,
        tree_ensemble_handle,
        mean_gradients,
        mean_hessians,
        l1,
        l2,
        &__args,
    )
}

/// boosted_trees_center_bias with options.
pub fn boosted_trees_center_bias_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    mean_gradients: T1,
    mean_hessians: T2,
    l1: T3,
    l2: T4,
    __args: &BoostedTreesCenterBias,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesCenterBias")?;

    // Required input arguments
    op.add_input(&tree_ensemble_handle.to_handle()?)?;
    op.add_input(&mean_gradients.to_handle()?)?;
    op.add_input(&mean_hessians.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesCreateEnsemble
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesCreateEnsemble {}

impl BoostedTreesCreateEnsemble {
    /// Creates a new `BoostedTreesCreateEnsemble`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_create_ensemble with default options.
pub fn boosted_trees_create_ensemble<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    stamp_token: T1,
    tree_ensemble_serialized: T2,
) -> Result<()> {
    let __args = BoostedTreesCreateEnsemble::new();
    boosted_trees_create_ensemble_with_args(
        ctx,
        tree_ensemble_handle,
        stamp_token,
        tree_ensemble_serialized,
        &__args,
    )
}

/// boosted_trees_create_ensemble with options.
pub fn boosted_trees_create_ensemble_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    stamp_token: T1,
    tree_ensemble_serialized: T2,
    __args: &BoostedTreesCreateEnsemble,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesCreateEnsemble")?;

    // Required input arguments
    op.add_input(&tree_ensemble_handle.to_handle()?)?;
    op.add_input(&stamp_token.to_handle()?)?;
    op.add_input(&tree_ensemble_serialized.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// BoostedTreesCreateQuantileStreamResource
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesCreateQuantileStreamResource {
    pub max_elements: ::std::option::Option<i64>,
}

impl BoostedTreesCreateQuantileStreamResource {
    /// Creates a new `BoostedTreesCreateQuantileStreamResource`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_create_quantile_stream_resource with default options.
pub fn boosted_trees_create_quantile_stream_resource<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
    epsilon: T1,
    num_streams: T2,
) -> Result<()> {
    let __args = BoostedTreesCreateQuantileStreamResource::new();
    boosted_trees_create_quantile_stream_resource_with_args(
        ctx,
        quantile_stream_resource_handle,
        epsilon,
        num_streams,
        &__args,
    )
}

/// boosted_trees_create_quantile_stream_resource with options.
pub fn boosted_trees_create_quantile_stream_resource_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
    epsilon: T1,
    num_streams: T2,
    __args: &BoostedTreesCreateQuantileStreamResource,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesCreateQuantileStreamResource")?;

    // Required input arguments
    op.add_input(&quantile_stream_resource_handle.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&num_streams.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.max_elements {
        op.set_attr_int("max_elements", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// BoostedTreesDeserializeEnsemble
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesDeserializeEnsemble {}

impl BoostedTreesDeserializeEnsemble {
    /// Creates a new `BoostedTreesDeserializeEnsemble`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_deserialize_ensemble with default options.
pub fn boosted_trees_deserialize_ensemble<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    stamp_token: T1,
    tree_ensemble_serialized: T2,
) -> Result<()> {
    let __args = BoostedTreesDeserializeEnsemble::new();
    boosted_trees_deserialize_ensemble_with_args(
        ctx,
        tree_ensemble_handle,
        stamp_token,
        tree_ensemble_serialized,
        &__args,
    )
}

/// boosted_trees_deserialize_ensemble with options.
pub fn boosted_trees_deserialize_ensemble_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    stamp_token: T1,
    tree_ensemble_serialized: T2,
    __args: &BoostedTreesDeserializeEnsemble,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesDeserializeEnsemble")?;

    // Required input arguments
    op.add_input(&tree_ensemble_handle.to_handle()?)?;
    op.add_input(&stamp_token.to_handle()?)?;
    op.add_input(&tree_ensemble_serialized.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// BoostedTreesEnsembleResourceHandleOp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesEnsembleResourceHandleOp {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl BoostedTreesEnsembleResourceHandleOp {
    /// Creates a new `BoostedTreesEnsembleResourceHandleOp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_ensemble_resource_handle_op with default options.
pub fn boosted_trees_ensemble_resource_handle_op(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = BoostedTreesEnsembleResourceHandleOp::new();
    boosted_trees_ensemble_resource_handle_op_with_args(ctx, &__args)
}

/// boosted_trees_ensemble_resource_handle_op with options.
pub fn boosted_trees_ensemble_resource_handle_op_with_args(
    ctx: &crate::eager::Context,
    __args: &BoostedTreesEnsembleResourceHandleOp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesEnsembleResourceHandleOp")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesExampleDebugOutputs
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesExampleDebugOutputs {
    pub num_bucketized_features: ::std::option::Option<i64>,
    pub logits_dimension: ::std::option::Option<i64>,
}

impl BoostedTreesExampleDebugOutputs {
    /// Creates a new `BoostedTreesExampleDebugOutputs`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_example_debug_outputs with default options.
pub fn boosted_trees_example_debug_outputs<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    bucketized_features: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BoostedTreesExampleDebugOutputs::new();
    boosted_trees_example_debug_outputs_with_args(
        ctx,
        tree_ensemble_handle,
        bucketized_features,
        &__args,
    )
}

/// boosted_trees_example_debug_outputs with options.
pub fn boosted_trees_example_debug_outputs_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    bucketized_features: T1,
    __args: &BoostedTreesExampleDebugOutputs,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesExampleDebugOutputs")?;

    // Required input arguments
    op.add_input(&tree_ensemble_handle.to_handle()?)?;
    op.add_input(&bucketized_features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_bucketized_features {
        op.set_attr_int("num_bucketized_features", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.logits_dimension {
        op.set_attr_int("logits_dimension", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesFlushQuantileSummaries
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesFlushQuantileSummaries {
    pub num_features: ::std::option::Option<i64>,
}

impl BoostedTreesFlushQuantileSummaries {
    /// Creates a new `BoostedTreesFlushQuantileSummaries`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_flush_quantile_summaries with default options.
pub fn boosted_trees_flush_quantile_summaries<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BoostedTreesFlushQuantileSummaries::new();
    boosted_trees_flush_quantile_summaries_with_args(ctx, quantile_stream_resource_handle, &__args)
}

/// boosted_trees_flush_quantile_summaries with options.
pub fn boosted_trees_flush_quantile_summaries_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
    __args: &BoostedTreesFlushQuantileSummaries,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesFlushQuantileSummaries")?;

    // Required input arguments
    op.add_input(&quantile_stream_resource_handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int("num_features", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesGetEnsembleStates
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesGetEnsembleStates {}

impl BoostedTreesGetEnsembleStates {
    /// Creates a new `BoostedTreesGetEnsembleStates`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_get_ensemble_states with default options.
pub fn boosted_trees_get_ensemble_states<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let __args = BoostedTreesGetEnsembleStates::new();
    boosted_trees_get_ensemble_states_with_args(ctx, tree_ensemble_handle, &__args)
}

/// boosted_trees_get_ensemble_states with options.
pub fn boosted_trees_get_ensemble_states_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    __args: &BoostedTreesGetEnsembleStates,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesGetEnsembleStates")?;

    // Required input arguments
    op.add_input(&tree_ensemble_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 5;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 5];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesMakeQuantileSummaries
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesMakeQuantileSummaries {
    pub num_features: ::std::option::Option<i64>,
}

impl BoostedTreesMakeQuantileSummaries {
    /// Creates a new `BoostedTreesMakeQuantileSummaries`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_make_quantile_summaries with default options.
pub fn boosted_trees_make_quantile_summaries<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    float_values: T0,
    example_weights: T1,
    epsilon: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = BoostedTreesMakeQuantileSummaries::new();
    boosted_trees_make_quantile_summaries_with_args(
        ctx,
        float_values,
        example_weights,
        epsilon,
        &__args,
    )
}

/// boosted_trees_make_quantile_summaries with options.
pub fn boosted_trees_make_quantile_summaries_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    float_values: T0,
    example_weights: T1,
    epsilon: T2,
    __args: &BoostedTreesMakeQuantileSummaries,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesMakeQuantileSummaries")?;

    // Required input arguments
    op.add_input(&float_values.to_handle()?)?;
    op.add_input(&example_weights.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int("num_features", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesMakeStatsSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesMakeStatsSummary {
    pub max_splits: ::std::option::Option<i64>,
    pub num_buckets: ::std::option::Option<i64>,
    pub num_features: ::std::option::Option<i64>,
}

impl BoostedTreesMakeStatsSummary {
    /// Creates a new `BoostedTreesMakeStatsSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_make_stats_summary with default options.
pub fn boosted_trees_make_stats_summary<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_ids: T0,
    gradients: T1,
    hessians: T2,
    bucketized_features_list: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = BoostedTreesMakeStatsSummary::new();
    boosted_trees_make_stats_summary_with_args(
        ctx,
        node_ids,
        gradients,
        hessians,
        bucketized_features_list,
        &__args,
    )
}

/// boosted_trees_make_stats_summary with options.
pub fn boosted_trees_make_stats_summary_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_ids: T0,
    gradients: T1,
    hessians: T2,
    bucketized_features_list: T3,
    __args: &BoostedTreesMakeStatsSummary,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesMakeStatsSummary")?;

    // Required input arguments
    op.add_input(&node_ids.to_handle()?)?;
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&hessians.to_handle()?)?;
    op.add_input(&bucketized_features_list.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.max_splits {
        op.set_attr_int("max_splits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_buckets {
        op.set_attr_int("num_buckets", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int("num_features", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesPredict
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesPredict {
    pub num_bucketized_features: ::std::option::Option<i64>,
    pub logits_dimension: ::std::option::Option<i64>,
}

impl BoostedTreesPredict {
    /// Creates a new `BoostedTreesPredict`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_predict with default options.
pub fn boosted_trees_predict<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    bucketized_features: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BoostedTreesPredict::new();
    boosted_trees_predict_with_args(ctx, tree_ensemble_handle, bucketized_features, &__args)
}

/// boosted_trees_predict with options.
pub fn boosted_trees_predict_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    bucketized_features: T1,
    __args: &BoostedTreesPredict,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesPredict")?;

    // Required input arguments
    op.add_input(&tree_ensemble_handle.to_handle()?)?;
    op.add_input(&bucketized_features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_bucketized_features {
        op.set_attr_int("num_bucketized_features", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.logits_dimension {
        op.set_attr_int("logits_dimension", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesQuantileStreamResourceAddSummaries
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesQuantileStreamResourceAddSummaries {
    pub num_features: ::std::option::Option<i64>,
}

impl BoostedTreesQuantileStreamResourceAddSummaries {
    /// Creates a new `BoostedTreesQuantileStreamResourceAddSummaries`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_quantile_stream_resource_add_summaries with default options.
pub fn boosted_trees_quantile_stream_resource_add_summaries<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
    summaries: T1,
) -> Result<()> {
    let __args = BoostedTreesQuantileStreamResourceAddSummaries::new();
    boosted_trees_quantile_stream_resource_add_summaries_with_args(
        ctx,
        quantile_stream_resource_handle,
        summaries,
        &__args,
    )
}

/// boosted_trees_quantile_stream_resource_add_summaries with options.
pub fn boosted_trees_quantile_stream_resource_add_summaries_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
    summaries: T1,
    __args: &BoostedTreesQuantileStreamResourceAddSummaries,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesQuantileStreamResourceAddSummaries")?;

    // Required input arguments
    op.add_input(&quantile_stream_resource_handle.to_handle()?)?;
    op.add_input(&summaries.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int("num_features", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// BoostedTreesQuantileStreamResourceDeserialize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesQuantileStreamResourceDeserialize {
    pub num_streams: ::std::option::Option<i64>,
}

impl BoostedTreesQuantileStreamResourceDeserialize {
    /// Creates a new `BoostedTreesQuantileStreamResourceDeserialize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_quantile_stream_resource_deserialize with default options.
pub fn boosted_trees_quantile_stream_resource_deserialize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
    bucket_boundaries: T1,
) -> Result<()> {
    let __args = BoostedTreesQuantileStreamResourceDeserialize::new();
    boosted_trees_quantile_stream_resource_deserialize_with_args(
        ctx,
        quantile_stream_resource_handle,
        bucket_boundaries,
        &__args,
    )
}

/// boosted_trees_quantile_stream_resource_deserialize with options.
pub fn boosted_trees_quantile_stream_resource_deserialize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
    bucket_boundaries: T1,
    __args: &BoostedTreesQuantileStreamResourceDeserialize,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesQuantileStreamResourceDeserialize")?;

    // Required input arguments
    op.add_input(&quantile_stream_resource_handle.to_handle()?)?;
    op.add_input(&bucket_boundaries.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_streams {
        op.set_attr_int("num_streams", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// BoostedTreesQuantileStreamResourceFlush
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesQuantileStreamResourceFlush {
    pub generate_quantiles: ::std::option::Option<bool>,
}

impl BoostedTreesQuantileStreamResourceFlush {
    /// Creates a new `BoostedTreesQuantileStreamResourceFlush`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_quantile_stream_resource_flush with default options.
pub fn boosted_trees_quantile_stream_resource_flush<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
    num_buckets: T1,
) -> Result<()> {
    let __args = BoostedTreesQuantileStreamResourceFlush::new();
    boosted_trees_quantile_stream_resource_flush_with_args(
        ctx,
        quantile_stream_resource_handle,
        num_buckets,
        &__args,
    )
}

/// boosted_trees_quantile_stream_resource_flush with options.
pub fn boosted_trees_quantile_stream_resource_flush_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
    num_buckets: T1,
    __args: &BoostedTreesQuantileStreamResourceFlush,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesQuantileStreamResourceFlush")?;

    // Required input arguments
    op.add_input(&quantile_stream_resource_handle.to_handle()?)?;
    op.add_input(&num_buckets.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.generate_quantiles {
        op.set_attr_bool("generate_quantiles", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// BoostedTreesQuantileStreamResourceGetBucketBoundaries
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesQuantileStreamResourceGetBucketBoundaries {
    pub num_features: ::std::option::Option<i64>,
}

impl BoostedTreesQuantileStreamResourceGetBucketBoundaries {
    /// Creates a new `BoostedTreesQuantileStreamResourceGetBucketBoundaries`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_quantile_stream_resource_get_bucket_boundaries with default options.
pub fn boosted_trees_quantile_stream_resource_get_bucket_boundaries<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = BoostedTreesQuantileStreamResourceGetBucketBoundaries::new();
    boosted_trees_quantile_stream_resource_get_bucket_boundaries_with_args(
        ctx,
        quantile_stream_resource_handle,
        &__args,
    )
}

/// boosted_trees_quantile_stream_resource_get_bucket_boundaries with options.
pub fn boosted_trees_quantile_stream_resource_get_bucket_boundaries_with_args<
    T0: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
    __args: &BoostedTreesQuantileStreamResourceGetBucketBoundaries,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op =
        crate::eager::Op::new(ctx, "BoostedTreesQuantileStreamResourceGetBucketBoundaries")?;

    // Required input arguments
    op.add_input(&quantile_stream_resource_handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int("num_features", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesQuantileStreamResourceHandleOp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesQuantileStreamResourceHandleOp {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl BoostedTreesQuantileStreamResourceHandleOp {
    /// Creates a new `BoostedTreesQuantileStreamResourceHandleOp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_quantile_stream_resource_handle_op with default options.
pub fn boosted_trees_quantile_stream_resource_handle_op(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = BoostedTreesQuantileStreamResourceHandleOp::new();
    boosted_trees_quantile_stream_resource_handle_op_with_args(ctx, &__args)
}

/// boosted_trees_quantile_stream_resource_handle_op with options.
pub fn boosted_trees_quantile_stream_resource_handle_op_with_args(
    ctx: &crate::eager::Context,
    __args: &BoostedTreesQuantileStreamResourceHandleOp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesQuantileStreamResourceHandleOp")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesSerializeEnsemble
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesSerializeEnsemble {}

impl BoostedTreesSerializeEnsemble {
    /// Creates a new `BoostedTreesSerializeEnsemble`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_serialize_ensemble with default options.
pub fn boosted_trees_serialize_ensemble<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = BoostedTreesSerializeEnsemble::new();
    boosted_trees_serialize_ensemble_with_args(ctx, tree_ensemble_handle, &__args)
}

/// boosted_trees_serialize_ensemble with options.
pub fn boosted_trees_serialize_ensemble_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    __args: &BoostedTreesSerializeEnsemble,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesSerializeEnsemble")?;

    // Required input arguments
    op.add_input(&tree_ensemble_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesSparseAggregateStats
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesSparseAggregateStats {
    pub max_splits: ::std::option::Option<i64>,
    pub num_buckets: ::std::option::Option<i64>,
}

impl BoostedTreesSparseAggregateStats {
    /// Creates a new `BoostedTreesSparseAggregateStats`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_sparse_aggregate_stats with default options.
pub fn boosted_trees_sparse_aggregate_stats<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_ids: T0,
    gradients: T1,
    hessians: T2,
    feature_indices: T3,
    feature_values: T4,
    feature_shape: T5,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = BoostedTreesSparseAggregateStats::new();
    boosted_trees_sparse_aggregate_stats_with_args(
        ctx,
        node_ids,
        gradients,
        hessians,
        feature_indices,
        feature_values,
        feature_shape,
        &__args,
    )
}

/// boosted_trees_sparse_aggregate_stats with options.
pub fn boosted_trees_sparse_aggregate_stats_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_ids: T0,
    gradients: T1,
    hessians: T2,
    feature_indices: T3,
    feature_values: T4,
    feature_shape: T5,
    __args: &BoostedTreesSparseAggregateStats,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesSparseAggregateStats")?;

    // Required input arguments
    op.add_input(&node_ids.to_handle()?)?;
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&hessians.to_handle()?)?;
    op.add_input(&feature_indices.to_handle()?)?;
    op.add_input(&feature_values.to_handle()?)?;
    op.add_input(&feature_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.max_splits {
        op.set_attr_int("max_splits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_buckets {
        op.set_attr_int("num_buckets", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesSparseCalculateBestFeatureSplit
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesSparseCalculateBestFeatureSplit {
    pub logits_dimension: ::std::option::Option<i64>,
    pub split_type: ::std::option::Option<::std::string::String>,
}

impl BoostedTreesSparseCalculateBestFeatureSplit {
    /// Creates a new `BoostedTreesSparseCalculateBestFeatureSplit`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_sparse_calculate_best_feature_split with default options.
pub fn boosted_trees_sparse_calculate_best_feature_split<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_id_range: T0,
    stats_summary_indices: T1,
    stats_summary_values: T2,
    stats_summary_shape: T3,
    l1: T4,
    l2: T5,
    tree_complexity: T6,
    min_node_weight: T7,
) -> Result<[crate::eager::TensorHandle; 7]> {
    let __args = BoostedTreesSparseCalculateBestFeatureSplit::new();
    boosted_trees_sparse_calculate_best_feature_split_with_args(
        ctx,
        node_id_range,
        stats_summary_indices,
        stats_summary_values,
        stats_summary_shape,
        l1,
        l2,
        tree_complexity,
        min_node_weight,
        &__args,
    )
}

/// boosted_trees_sparse_calculate_best_feature_split with options.
pub fn boosted_trees_sparse_calculate_best_feature_split_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    node_id_range: T0,
    stats_summary_indices: T1,
    stats_summary_values: T2,
    stats_summary_shape: T3,
    l1: T4,
    l2: T5,
    tree_complexity: T6,
    min_node_weight: T7,
    __args: &BoostedTreesSparseCalculateBestFeatureSplit,
) -> Result<[crate::eager::TensorHandle; 7]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesSparseCalculateBestFeatureSplit")?;

    // Required input arguments
    op.add_input(&node_id_range.to_handle()?)?;
    op.add_input(&stats_summary_indices.to_handle()?)?;
    op.add_input(&stats_summary_values.to_handle()?)?;
    op.add_input(&stats_summary_shape.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&tree_complexity.to_handle()?)?;
    op.add_input(&min_node_weight.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.logits_dimension {
        op.set_attr_int("logits_dimension", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.split_type {
        op.set_attr_string("split_type", value);
    }

    // Execute Op
    let mut num_output = 7;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 7];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
                crate::eager::TensorHandle::from_tensor_handle(res[6]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesTrainingPredict
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesTrainingPredict {
    pub num_bucketized_features: ::std::option::Option<i64>,
    pub logits_dimension: ::std::option::Option<i64>,
}

impl BoostedTreesTrainingPredict {
    /// Creates a new `BoostedTreesTrainingPredict`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_training_predict with default options.
pub fn boosted_trees_training_predict<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    cached_tree_ids: T1,
    cached_node_ids: T2,
    bucketized_features: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = BoostedTreesTrainingPredict::new();
    boosted_trees_training_predict_with_args(
        ctx,
        tree_ensemble_handle,
        cached_tree_ids,
        cached_node_ids,
        bucketized_features,
        &__args,
    )
}

/// boosted_trees_training_predict with options.
pub fn boosted_trees_training_predict_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    cached_tree_ids: T1,
    cached_node_ids: T2,
    bucketized_features: T3,
    __args: &BoostedTreesTrainingPredict,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesTrainingPredict")?;

    // Required input arguments
    op.add_input(&tree_ensemble_handle.to_handle()?)?;
    op.add_input(&cached_tree_ids.to_handle()?)?;
    op.add_input(&cached_node_ids.to_handle()?)?;
    op.add_input(&bucketized_features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_bucketized_features {
        op.set_attr_int("num_bucketized_features", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.logits_dimension {
        op.set_attr_int("logits_dimension", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BoostedTreesUpdateEnsemble
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesUpdateEnsemble {
    pub pruning_mode: ::std::option::Option<i64>,
    pub num_features: ::std::option::Option<i64>,
}

impl BoostedTreesUpdateEnsemble {
    /// Creates a new `BoostedTreesUpdateEnsemble`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_update_ensemble with default options.
pub fn boosted_trees_update_ensemble<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    feature_ids: T1,
    node_ids: T2,
    gains: T3,
    thresholds: T4,
    left_node_contribs: T5,
    right_node_contribs: T6,
    max_depth: T7,
    learning_rate: T8,
) -> Result<()> {
    let __args = BoostedTreesUpdateEnsemble::new();
    boosted_trees_update_ensemble_with_args(
        ctx,
        tree_ensemble_handle,
        feature_ids,
        node_ids,
        gains,
        thresholds,
        left_node_contribs,
        right_node_contribs,
        max_depth,
        learning_rate,
        &__args,
    )
}

/// boosted_trees_update_ensemble with options.
pub fn boosted_trees_update_ensemble_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    feature_ids: T1,
    node_ids: T2,
    gains: T3,
    thresholds: T4,
    left_node_contribs: T5,
    right_node_contribs: T6,
    max_depth: T7,
    learning_rate: T8,
    __args: &BoostedTreesUpdateEnsemble,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesUpdateEnsemble")?;

    // Required input arguments
    op.add_input(&tree_ensemble_handle.to_handle()?)?;
    op.add_input(&feature_ids.to_handle()?)?;
    op.add_input(&node_ids.to_handle()?)?;
    op.add_input(&gains.to_handle()?)?;
    op.add_input(&thresholds.to_handle()?)?;
    op.add_input(&left_node_contribs.to_handle()?)?;
    op.add_input(&right_node_contribs.to_handle()?)?;
    op.add_input(&max_depth.to_handle()?)?;
    op.add_input(&learning_rate.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.pruning_mode {
        op.set_attr_int("pruning_mode", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int("num_features", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// BoostedTreesUpdateEnsembleV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesUpdateEnsembleV2 {
    pub num_features: ::std::option::Option<i64>,
    pub logits_dimension: ::std::option::Option<i64>,
    pub num_groups: ::std::option::Option<i64>,
}

impl BoostedTreesUpdateEnsembleV2 {
    /// Creates a new `BoostedTreesUpdateEnsembleV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// boosted_trees_update_ensemble_v2 with default options.
pub fn boosted_trees_update_ensemble_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    feature_ids: T1,
    dimension_ids: T2,
    node_ids: T3,
    gains: T4,
    thresholds: T5,
    left_node_contribs: T6,
    right_node_contribs: T7,
    split_types: T8,
    max_depth: T9,
    learning_rate: T10,
    pruning_mode: T11,
) -> Result<()> {
    let __args = BoostedTreesUpdateEnsembleV2::new();
    boosted_trees_update_ensemble_v2_with_args(
        ctx,
        tree_ensemble_handle,
        feature_ids,
        dimension_ids,
        node_ids,
        gains,
        thresholds,
        left_node_contribs,
        right_node_contribs,
        split_types,
        max_depth,
        learning_rate,
        pruning_mode,
        &__args,
    )
}

/// boosted_trees_update_ensemble_v2 with options.
pub fn boosted_trees_update_ensemble_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    feature_ids: T1,
    dimension_ids: T2,
    node_ids: T3,
    gains: T4,
    thresholds: T5,
    left_node_contribs: T6,
    right_node_contribs: T7,
    split_types: T8,
    max_depth: T9,
    learning_rate: T10,
    pruning_mode: T11,
    __args: &BoostedTreesUpdateEnsembleV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BoostedTreesUpdateEnsembleV2")?;

    // Required input arguments
    op.add_input(&tree_ensemble_handle.to_handle()?)?;
    op.add_input(&feature_ids.to_handle()?)?;
    op.add_input(&dimension_ids.to_handle()?)?;
    op.add_input(&node_ids.to_handle()?)?;
    op.add_input(&gains.to_handle()?)?;
    op.add_input(&thresholds.to_handle()?)?;
    op.add_input(&left_node_contribs.to_handle()?)?;
    op.add_input(&right_node_contribs.to_handle()?)?;
    op.add_input(&split_types.to_handle()?)?;
    op.add_input(&max_depth.to_handle()?)?;
    op.add_input(&learning_rate.to_handle()?)?;
    op.add_input(&pruning_mode.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int("num_features", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.logits_dimension {
        op.set_attr_int("logits_dimension", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_groups {
        op.set_attr_int("num_groups", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// BroadcastArgs
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BroadcastArgs {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BroadcastArgs {
    /// Creates a new `BroadcastArgs`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// broadcast_args with default options.
pub fn broadcast_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    s0: T0,
    s1: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BroadcastArgs::new();
    broadcast_args_with_args(ctx, s0, s1, &__args)
}

/// broadcast_args with options.
pub fn broadcast_args_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    s0: T0,
    s1: T1,
    __args: &BroadcastArgs,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BroadcastArgs")?;

    // Required input arguments
    op.add_input(&s0.to_handle()?)?;
    op.add_input(&s1.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BroadcastGradientArgs
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BroadcastGradientArgs {
    pub T: ::std::option::Option<crate::DataType>,
}

impl BroadcastGradientArgs {
    /// Creates a new `BroadcastGradientArgs`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// broadcast_gradient_args with default options.
pub fn broadcast_gradient_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    s0: T0,
    s1: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = BroadcastGradientArgs::new();
    broadcast_gradient_args_with_args(ctx, s0, s1, &__args)
}

/// broadcast_gradient_args with options.
pub fn broadcast_gradient_args_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    s0: T0,
    s1: T1,
    __args: &BroadcastGradientArgs,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BroadcastGradientArgs")?;

    // Required input arguments
    op.add_input(&s0.to_handle()?)?;
    op.add_input(&s1.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// BroadcastTo
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BroadcastTo {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl BroadcastTo {
    /// Creates a new `BroadcastTo`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// broadcast_to with default options.
pub fn broadcast_to<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    shape: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BroadcastTo::new();
    broadcast_to_with_args(ctx, input, shape, &__args)
}

/// broadcast_to with options.
pub fn broadcast_to_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    shape: T1,
    __args: &BroadcastTo,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BroadcastTo")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Bucketize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Bucketize {
    pub T: ::std::option::Option<crate::DataType>,
    pub boundaries: ::std::option::Option<::std::vec::Vec<f32>>,
}

impl Bucketize {
    /// Creates a new `Bucketize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bucketize with default options.
pub fn bucketize<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Bucketize::new();
    bucketize_with_args(ctx, input, &__args)
}

/// bucketize with options.
pub fn bucketize_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Bucketize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Bucketize")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.boundaries {
        op.set_attr_float_list("boundaries", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// BytesProducedStatsDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BytesProducedStatsDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl BytesProducedStatsDataset {
    /// Creates a new `BytesProducedStatsDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// bytes_produced_stats_dataset with default options.
pub fn bytes_produced_stats_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    tag: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = BytesProducedStatsDataset::new();
    bytes_produced_stats_dataset_with_args(ctx, input_dataset, tag, &__args)
}

/// bytes_produced_stats_dataset with options.
pub fn bytes_produced_stats_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    tag: T1,
    __args: &BytesProducedStatsDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "BytesProducedStatsDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&tag.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CSRSparseMatrixComponents
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CSRSparseMatrixComponents {
    pub type_: ::std::option::Option<crate::DataType>,
}

impl CSRSparseMatrixComponents {
    /// Creates a new `CSRSparseMatrixComponents`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// csrsparse_matrix_components with default options.
pub fn csrsparse_matrix_components<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    csr_sparse_matrix: T0,
    index: T1,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = CSRSparseMatrixComponents::new();
    csrsparse_matrix_components_with_args(ctx, csr_sparse_matrix, index, &__args)
}

/// csrsparse_matrix_components with options.
pub fn csrsparse_matrix_components_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    csr_sparse_matrix: T0,
    index: T1,
    __args: &CSRSparseMatrixComponents,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CSRSparseMatrixComponents")?;

    // Required input arguments
    op.add_input(&csr_sparse_matrix.to_handle()?)?;
    op.add_input(&index.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.type_ {
        op.set_attr_type("type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CSRSparseMatrixToDense
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CSRSparseMatrixToDense {
    pub type_: ::std::option::Option<crate::DataType>,
}

impl CSRSparseMatrixToDense {
    /// Creates a new `CSRSparseMatrixToDense`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// csrsparse_matrix_to_dense with default options.
pub fn csrsparse_matrix_to_dense<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sparse_input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = CSRSparseMatrixToDense::new();
    csrsparse_matrix_to_dense_with_args(ctx, sparse_input, &__args)
}

/// csrsparse_matrix_to_dense with options.
pub fn csrsparse_matrix_to_dense_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sparse_input: T0,
    __args: &CSRSparseMatrixToDense,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CSRSparseMatrixToDense")?;

    // Required input arguments
    op.add_input(&sparse_input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.type_ {
        op.set_attr_type("type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CSRSparseMatrixToSparseTensor
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CSRSparseMatrixToSparseTensor {
    pub type_: ::std::option::Option<crate::DataType>,
}

impl CSRSparseMatrixToSparseTensor {
    /// Creates a new `CSRSparseMatrixToSparseTensor`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// csrsparse_matrix_to_sparse_tensor with default options.
pub fn csrsparse_matrix_to_sparse_tensor<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sparse_matrix: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = CSRSparseMatrixToSparseTensor::new();
    csrsparse_matrix_to_sparse_tensor_with_args(ctx, sparse_matrix, &__args)
}

/// csrsparse_matrix_to_sparse_tensor with options.
pub fn csrsparse_matrix_to_sparse_tensor_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sparse_matrix: T0,
    __args: &CSRSparseMatrixToSparseTensor,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CSRSparseMatrixToSparseTensor")?;

    // Required input arguments
    op.add_input(&sparse_matrix.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.type_ {
        op.set_attr_type("type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CSVDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CSVDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl CSVDataset {
    /// Creates a new `CSVDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// csvdataset with default options.
pub fn csvdataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    compression_type: T1,
    buffer_size: T2,
    header: T3,
    field_delim: T4,
    use_quote_delim: T5,
    na_value: T6,
    select_cols: T7,
    record_defaults: T8,
) -> Result<crate::eager::TensorHandle> {
    let __args = CSVDataset::new();
    csvdataset_with_args(
        ctx,
        filenames,
        compression_type,
        buffer_size,
        header,
        field_delim,
        use_quote_delim,
        na_value,
        select_cols,
        record_defaults,
        &__args,
    )
}

/// csvdataset with options.
pub fn csvdataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    compression_type: T1,
    buffer_size: T2,
    header: T3,
    field_delim: T4,
    use_quote_delim: T5,
    na_value: T6,
    select_cols: T7,
    record_defaults: T8,
    __args: &CSVDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CSVDataset")?;

    // Required input arguments
    op.add_input(&filenames.to_handle()?)?;
    op.add_input(&compression_type.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;
    op.add_input(&header.to_handle()?)?;
    op.add_input(&field_delim.to_handle()?)?;
    op.add_input(&use_quote_delim.to_handle()?)?;
    op.add_input(&na_value.to_handle()?)?;
    op.add_input(&select_cols.to_handle()?)?;
    op.add_input(&record_defaults.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CSVDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CSVDatasetV2 {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl CSVDatasetV2 {
    /// Creates a new `CSVDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// csvdataset_v2 with default options.
pub fn csvdataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    compression_type: T1,
    buffer_size: T2,
    header: T3,
    field_delim: T4,
    use_quote_delim: T5,
    na_value: T6,
    select_cols: T7,
    record_defaults: T8,
    exclude_cols: T9,
) -> Result<crate::eager::TensorHandle> {
    let __args = CSVDatasetV2::new();
    csvdataset_v2_with_args(
        ctx,
        filenames,
        compression_type,
        buffer_size,
        header,
        field_delim,
        use_quote_delim,
        na_value,
        select_cols,
        record_defaults,
        exclude_cols,
        &__args,
    )
}

/// csvdataset_v2 with options.
pub fn csvdataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    compression_type: T1,
    buffer_size: T2,
    header: T3,
    field_delim: T4,
    use_quote_delim: T5,
    na_value: T6,
    select_cols: T7,
    record_defaults: T8,
    exclude_cols: T9,
    __args: &CSVDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CSVDatasetV2")?;

    // Required input arguments
    op.add_input(&filenames.to_handle()?)?;
    op.add_input(&compression_type.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;
    op.add_input(&header.to_handle()?)?;
    op.add_input(&field_delim.to_handle()?)?;
    op.add_input(&use_quote_delim.to_handle()?)?;
    op.add_input(&na_value.to_handle()?)?;
    op.add_input(&select_cols.to_handle()?)?;
    op.add_input(&record_defaults.to_handle()?)?;
    op.add_input(&exclude_cols.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CTCBeamSearchDecoder
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CTCBeamSearchDecoder {
    pub beam_width: ::std::option::Option<i64>,
    pub top_paths: ::std::option::Option<i64>,
    pub merge_repeated: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl CTCBeamSearchDecoder {
    /// Creates a new `CTCBeamSearchDecoder`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ctcbeam_search_decoder with default options.
pub fn ctcbeam_search_decoder<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    sequence_length: T1,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = CTCBeamSearchDecoder::new();
    ctcbeam_search_decoder_with_args(ctx, inputs, sequence_length, &__args)
}

/// ctcbeam_search_decoder with options.
pub fn ctcbeam_search_decoder_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    sequence_length: T1,
    __args: &CTCBeamSearchDecoder,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CTCBeamSearchDecoder")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;
    op.add_input(&sequence_length.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.beam_width {
        op.set_attr_int("beam_width", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.top_paths {
        op.set_attr_int("top_paths", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.merge_repeated {
        op.set_attr_bool("merge_repeated", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CTCGreedyDecoder
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CTCGreedyDecoder {
    pub merge_repeated: ::std::option::Option<bool>,
    pub blank_index: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl CTCGreedyDecoder {
    /// Creates a new `CTCGreedyDecoder`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ctcgreedy_decoder with default options.
pub fn ctcgreedy_decoder<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    sequence_length: T1,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = CTCGreedyDecoder::new();
    ctcgreedy_decoder_with_args(ctx, inputs, sequence_length, &__args)
}

/// ctcgreedy_decoder with options.
pub fn ctcgreedy_decoder_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    sequence_length: T1,
    __args: &CTCGreedyDecoder,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CTCGreedyDecoder")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;
    op.add_input(&sequence_length.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.merge_repeated {
        op.set_attr_bool("merge_repeated", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.blank_index {
        op.set_attr_int("blank_index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CTCLoss
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CTCLoss {
    pub preprocess_collapse_repeated: ::std::option::Option<bool>,
    pub ctc_merge_repeated: ::std::option::Option<bool>,
    pub ignore_longer_outputs_than_inputs: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl CTCLoss {
    /// Creates a new `CTCLoss`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ctcloss with default options.
pub fn ctcloss<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    inputs: T0,
    labels_indices: T1,
    labels_values: T2,
    sequence_length: T3,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = CTCLoss::new();
    ctcloss_with_args(
        ctx,
        inputs,
        labels_indices,
        labels_values,
        sequence_length,
        &__args,
    )
}

/// ctcloss with options.
pub fn ctcloss_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    inputs: T0,
    labels_indices: T1,
    labels_values: T2,
    sequence_length: T3,
    __args: &CTCLoss,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CTCLoss")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;
    op.add_input(&labels_indices.to_handle()?)?;
    op.add_input(&labels_values.to_handle()?)?;
    op.add_input(&sequence_length.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.preprocess_collapse_repeated {
        op.set_attr_bool("preprocess_collapse_repeated", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ctc_merge_repeated {
        op.set_attr_bool("ctc_merge_repeated", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ignore_longer_outputs_than_inputs {
        op.set_attr_bool("ignore_longer_outputs_than_inputs", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CTCLossV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CTCLossV2 {
    pub preprocess_collapse_repeated: ::std::option::Option<bool>,
    pub ctc_merge_repeated: ::std::option::Option<bool>,
    pub ignore_longer_outputs_than_inputs: ::std::option::Option<bool>,
}

impl CTCLossV2 {
    /// Creates a new `CTCLossV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ctcloss_v2 with default options.
pub fn ctcloss_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    inputs: T0,
    labels_indices: T1,
    labels_values: T2,
    sequence_length: T3,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = CTCLossV2::new();
    ctcloss_v2_with_args(
        ctx,
        inputs,
        labels_indices,
        labels_values,
        sequence_length,
        &__args,
    )
}

/// ctcloss_v2 with options.
pub fn ctcloss_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    inputs: T0,
    labels_indices: T1,
    labels_values: T2,
    sequence_length: T3,
    __args: &CTCLossV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CTCLossV2")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;
    op.add_input(&labels_indices.to_handle()?)?;
    op.add_input(&labels_values.to_handle()?)?;
    op.add_input(&sequence_length.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.preprocess_collapse_repeated {
        op.set_attr_bool("preprocess_collapse_repeated", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ctc_merge_repeated {
        op.set_attr_bool("ctc_merge_repeated", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ignore_longer_outputs_than_inputs {
        op.set_attr_bool("ignore_longer_outputs_than_inputs", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CacheDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CacheDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl CacheDataset {
    /// Creates a new `CacheDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cache_dataset with default options.
pub fn cache_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    filename: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = CacheDataset::new();
    cache_dataset_with_args(ctx, input_dataset, filename, &__args)
}

/// cache_dataset with options.
pub fn cache_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    filename: T1,
    __args: &CacheDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CacheDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&filename.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CacheDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CacheDatasetV2 {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl CacheDatasetV2 {
    /// Creates a new `CacheDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cache_dataset_v2 with default options.
pub fn cache_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    filename: T1,
    cache: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = CacheDatasetV2::new();
    cache_dataset_v2_with_args(ctx, input_dataset, filename, cache, &__args)
}

/// cache_dataset_v2 with options.
pub fn cache_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    filename: T1,
    cache: T2,
    __args: &CacheDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CacheDatasetV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&filename.to_handle()?)?;
    op.add_input(&cache.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Case
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Case {
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub branches: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl Case {
    /// Creates a new `Case`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// case with default options.
pub fn case<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    branch_index: T0,
    input: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Case::new();
    case_with_args(ctx, branch_index, input, &__args)
}

/// case with options.
pub fn case_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    branch_index: T0,
    input: T1,
    __args: &Case,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Case")?;

    // Required input arguments
    op.add_input(&branch_index.to_handle()?)?;
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }
    if let ::std::option::Option::Some(value) = &__args.branches {
        op.set_attr_string_list("branches", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Cast
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cast {
    pub SrcT: ::std::option::Option<crate::DataType>,
    pub DstT: ::std::option::Option<crate::DataType>,
    pub Truncate: ::std::option::Option<bool>,
}

impl Cast {
    /// Creates a new `Cast`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cast with default options.
pub fn cast<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Cast::new();
    cast_with_args(ctx, x, &__args)
}

/// cast with options.
pub fn cast_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Cast,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Cast")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.SrcT {
        op.set_attr_type("SrcT", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.DstT {
        op.set_attr_type("DstT", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Truncate {
        op.set_attr_bool("Truncate", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Ceil
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Ceil {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Ceil {
    /// Creates a new `Ceil`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ceil with default options.
pub fn ceil<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Ceil::new();
    ceil_with_args(ctx, x, &__args)
}

/// ceil with options.
pub fn ceil_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Ceil,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Ceil")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CheckNumerics
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CheckNumerics {
    pub T: ::std::option::Option<crate::DataType>,
    pub message: ::std::option::Option<::std::string::String>,
}

impl CheckNumerics {
    /// Creates a new `CheckNumerics`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// check_numerics with default options.
pub fn check_numerics<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = CheckNumerics::new();
    check_numerics_with_args(ctx, tensor, &__args)
}

/// check_numerics with options.
pub fn check_numerics_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    __args: &CheckNumerics,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CheckNumerics")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.message {
        op.set_attr_string("message", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CheckNumericsV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CheckNumericsV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub message: ::std::option::Option<::std::string::String>,
}

impl CheckNumericsV2 {
    /// Creates a new `CheckNumericsV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// check_numerics_v2 with default options.
pub fn check_numerics_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = CheckNumericsV2::new();
    check_numerics_v2_with_args(ctx, tensor, &__args)
}

/// check_numerics_v2 with options.
pub fn check_numerics_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    __args: &CheckNumericsV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CheckNumericsV2")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.message {
        op.set_attr_string("message", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Cholesky
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cholesky {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Cholesky {
    /// Creates a new `Cholesky`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cholesky with default options.
pub fn cholesky<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Cholesky::new();
    cholesky_with_args(ctx, input, &__args)
}

/// cholesky with options.
pub fn cholesky_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Cholesky,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Cholesky")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CholeskyGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CholeskyGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl CholeskyGrad {
    /// Creates a new `CholeskyGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cholesky_grad with default options.
pub fn cholesky_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    l: T0,
    grad: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = CholeskyGrad::new();
    cholesky_grad_with_args(ctx, l, grad, &__args)
}

/// cholesky_grad with options.
pub fn cholesky_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    l: T0,
    grad: T1,
    __args: &CholeskyGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CholeskyGrad")?;

    // Required input arguments
    op.add_input(&l.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ChooseFastestBranchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ChooseFastestBranchDataset {
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub num_elements_per_branch: ::std::option::Option<i64>,
    pub branches: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub other_arguments_lengths: ::std::option::Option<::std::vec::Vec<i64>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ChooseFastestBranchDataset {
    /// Creates a new `ChooseFastestBranchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// choose_fastest_branch_dataset with default options.
pub fn choose_fastest_branch_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    ratio_numerator: T1,
    ratio_denominator: T2,
    other_arguments: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = ChooseFastestBranchDataset::new();
    choose_fastest_branch_dataset_with_args(
        ctx,
        input_dataset,
        ratio_numerator,
        ratio_denominator,
        other_arguments,
        &__args,
    )
}

/// choose_fastest_branch_dataset with options.
pub fn choose_fastest_branch_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    ratio_numerator: T1,
    ratio_denominator: T2,
    other_arguments: T3,
    __args: &ChooseFastestBranchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ChooseFastestBranchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&ratio_numerator.to_handle()?)?;
    op.add_input(&ratio_denominator.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_elements_per_branch {
        op.set_attr_int("num_elements_per_branch", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.branches {
        op.set_attr_string_list("branches", value);
    }
    if let ::std::option::Option::Some(value) = &__args.other_arguments_lengths {
        op.set_attr_int_list("other_arguments_lengths", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ChooseFastestDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ChooseFastestDataset {
    pub N: ::std::option::Option<i64>,
    pub num_experiments: ::std::option::Option<i64>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ChooseFastestDataset {
    /// Creates a new `ChooseFastestDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// choose_fastest_dataset with default options.
pub fn choose_fastest_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_datasets: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ChooseFastestDataset::new();
    choose_fastest_dataset_with_args(ctx, input_datasets, &__args)
}

/// choose_fastest_dataset with options.
pub fn choose_fastest_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_datasets: T0,
    __args: &ChooseFastestDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ChooseFastestDataset")?;

    // Required input arguments
    op.add_input(&input_datasets.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_experiments {
        op.set_attr_int("num_experiments", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ClipByValue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ClipByValue {
    pub T: ::std::option::Option<crate::DataType>,
}

impl ClipByValue {
    /// Creates a new `ClipByValue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// clip_by_value with default options.
pub fn clip_by_value<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    t: T0,
    clip_value_min: T1,
    clip_value_max: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ClipByValue::new();
    clip_by_value_with_args(ctx, t, clip_value_min, clip_value_max, &__args)
}

/// clip_by_value with options.
pub fn clip_by_value_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    t: T0,
    clip_value_min: T1,
    clip_value_max: T2,
    __args: &ClipByValue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ClipByValue")?;

    // Required input arguments
    op.add_input(&t.to_handle()?)?;
    op.add_input(&clip_value_min.to_handle()?)?;
    op.add_input(&clip_value_max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CloseSummaryWriter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CloseSummaryWriter {}

impl CloseSummaryWriter {
    /// Creates a new `CloseSummaryWriter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// close_summary_writer with default options.
pub fn close_summary_writer<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    writer: T0,
) -> Result<()> {
    let __args = CloseSummaryWriter::new();
    close_summary_writer_with_args(ctx, writer, &__args)
}

/// close_summary_writer with options.
pub fn close_summary_writer_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    writer: T0,
    __args: &CloseSummaryWriter,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CloseSummaryWriter")?;

    // Required input arguments
    op.add_input(&writer.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// CollectiveBcastRecv
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectiveBcastRecv {
    pub T: ::std::option::Option<crate::DataType>,
    pub group_size: ::std::option::Option<i64>,
    pub group_key: ::std::option::Option<i64>,
    pub instance_key: ::std::option::Option<i64>,
    pub shape: ::std::option::Option<crate::Shape>,
    pub communication_hint: ::std::option::Option<::std::string::String>,
    pub timeout_seconds: ::std::option::Option<f32>,
}

impl CollectiveBcastRecv {
    /// Creates a new `CollectiveBcastRecv`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// collective_bcast_recv with default options.
pub fn collective_bcast_recv(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = CollectiveBcastRecv::new();
    collective_bcast_recv_with_args(ctx, &__args)
}

/// collective_bcast_recv with options.
pub fn collective_bcast_recv_with_args(
    ctx: &crate::eager::Context,
    __args: &CollectiveBcastRecv,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CollectiveBcastRecv")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.group_size {
        op.set_attr_int("group_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.group_key {
        op.set_attr_int("group_key", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.instance_key {
        op.set_attr_int("instance_key", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.communication_hint {
        op.set_attr_string("communication_hint", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_seconds {
        op.set_attr_float("timeout_seconds", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CollectiveBcastRecvV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectiveBcastRecvV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tshape: ::std::option::Option<crate::DataType>,
    pub communication_hint: ::std::option::Option<::std::string::String>,
    pub timeout_seconds: ::std::option::Option<f32>,
}

impl CollectiveBcastRecvV2 {
    /// Creates a new `CollectiveBcastRecvV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// collective_bcast_recv_v2 with default options.
pub fn collective_bcast_recv_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    group_size: T0,
    group_key: T1,
    instance_key: T2,
    shape: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = CollectiveBcastRecvV2::new();
    collective_bcast_recv_v2_with_args(ctx, group_size, group_key, instance_key, shape, &__args)
}

/// collective_bcast_recv_v2 with options.
pub fn collective_bcast_recv_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    group_size: T0,
    group_key: T1,
    instance_key: T2,
    shape: T3,
    __args: &CollectiveBcastRecvV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CollectiveBcastRecvV2")?;

    // Required input arguments
    op.add_input(&group_size.to_handle()?)?;
    op.add_input(&group_key.to_handle()?)?;
    op.add_input(&instance_key.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshape {
        op.set_attr_type("Tshape", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.communication_hint {
        op.set_attr_string("communication_hint", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_seconds {
        op.set_attr_float("timeout_seconds", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CollectiveBcastSend
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectiveBcastSend {
    pub T: ::std::option::Option<crate::DataType>,
    pub group_size: ::std::option::Option<i64>,
    pub group_key: ::std::option::Option<i64>,
    pub instance_key: ::std::option::Option<i64>,
    pub shape: ::std::option::Option<crate::Shape>,
    pub communication_hint: ::std::option::Option<::std::string::String>,
    pub timeout_seconds: ::std::option::Option<f32>,
}

impl CollectiveBcastSend {
    /// Creates a new `CollectiveBcastSend`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// collective_bcast_send with default options.
pub fn collective_bcast_send<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = CollectiveBcastSend::new();
    collective_bcast_send_with_args(ctx, input, &__args)
}

/// collective_bcast_send with options.
pub fn collective_bcast_send_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &CollectiveBcastSend,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CollectiveBcastSend")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.group_size {
        op.set_attr_int("group_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.group_key {
        op.set_attr_int("group_key", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.instance_key {
        op.set_attr_int("instance_key", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.communication_hint {
        op.set_attr_string("communication_hint", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_seconds {
        op.set_attr_float("timeout_seconds", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CollectiveBcastSendV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectiveBcastSendV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub communication_hint: ::std::option::Option<::std::string::String>,
    pub timeout_seconds: ::std::option::Option<f32>,
}

impl CollectiveBcastSendV2 {
    /// Creates a new `CollectiveBcastSendV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// collective_bcast_send_v2 with default options.
pub fn collective_bcast_send_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    group_size: T1,
    group_key: T2,
    instance_key: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = CollectiveBcastSendV2::new();
    collective_bcast_send_v2_with_args(ctx, input, group_size, group_key, instance_key, &__args)
}

/// collective_bcast_send_v2 with options.
pub fn collective_bcast_send_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    group_size: T1,
    group_key: T2,
    instance_key: T3,
    __args: &CollectiveBcastSendV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CollectiveBcastSendV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&group_size.to_handle()?)?;
    op.add_input(&group_key.to_handle()?)?;
    op.add_input(&instance_key.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.communication_hint {
        op.set_attr_string("communication_hint", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_seconds {
        op.set_attr_float("timeout_seconds", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CollectiveGather
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectiveGather {
    pub T: ::std::option::Option<crate::DataType>,
    pub group_size: ::std::option::Option<i64>,
    pub group_key: ::std::option::Option<i64>,
    pub instance_key: ::std::option::Option<i64>,
    pub shape: ::std::option::Option<crate::Shape>,
    pub communication_hint: ::std::option::Option<::std::string::String>,
    pub timeout_seconds: ::std::option::Option<f32>,
}

impl CollectiveGather {
    /// Creates a new `CollectiveGather`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// collective_gather with default options.
pub fn collective_gather<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = CollectiveGather::new();
    collective_gather_with_args(ctx, input, &__args)
}

/// collective_gather with options.
pub fn collective_gather_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &CollectiveGather,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CollectiveGather")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.group_size {
        op.set_attr_int("group_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.group_key {
        op.set_attr_int("group_key", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.instance_key {
        op.set_attr_int("instance_key", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.communication_hint {
        op.set_attr_string("communication_hint", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_seconds {
        op.set_attr_float("timeout_seconds", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CollectiveGatherV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectiveGatherV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub communication_hint: ::std::option::Option<::std::string::String>,
    pub timeout_seconds: ::std::option::Option<f32>,
    pub Nordering_token: ::std::option::Option<i64>,
}

impl CollectiveGatherV2 {
    /// Creates a new `CollectiveGatherV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// collective_gather_v2 with default options.
pub fn collective_gather_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    group_size: T1,
    group_key: T2,
    instance_key: T3,
    ordering_token: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = CollectiveGatherV2::new();
    collective_gather_v2_with_args(
        ctx,
        input,
        group_size,
        group_key,
        instance_key,
        ordering_token,
        &__args,
    )
}

/// collective_gather_v2 with options.
pub fn collective_gather_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    group_size: T1,
    group_key: T2,
    instance_key: T3,
    ordering_token: T4,
    __args: &CollectiveGatherV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CollectiveGatherV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&group_size.to_handle()?)?;
    op.add_input(&group_key.to_handle()?)?;
    op.add_input(&instance_key.to_handle()?)?;
    op.add_input(&ordering_token.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.communication_hint {
        op.set_attr_string("communication_hint", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_seconds {
        op.set_attr_float("timeout_seconds", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Nordering_token {
        op.set_attr_int("Nordering_token", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CollectivePermute
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectivePermute {
    pub T: ::std::option::Option<crate::DataType>,
}

impl CollectivePermute {
    /// Creates a new `CollectivePermute`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// collective_permute with default options.
pub fn collective_permute<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    source_target_pairs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = CollectivePermute::new();
    collective_permute_with_args(ctx, input, source_target_pairs, &__args)
}

/// collective_permute with options.
pub fn collective_permute_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    source_target_pairs: T1,
    __args: &CollectivePermute,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CollectivePermute")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&source_target_pairs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CollectiveReduce
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectiveReduce {
    pub T: ::std::option::Option<crate::DataType>,
    pub group_size: ::std::option::Option<i64>,
    pub group_key: ::std::option::Option<i64>,
    pub instance_key: ::std::option::Option<i64>,
    pub merge_op: ::std::option::Option<::std::string::String>,
    pub final_op: ::std::option::Option<::std::string::String>,
    pub subdiv_offsets: ::std::option::Option<::std::vec::Vec<i64>>,
    pub wait_for: ::std::option::Option<::std::vec::Vec<i64>>,
    pub communication_hint: ::std::option::Option<::std::string::String>,
    pub timeout_seconds: ::std::option::Option<f32>,
}

impl CollectiveReduce {
    /// Creates a new `CollectiveReduce`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// collective_reduce with default options.
pub fn collective_reduce<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = CollectiveReduce::new();
    collective_reduce_with_args(ctx, input, &__args)
}

/// collective_reduce with options.
pub fn collective_reduce_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &CollectiveReduce,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CollectiveReduce")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.group_size {
        op.set_attr_int("group_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.group_key {
        op.set_attr_int("group_key", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.instance_key {
        op.set_attr_int("instance_key", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.merge_op {
        op.set_attr_string("merge_op", value);
    }
    if let ::std::option::Option::Some(value) = &__args.final_op {
        op.set_attr_string("final_op", value);
    }
    if let ::std::option::Option::Some(value) = &__args.subdiv_offsets {
        op.set_attr_int_list("subdiv_offsets", value);
    }
    if let ::std::option::Option::Some(value) = &__args.wait_for {
        op.set_attr_int_list("wait_for", value);
    }
    if let ::std::option::Option::Some(value) = &__args.communication_hint {
        op.set_attr_string("communication_hint", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_seconds {
        op.set_attr_float("timeout_seconds", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CollectiveReduceV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectiveReduceV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub merge_op: ::std::option::Option<::std::string::String>,
    pub final_op: ::std::option::Option<::std::string::String>,
    pub communication_hint: ::std::option::Option<::std::string::String>,
    pub timeout_seconds: ::std::option::Option<f32>,
    pub Nordering_token: ::std::option::Option<i64>,
    pub max_subdivs_per_device: ::std::option::Option<i64>,
}

impl CollectiveReduceV2 {
    /// Creates a new `CollectiveReduceV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// collective_reduce_v2 with default options.
pub fn collective_reduce_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    group_size: T1,
    group_key: T2,
    instance_key: T3,
    ordering_token: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = CollectiveReduceV2::new();
    collective_reduce_v2_with_args(
        ctx,
        input,
        group_size,
        group_key,
        instance_key,
        ordering_token,
        &__args,
    )
}

/// collective_reduce_v2 with options.
pub fn collective_reduce_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    group_size: T1,
    group_key: T2,
    instance_key: T3,
    ordering_token: T4,
    __args: &CollectiveReduceV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CollectiveReduceV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&group_size.to_handle()?)?;
    op.add_input(&group_key.to_handle()?)?;
    op.add_input(&instance_key.to_handle()?)?;
    op.add_input(&ordering_token.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.merge_op {
        op.set_attr_string("merge_op", value);
    }
    if let ::std::option::Option::Some(value) = &__args.final_op {
        op.set_attr_string("final_op", value);
    }
    if let ::std::option::Option::Some(value) = &__args.communication_hint {
        op.set_attr_string("communication_hint", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_seconds {
        op.set_attr_float("timeout_seconds", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Nordering_token {
        op.set_attr_int("Nordering_token", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_subdivs_per_device {
        op.set_attr_int("max_subdivs_per_device", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CombinedNonMaxSuppression
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CombinedNonMaxSuppression {
    pub pad_per_class: ::std::option::Option<bool>,
    pub clip_boxes: ::std::option::Option<bool>,
}

impl CombinedNonMaxSuppression {
    /// Creates a new `CombinedNonMaxSuppression`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// combined_non_max_suppression with default options.
pub fn combined_non_max_suppression<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    boxes: T0,
    scores: T1,
    max_output_size_per_class: T2,
    max_total_size: T3,
    iou_threshold: T4,
    score_threshold: T5,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = CombinedNonMaxSuppression::new();
    combined_non_max_suppression_with_args(
        ctx,
        boxes,
        scores,
        max_output_size_per_class,
        max_total_size,
        iou_threshold,
        score_threshold,
        &__args,
    )
}

/// combined_non_max_suppression with options.
pub fn combined_non_max_suppression_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    boxes: T0,
    scores: T1,
    max_output_size_per_class: T2,
    max_total_size: T3,
    iou_threshold: T4,
    score_threshold: T5,
    __args: &CombinedNonMaxSuppression,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CombinedNonMaxSuppression")?;

    // Required input arguments
    op.add_input(&boxes.to_handle()?)?;
    op.add_input(&scores.to_handle()?)?;
    op.add_input(&max_output_size_per_class.to_handle()?)?;
    op.add_input(&max_total_size.to_handle()?)?;
    op.add_input(&iou_threshold.to_handle()?)?;
    op.add_input(&score_threshold.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.pad_per_class {
        op.set_attr_bool("pad_per_class", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.clip_boxes {
        op.set_attr_bool("clip_boxes", *value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Complex
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Complex {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl Complex {
    /// Creates a new `Complex`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// complex with default options.
pub fn complex<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    real: T0,
    imag: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Complex::new();
    complex_with_args(ctx, real, imag, &__args)
}

/// complex with options.
pub fn complex_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    real: T0,
    imag: T1,
    __args: &Complex,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Complex")?;

    // Required input arguments
    op.add_input(&real.to_handle()?)?;
    op.add_input(&imag.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ComplexAbs
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ComplexAbs {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl ComplexAbs {
    /// Creates a new `ComplexAbs`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// complex_abs with default options.
pub fn complex_abs<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ComplexAbs::new();
    complex_abs_with_args(ctx, x, &__args)
}

/// complex_abs with options.
pub fn complex_abs_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &ComplexAbs,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ComplexAbs")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CompositeTensorVariantFromComponents
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CompositeTensorVariantFromComponents {
    pub metadata: ::std::option::Option<::std::string::String>,
    pub Tcomponents: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl CompositeTensorVariantFromComponents {
    /// Creates a new `CompositeTensorVariantFromComponents`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// composite_tensor_variant_from_components with default options.
pub fn composite_tensor_variant_from_components<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    components: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = CompositeTensorVariantFromComponents::new();
    composite_tensor_variant_from_components_with_args(ctx, components, &__args)
}

/// composite_tensor_variant_from_components with options.
pub fn composite_tensor_variant_from_components_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    components: T0,
    __args: &CompositeTensorVariantFromComponents,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CompositeTensorVariantFromComponents")?;

    // Required input arguments
    op.add_input(&components.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.metadata {
        op.set_attr_string("metadata", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcomponents {
        op.set_attr_type_list("Tcomponents", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CompositeTensorVariantToComponents
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CompositeTensorVariantToComponents {
    pub metadata: ::std::option::Option<::std::string::String>,
    pub Tcomponents: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl CompositeTensorVariantToComponents {
    /// Creates a new `CompositeTensorVariantToComponents`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// composite_tensor_variant_to_components with default options.
pub fn composite_tensor_variant_to_components<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    encoded: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = CompositeTensorVariantToComponents::new();
    composite_tensor_variant_to_components_with_args(ctx, encoded, &__args)
}

/// composite_tensor_variant_to_components with options.
pub fn composite_tensor_variant_to_components_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    encoded: T0,
    __args: &CompositeTensorVariantToComponents,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CompositeTensorVariantToComponents")?;

    // Required input arguments
    op.add_input(&encoded.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.metadata {
        op.set_attr_string("metadata", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcomponents {
        op.set_attr_type_list("Tcomponents", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CompressElement
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CompressElement {
    pub input_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl CompressElement {
    /// Creates a new `CompressElement`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// compress_element with default options.
pub fn compress_element<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    components: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = CompressElement::new();
    compress_element_with_args(ctx, components, &__args)
}

/// compress_element with options.
pub fn compress_element_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    components: T0,
    __args: &CompressElement,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CompressElement")?;

    // Required input arguments
    op.add_input(&components.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.input_types {
        op.set_attr_type_list("input_types", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ComputeAccidentalHits
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ComputeAccidentalHits {
    pub num_true: ::std::option::Option<i64>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
}

impl ComputeAccidentalHits {
    /// Creates a new `ComputeAccidentalHits`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// compute_accidental_hits with default options.
pub fn compute_accidental_hits<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
    sampled_candidates: T1,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = ComputeAccidentalHits::new();
    compute_accidental_hits_with_args(ctx, true_classes, sampled_candidates, &__args)
}

/// compute_accidental_hits with options.
pub fn compute_accidental_hits_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
    sampled_candidates: T1,
    __args: &ComputeAccidentalHits,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ComputeAccidentalHits")?;

    // Required input arguments
    op.add_input(&true_classes.to_handle()?)?;
    op.add_input(&sampled_candidates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_true {
        op.set_attr_int("num_true", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// ComputeBatchSize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ComputeBatchSize {}

impl ComputeBatchSize {
    /// Creates a new `ComputeBatchSize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// compute_batch_size with default options.
pub fn compute_batch_size<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ComputeBatchSize::new();
    compute_batch_size_with_args(ctx, input_dataset, &__args)
}

/// compute_batch_size with options.
pub fn compute_batch_size_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &ComputeBatchSize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ComputeBatchSize")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Concat
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Concat {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl Concat {
    /// Creates a new `Concat`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// concat with default options.
pub fn concat<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    concat_dim: T0,
    values: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Concat::new();
    concat_with_args(ctx, concat_dim, values, &__args)
}

/// concat with options.
pub fn concat_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    concat_dim: T0,
    values: T1,
    __args: &Concat,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Concat")?;

    // Required input arguments
    op.add_input(&concat_dim.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ConcatOffset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConcatOffset {
    pub N: ::std::option::Option<i64>,
}

impl ConcatOffset {
    /// Creates a new `ConcatOffset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// concat_offset with default options.
pub fn concat_offset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    concat_dim: T0,
    shape: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ConcatOffset::new();
    concat_offset_with_args(ctx, concat_dim, shape, &__args)
}

/// concat_offset with options.
pub fn concat_offset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    concat_dim: T0,
    shape: T1,
    __args: &ConcatOffset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ConcatOffset")?;

    // Required input arguments
    op.add_input(&concat_dim.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ConcatV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConcatV2 {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl ConcatV2 {
    /// Creates a new `ConcatV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// concat_v2 with default options.
pub fn concat_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    values: T0,
    axis: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ConcatV2::new();
    concat_v2_with_args(ctx, values, axis, &__args)
}

/// concat_v2 with options.
pub fn concat_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    values: T0,
    axis: T1,
    __args: &ConcatV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ConcatV2")?;

    // Required input arguments
    op.add_input(&values.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ConcatenateDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConcatenateDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ConcatenateDataset {
    /// Creates a new `ConcatenateDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// concatenate_dataset with default options.
pub fn concatenate_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    another_dataset: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ConcatenateDataset::new();
    concatenate_dataset_with_args(ctx, input_dataset, another_dataset, &__args)
}

/// concatenate_dataset with options.
pub fn concatenate_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    another_dataset: T1,
    __args: &ConcatenateDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ConcatenateDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&another_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ConditionalAccumulator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConditionalAccumulator {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub reduction_type: ::std::option::Option<::std::string::String>,
}

impl ConditionalAccumulator {
    /// Creates a new `ConditionalAccumulator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// conditional_accumulator with default options.
pub fn conditional_accumulator(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = ConditionalAccumulator::new();
    conditional_accumulator_with_args(ctx, &__args)
}

/// conditional_accumulator with options.
pub fn conditional_accumulator_with_args(
    ctx: &crate::eager::Context,
    __args: &ConditionalAccumulator,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ConditionalAccumulator")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.reduction_type {
        op.set_attr_string("reduction_type", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ConfigureDistributedTPU
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConfigureDistributedTPU {
    pub embedding_config: ::std::option::Option<::std::string::String>,
    pub tpu_embedding_config: ::std::option::Option<::std::string::String>,
    pub is_global_init: ::std::option::Option<bool>,
    pub enable_whole_mesh_compilations: ::std::option::Option<bool>,
    pub compilation_failure_closes_chips: ::std::option::Option<bool>,
}

impl ConfigureDistributedTPU {
    /// Creates a new `ConfigureDistributedTPU`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// configure_distributed_tpu with default options.
pub fn configure_distributed_tpu(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = ConfigureDistributedTPU::new();
    configure_distributed_tpu_with_args(ctx, &__args)
}

/// configure_distributed_tpu with options.
pub fn configure_distributed_tpu_with_args(
    ctx: &crate::eager::Context,
    __args: &ConfigureDistributedTPU,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ConfigureDistributedTPU")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.embedding_config {
        op.set_attr_string("embedding_config", value);
    }
    if let ::std::option::Option::Some(value) = &__args.tpu_embedding_config {
        op.set_attr_string("tpu_embedding_config", value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_global_init {
        op.set_attr_bool("is_global_init", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.enable_whole_mesh_compilations {
        op.set_attr_bool("enable_whole_mesh_compilations", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.compilation_failure_closes_chips {
        op.set_attr_bool("compilation_failure_closes_chips", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ConfigureTPUEmbedding
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConfigureTPUEmbedding {
    pub config: ::std::option::Option<::std::string::String>,
}

impl ConfigureTPUEmbedding {
    /// Creates a new `ConfigureTPUEmbedding`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// configure_tpuembedding with default options.
pub fn configure_tpuembedding(ctx: &crate::eager::Context) -> Result<()> {
    let __args = ConfigureTPUEmbedding::new();
    configure_tpuembedding_with_args(ctx, &__args)
}

/// configure_tpuembedding with options.
pub fn configure_tpuembedding_with_args(
    ctx: &crate::eager::Context,
    __args: &ConfigureTPUEmbedding,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ConfigureTPUEmbedding")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Conj
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conj {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Conj {
    /// Creates a new `Conj`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// conj with default options.
pub fn conj<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Conj::new();
    conj_with_args(ctx, input, &__args)
}

/// conj with options.
pub fn conj_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Conj,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Conj")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ConjugateTranspose
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConjugateTranspose {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tperm: ::std::option::Option<crate::DataType>,
}

impl ConjugateTranspose {
    /// Creates a new `ConjugateTranspose`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// conjugate_transpose with default options.
pub fn conjugate_transpose<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    perm: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ConjugateTranspose::new();
    conjugate_transpose_with_args(ctx, x, perm, &__args)
}

/// conjugate_transpose with options.
pub fn conjugate_transpose_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    perm: T1,
    __args: &ConjugateTranspose,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ConjugateTranspose")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&perm.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tperm {
        op.set_attr_type("Tperm", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Const
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Const {
    value: ::std::option::Option<::std::boxed::Box<dyn crate::AnyTensor>>,
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl Const {
    /// Creates a new `Const`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// const_ with default options.
pub fn const_(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = Const::new();
    const__with_args(ctx, &__args)
}

/// const_ with options.
pub fn const__with_args(
    ctx: &crate::eager::Context,
    __args: &Const,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Const")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.value {
        op.set_attr_any_tensor("value", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ConsumeMutexLock
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConsumeMutexLock {}

impl ConsumeMutexLock {
    /// Creates a new `ConsumeMutexLock`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// consume_mutex_lock with default options.
pub fn consume_mutex_lock<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    mutex_lock: T0,
) -> Result<()> {
    let __args = ConsumeMutexLock::new();
    consume_mutex_lock_with_args(ctx, mutex_lock, &__args)
}

/// consume_mutex_lock with options.
pub fn consume_mutex_lock_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    mutex_lock: T0,
    __args: &ConsumeMutexLock,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ConsumeMutexLock")?;

    // Required input arguments
    op.add_input(&mutex_lock.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ControlTrigger
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ControlTrigger {}

impl ControlTrigger {
    /// Creates a new `ControlTrigger`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// control_trigger with default options.
pub fn control_trigger(ctx: &crate::eager::Context) -> Result<()> {
    let __args = ControlTrigger::new();
    control_trigger_with_args(ctx, &__args)
}

/// control_trigger with options.
pub fn control_trigger_with_args(
    ctx: &crate::eager::Context,
    __args: &ControlTrigger,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ControlTrigger")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Conv2D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv2D {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub use_cudnn_on_gpu: ::std::option::Option<bool>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl Conv2D {
    /// Creates a new `Conv2D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// conv2_d with default options.
pub fn conv2_d<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Conv2D::new();
    conv2_d_with_args(ctx, input, filter, &__args)
}

/// conv2_d with options.
pub fn conv2_d_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    __args: &Conv2D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Conv2D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_cudnn_on_gpu {
        op.set_attr_bool("use_cudnn_on_gpu", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.explicit_paddings {
        op.set_attr_int_list("explicit_paddings", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Conv2DBackpropFilter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv2DBackpropFilter {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub use_cudnn_on_gpu: ::std::option::Option<bool>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl Conv2DBackpropFilter {
    /// Creates a new `Conv2DBackpropFilter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// conv2_dbackprop_filter with default options.
pub fn conv2_dbackprop_filter<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter_sizes: T1,
    out_backprop: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Conv2DBackpropFilter::new();
    conv2_dbackprop_filter_with_args(ctx, input, filter_sizes, out_backprop, &__args)
}

/// conv2_dbackprop_filter with options.
pub fn conv2_dbackprop_filter_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter_sizes: T1,
    out_backprop: T2,
    __args: &Conv2DBackpropFilter,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Conv2DBackpropFilter")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter_sizes.to_handle()?)?;
    op.add_input(&out_backprop.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_cudnn_on_gpu {
        op.set_attr_bool("use_cudnn_on_gpu", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.explicit_paddings {
        op.set_attr_int_list("explicit_paddings", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Conv2DBackpropInput
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv2DBackpropInput {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub use_cudnn_on_gpu: ::std::option::Option<bool>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl Conv2DBackpropInput {
    /// Creates a new `Conv2DBackpropInput`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// conv2_dbackprop_input with default options.
pub fn conv2_dbackprop_input<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_sizes: T0,
    filter: T1,
    out_backprop: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Conv2DBackpropInput::new();
    conv2_dbackprop_input_with_args(ctx, input_sizes, filter, out_backprop, &__args)
}

/// conv2_dbackprop_input with options.
pub fn conv2_dbackprop_input_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_sizes: T0,
    filter: T1,
    out_backprop: T2,
    __args: &Conv2DBackpropInput,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Conv2DBackpropInput")?;

    // Required input arguments
    op.add_input(&input_sizes.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&out_backprop.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_cudnn_on_gpu {
        op.set_attr_bool("use_cudnn_on_gpu", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.explicit_paddings {
        op.set_attr_int_list("explicit_paddings", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Conv3D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv3D {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl Conv3D {
    /// Creates a new `Conv3D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// conv3_d with default options.
pub fn conv3_d<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Conv3D::new();
    conv3_d_with_args(ctx, input, filter, &__args)
}

/// conv3_d with options.
pub fn conv3_d_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    __args: &Conv3D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Conv3D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Conv3DBackpropFilter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv3DBackpropFilter {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl Conv3DBackpropFilter {
    /// Creates a new `Conv3DBackpropFilter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// conv3_dbackprop_filter with default options.
pub fn conv3_dbackprop_filter<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    out_backprop: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Conv3DBackpropFilter::new();
    conv3_dbackprop_filter_with_args(ctx, input, filter, out_backprop, &__args)
}

/// conv3_dbackprop_filter with options.
pub fn conv3_dbackprop_filter_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    out_backprop: T2,
    __args: &Conv3DBackpropFilter,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Conv3DBackpropFilter")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&out_backprop.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Conv3DBackpropFilterV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv3DBackpropFilterV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl Conv3DBackpropFilterV2 {
    /// Creates a new `Conv3DBackpropFilterV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// conv3_dbackprop_filter_v2 with default options.
pub fn conv3_dbackprop_filter_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter_sizes: T1,
    out_backprop: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Conv3DBackpropFilterV2::new();
    conv3_dbackprop_filter_v2_with_args(ctx, input, filter_sizes, out_backprop, &__args)
}

/// conv3_dbackprop_filter_v2 with options.
pub fn conv3_dbackprop_filter_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter_sizes: T1,
    out_backprop: T2,
    __args: &Conv3DBackpropFilterV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Conv3DBackpropFilterV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter_sizes.to_handle()?)?;
    op.add_input(&out_backprop.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Conv3DBackpropInput
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv3DBackpropInput {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl Conv3DBackpropInput {
    /// Creates a new `Conv3DBackpropInput`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// conv3_dbackprop_input with default options.
pub fn conv3_dbackprop_input<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    out_backprop: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Conv3DBackpropInput::new();
    conv3_dbackprop_input_with_args(ctx, input, filter, out_backprop, &__args)
}

/// conv3_dbackprop_input with options.
pub fn conv3_dbackprop_input_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    out_backprop: T2,
    __args: &Conv3DBackpropInput,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Conv3DBackpropInput")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&out_backprop.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Conv3DBackpropInputV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv3DBackpropInputV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub Tshape: ::std::option::Option<crate::DataType>,
}

impl Conv3DBackpropInputV2 {
    /// Creates a new `Conv3DBackpropInputV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// conv3_dbackprop_input_v2 with default options.
pub fn conv3_dbackprop_input_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_sizes: T0,
    filter: T1,
    out_backprop: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Conv3DBackpropInputV2::new();
    conv3_dbackprop_input_v2_with_args(ctx, input_sizes, filter, out_backprop, &__args)
}

/// conv3_dbackprop_input_v2 with options.
pub fn conv3_dbackprop_input_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_sizes: T0,
    filter: T1,
    out_backprop: T2,
    __args: &Conv3DBackpropInputV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Conv3DBackpropInputV2")?;

    // Required input arguments
    op.add_input(&input_sizes.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&out_backprop.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshape {
        op.set_attr_type("Tshape", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Copy
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Copy {
    pub T: ::std::option::Option<crate::DataType>,
    pub tensor_name: ::std::option::Option<::std::string::String>,
    pub debug_ops_spec: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}

impl Copy {
    /// Creates a new `Copy`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// copy with default options.
pub fn copy<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Copy::new();
    copy_with_args(ctx, input, &__args)
}

/// copy with options.
pub fn copy_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Copy,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Copy")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_name {
        op.set_attr_string("tensor_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.debug_ops_spec {
        op.set_attr_string_list("debug_ops_spec", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CopyHost
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CopyHost {
    pub T: ::std::option::Option<crate::DataType>,
    pub tensor_name: ::std::option::Option<::std::string::String>,
    pub debug_ops_spec: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}

impl CopyHost {
    /// Creates a new `CopyHost`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// copy_host with default options.
pub fn copy_host<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = CopyHost::new();
    copy_host_with_args(ctx, input, &__args)
}

/// copy_host with options.
pub fn copy_host_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &CopyHost,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CopyHost")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_name {
        op.set_attr_string("tensor_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.debug_ops_spec {
        op.set_attr_string_list("debug_ops_spec", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Cos
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cos {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Cos {
    /// Creates a new `Cos`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cos with default options.
pub fn cos<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Cos::new();
    cos_with_args(ctx, x, &__args)
}

/// cos with options.
pub fn cos_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Cos,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Cos")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Cosh
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cosh {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Cosh {
    /// Creates a new `Cosh`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cosh with default options.
pub fn cosh<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Cosh::new();
    cosh_with_args(ctx, x, &__args)
}

/// cosh with options.
pub fn cosh_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Cosh,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Cosh")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CountUpTo
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CountUpTo {
    pub limit: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl CountUpTo {
    /// Creates a new `CountUpTo`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// count_up_to with default options.
pub fn count_up_to<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    ref_: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = CountUpTo::new();
    count_up_to_with_args(ctx, ref_, &__args)
}

/// count_up_to with options.
pub fn count_up_to_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    ref_: T0,
    __args: &CountUpTo,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CountUpTo")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.limit {
        op.set_attr_int("limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CreateSummaryDbWriter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CreateSummaryDbWriter {}

impl CreateSummaryDbWriter {
    /// Creates a new `CreateSummaryDbWriter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// create_summary_db_writer with default options.
pub fn create_summary_db_writer<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    db_uri: T1,
    experiment_name: T2,
    run_name: T3,
    user_name: T4,
) -> Result<()> {
    let __args = CreateSummaryDbWriter::new();
    create_summary_db_writer_with_args(
        ctx,
        writer,
        db_uri,
        experiment_name,
        run_name,
        user_name,
        &__args,
    )
}

/// create_summary_db_writer with options.
pub fn create_summary_db_writer_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    db_uri: T1,
    experiment_name: T2,
    run_name: T3,
    user_name: T4,
    __args: &CreateSummaryDbWriter,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CreateSummaryDbWriter")?;

    // Required input arguments
    op.add_input(&writer.to_handle()?)?;
    op.add_input(&db_uri.to_handle()?)?;
    op.add_input(&experiment_name.to_handle()?)?;
    op.add_input(&run_name.to_handle()?)?;
    op.add_input(&user_name.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// CreateSummaryFileWriter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CreateSummaryFileWriter {}

impl CreateSummaryFileWriter {
    /// Creates a new `CreateSummaryFileWriter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// create_summary_file_writer with default options.
pub fn create_summary_file_writer<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    logdir: T1,
    max_queue: T2,
    flush_millis: T3,
    filename_suffix: T4,
) -> Result<()> {
    let __args = CreateSummaryFileWriter::new();
    create_summary_file_writer_with_args(
        ctx,
        writer,
        logdir,
        max_queue,
        flush_millis,
        filename_suffix,
        &__args,
    )
}

/// create_summary_file_writer with options.
pub fn create_summary_file_writer_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    logdir: T1,
    max_queue: T2,
    flush_millis: T3,
    filename_suffix: T4,
    __args: &CreateSummaryFileWriter,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CreateSummaryFileWriter")?;

    // Required input arguments
    op.add_input(&writer.to_handle()?)?;
    op.add_input(&logdir.to_handle()?)?;
    op.add_input(&max_queue.to_handle()?)?;
    op.add_input(&flush_millis.to_handle()?)?;
    op.add_input(&filename_suffix.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// CropAndResize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CropAndResize {
    pub T: ::std::option::Option<crate::DataType>,
    pub method: ::std::option::Option<::std::string::String>,
    pub extrapolation_value: ::std::option::Option<f32>,
}

impl CropAndResize {
    /// Creates a new `CropAndResize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// crop_and_resize with default options.
pub fn crop_and_resize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    image: T0,
    boxes: T1,
    box_ind: T2,
    crop_size: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = CropAndResize::new();
    crop_and_resize_with_args(ctx, image, boxes, box_ind, crop_size, &__args)
}

/// crop_and_resize with options.
pub fn crop_and_resize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    image: T0,
    boxes: T1,
    box_ind: T2,
    crop_size: T3,
    __args: &CropAndResize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CropAndResize")?;

    // Required input arguments
    op.add_input(&image.to_handle()?)?;
    op.add_input(&boxes.to_handle()?)?;
    op.add_input(&box_ind.to_handle()?)?;
    op.add_input(&crop_size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.method {
        op.set_attr_string("method", value);
    }
    if let ::std::option::Option::Some(value) = &__args.extrapolation_value {
        op.set_attr_float("extrapolation_value", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CropAndResizeGradBoxes
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CropAndResizeGradBoxes {
    pub T: ::std::option::Option<crate::DataType>,
    pub method: ::std::option::Option<::std::string::String>,
}

impl CropAndResizeGradBoxes {
    /// Creates a new `CropAndResizeGradBoxes`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// crop_and_resize_grad_boxes with default options.
pub fn crop_and_resize_grad_boxes<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grads: T0,
    image: T1,
    boxes: T2,
    box_ind: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = CropAndResizeGradBoxes::new();
    crop_and_resize_grad_boxes_with_args(ctx, grads, image, boxes, box_ind, &__args)
}

/// crop_and_resize_grad_boxes with options.
pub fn crop_and_resize_grad_boxes_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grads: T0,
    image: T1,
    boxes: T2,
    box_ind: T3,
    __args: &CropAndResizeGradBoxes,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CropAndResizeGradBoxes")?;

    // Required input arguments
    op.add_input(&grads.to_handle()?)?;
    op.add_input(&image.to_handle()?)?;
    op.add_input(&boxes.to_handle()?)?;
    op.add_input(&box_ind.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.method {
        op.set_attr_string("method", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CropAndResizeGradImage
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CropAndResizeGradImage {
    pub T: ::std::option::Option<crate::DataType>,
    pub method: ::std::option::Option<::std::string::String>,
}

impl CropAndResizeGradImage {
    /// Creates a new `CropAndResizeGradImage`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// crop_and_resize_grad_image with default options.
pub fn crop_and_resize_grad_image<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grads: T0,
    boxes: T1,
    box_ind: T2,
    image_size: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = CropAndResizeGradImage::new();
    crop_and_resize_grad_image_with_args(ctx, grads, boxes, box_ind, image_size, &__args)
}

/// crop_and_resize_grad_image with options.
pub fn crop_and_resize_grad_image_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grads: T0,
    boxes: T1,
    box_ind: T2,
    image_size: T3,
    __args: &CropAndResizeGradImage,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CropAndResizeGradImage")?;

    // Required input arguments
    op.add_input(&grads.to_handle()?)?;
    op.add_input(&boxes.to_handle()?)?;
    op.add_input(&box_ind.to_handle()?)?;
    op.add_input(&image_size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.method {
        op.set_attr_string("method", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Cross
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cross {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Cross {
    /// Creates a new `Cross`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cross with default options.
pub fn cross<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Cross::new();
    cross_with_args(ctx, a, b, &__args)
}

/// cross with options.
pub fn cross_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    __args: &Cross,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Cross")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CrossReplicaSum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CrossReplicaSum {
    pub T: ::std::option::Option<crate::DataType>,
}

impl CrossReplicaSum {
    /// Creates a new `CrossReplicaSum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cross_replica_sum with default options.
pub fn cross_replica_sum<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    group_assignment: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = CrossReplicaSum::new();
    cross_replica_sum_with_args(ctx, input, group_assignment, &__args)
}

/// cross_replica_sum with options.
pub fn cross_replica_sum_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    group_assignment: T1,
    __args: &CrossReplicaSum,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CrossReplicaSum")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&group_assignment.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CudnnRNN
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNN {
    pub T: ::std::option::Option<crate::DataType>,
    pub rnn_mode: ::std::option::Option<::std::string::String>,
    pub input_mode: ::std::option::Option<::std::string::String>,
    pub direction: ::std::option::Option<::std::string::String>,
    pub dropout: ::std::option::Option<f32>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub is_training: ::std::option::Option<bool>,
}

impl CudnnRNN {
    /// Creates a new `CudnnRNN`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cudnn_rnn with default options.
pub fn cudnn_rnn<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_h: T1,
    input_c: T2,
    params: T3,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = CudnnRNN::new();
    cudnn_rnn_with_args(ctx, input, input_h, input_c, params, &__args)
}

/// cudnn_rnn with options.
pub fn cudnn_rnn_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_h: T1,
    input_c: T2,
    params: T3,
    __args: &CudnnRNN,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CudnnRNN")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_h.to_handle()?)?;
    op.add_input(&input_c.to_handle()?)?;
    op.add_input(&params.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.rnn_mode {
        op.set_attr_string("rnn_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_mode {
        op.set_attr_string("input_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.direction {
        op.set_attr_string("direction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dropout {
        op.set_attr_float("dropout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_training {
        op.set_attr_bool("is_training", *value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CudnnRNNBackprop
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNBackprop {
    pub T: ::std::option::Option<crate::DataType>,
    pub rnn_mode: ::std::option::Option<::std::string::String>,
    pub input_mode: ::std::option::Option<::std::string::String>,
    pub direction: ::std::option::Option<::std::string::String>,
    pub dropout: ::std::option::Option<f32>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
}

impl CudnnRNNBackprop {
    /// Creates a new `CudnnRNNBackprop`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cudnn_rnnbackprop with default options.
pub fn cudnn_rnnbackprop<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_h: T1,
    input_c: T2,
    params: T3,
    output: T4,
    output_h: T5,
    output_c: T6,
    output_backprop: T7,
    output_h_backprop: T8,
    output_c_backprop: T9,
    reserve_space: T10,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = CudnnRNNBackprop::new();
    cudnn_rnnbackprop_with_args(
        ctx,
        input,
        input_h,
        input_c,
        params,
        output,
        output_h,
        output_c,
        output_backprop,
        output_h_backprop,
        output_c_backprop,
        reserve_space,
        &__args,
    )
}

/// cudnn_rnnbackprop with options.
pub fn cudnn_rnnbackprop_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_h: T1,
    input_c: T2,
    params: T3,
    output: T4,
    output_h: T5,
    output_c: T6,
    output_backprop: T7,
    output_h_backprop: T8,
    output_c_backprop: T9,
    reserve_space: T10,
    __args: &CudnnRNNBackprop,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CudnnRNNBackprop")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_h.to_handle()?)?;
    op.add_input(&input_c.to_handle()?)?;
    op.add_input(&params.to_handle()?)?;
    op.add_input(&output.to_handle()?)?;
    op.add_input(&output_h.to_handle()?)?;
    op.add_input(&output_c.to_handle()?)?;
    op.add_input(&output_backprop.to_handle()?)?;
    op.add_input(&output_h_backprop.to_handle()?)?;
    op.add_input(&output_c_backprop.to_handle()?)?;
    op.add_input(&reserve_space.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.rnn_mode {
        op.set_attr_string("rnn_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_mode {
        op.set_attr_string("input_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.direction {
        op.set_attr_string("direction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dropout {
        op.set_attr_float("dropout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CudnnRNNBackpropV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNBackpropV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub rnn_mode: ::std::option::Option<::std::string::String>,
    pub input_mode: ::std::option::Option<::std::string::String>,
    pub direction: ::std::option::Option<::std::string::String>,
    pub dropout: ::std::option::Option<f32>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
}

impl CudnnRNNBackpropV2 {
    /// Creates a new `CudnnRNNBackpropV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cudnn_rnnbackprop_v2 with default options.
pub fn cudnn_rnnbackprop_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_h: T1,
    input_c: T2,
    params: T3,
    output: T4,
    output_h: T5,
    output_c: T6,
    output_backprop: T7,
    output_h_backprop: T8,
    output_c_backprop: T9,
    reserve_space: T10,
    host_reserved: T11,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = CudnnRNNBackpropV2::new();
    cudnn_rnnbackprop_v2_with_args(
        ctx,
        input,
        input_h,
        input_c,
        params,
        output,
        output_h,
        output_c,
        output_backprop,
        output_h_backprop,
        output_c_backprop,
        reserve_space,
        host_reserved,
        &__args,
    )
}

/// cudnn_rnnbackprop_v2 with options.
pub fn cudnn_rnnbackprop_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_h: T1,
    input_c: T2,
    params: T3,
    output: T4,
    output_h: T5,
    output_c: T6,
    output_backprop: T7,
    output_h_backprop: T8,
    output_c_backprop: T9,
    reserve_space: T10,
    host_reserved: T11,
    __args: &CudnnRNNBackpropV2,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CudnnRNNBackpropV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_h.to_handle()?)?;
    op.add_input(&input_c.to_handle()?)?;
    op.add_input(&params.to_handle()?)?;
    op.add_input(&output.to_handle()?)?;
    op.add_input(&output_h.to_handle()?)?;
    op.add_input(&output_c.to_handle()?)?;
    op.add_input(&output_backprop.to_handle()?)?;
    op.add_input(&output_h_backprop.to_handle()?)?;
    op.add_input(&output_c_backprop.to_handle()?)?;
    op.add_input(&reserve_space.to_handle()?)?;
    op.add_input(&host_reserved.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.rnn_mode {
        op.set_attr_string("rnn_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_mode {
        op.set_attr_string("input_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.direction {
        op.set_attr_string("direction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dropout {
        op.set_attr_float("dropout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CudnnRNNBackpropV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNBackpropV3 {
    pub T: ::std::option::Option<crate::DataType>,
    pub rnn_mode: ::std::option::Option<::std::string::String>,
    pub input_mode: ::std::option::Option<::std::string::String>,
    pub direction: ::std::option::Option<::std::string::String>,
    pub dropout: ::std::option::Option<f32>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub num_proj: ::std::option::Option<i64>,
    pub time_major: ::std::option::Option<bool>,
}

impl CudnnRNNBackpropV3 {
    /// Creates a new `CudnnRNNBackpropV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cudnn_rnnbackprop_v3 with default options.
pub fn cudnn_rnnbackprop_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
    T12: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_h: T1,
    input_c: T2,
    params: T3,
    sequence_lengths: T4,
    output: T5,
    output_h: T6,
    output_c: T7,
    output_backprop: T8,
    output_h_backprop: T9,
    output_c_backprop: T10,
    reserve_space: T11,
    host_reserved: T12,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = CudnnRNNBackpropV3::new();
    cudnn_rnnbackprop_v3_with_args(
        ctx,
        input,
        input_h,
        input_c,
        params,
        sequence_lengths,
        output,
        output_h,
        output_c,
        output_backprop,
        output_h_backprop,
        output_c_backprop,
        reserve_space,
        host_reserved,
        &__args,
    )
}

/// cudnn_rnnbackprop_v3 with options.
pub fn cudnn_rnnbackprop_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
    T12: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_h: T1,
    input_c: T2,
    params: T3,
    sequence_lengths: T4,
    output: T5,
    output_h: T6,
    output_c: T7,
    output_backprop: T8,
    output_h_backprop: T9,
    output_c_backprop: T10,
    reserve_space: T11,
    host_reserved: T12,
    __args: &CudnnRNNBackpropV3,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CudnnRNNBackpropV3")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_h.to_handle()?)?;
    op.add_input(&input_c.to_handle()?)?;
    op.add_input(&params.to_handle()?)?;
    op.add_input(&sequence_lengths.to_handle()?)?;
    op.add_input(&output.to_handle()?)?;
    op.add_input(&output_h.to_handle()?)?;
    op.add_input(&output_c.to_handle()?)?;
    op.add_input(&output_backprop.to_handle()?)?;
    op.add_input(&output_h_backprop.to_handle()?)?;
    op.add_input(&output_c_backprop.to_handle()?)?;
    op.add_input(&reserve_space.to_handle()?)?;
    op.add_input(&host_reserved.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.rnn_mode {
        op.set_attr_string("rnn_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_mode {
        op.set_attr_string("input_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.direction {
        op.set_attr_string("direction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dropout {
        op.set_attr_float("dropout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_proj {
        op.set_attr_int("num_proj", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.time_major {
        op.set_attr_bool("time_major", *value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CudnnRNNCanonicalToParams
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNCanonicalToParams {
    pub T: ::std::option::Option<crate::DataType>,
    pub num_params: ::std::option::Option<i64>,
    pub rnn_mode: ::std::option::Option<::std::string::String>,
    pub input_mode: ::std::option::Option<::std::string::String>,
    pub direction: ::std::option::Option<::std::string::String>,
    pub dropout: ::std::option::Option<f32>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
}

impl CudnnRNNCanonicalToParams {
    /// Creates a new `CudnnRNNCanonicalToParams`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cudnn_rnncanonical_to_params with default options.
pub fn cudnn_rnncanonical_to_params<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    num_layers: T0,
    num_units: T1,
    input_size: T2,
    weights: T3,
    biases: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = CudnnRNNCanonicalToParams::new();
    cudnn_rnncanonical_to_params_with_args(
        ctx, num_layers, num_units, input_size, weights, biases, &__args,
    )
}

/// cudnn_rnncanonical_to_params with options.
pub fn cudnn_rnncanonical_to_params_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    num_layers: T0,
    num_units: T1,
    input_size: T2,
    weights: T3,
    biases: T4,
    __args: &CudnnRNNCanonicalToParams,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CudnnRNNCanonicalToParams")?;

    // Required input arguments
    op.add_input(&num_layers.to_handle()?)?;
    op.add_input(&num_units.to_handle()?)?;
    op.add_input(&input_size.to_handle()?)?;
    op.add_input(&weights.to_handle()?)?;
    op.add_input(&biases.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_params {
        op.set_attr_int("num_params", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.rnn_mode {
        op.set_attr_string("rnn_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_mode {
        op.set_attr_string("input_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.direction {
        op.set_attr_string("direction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dropout {
        op.set_attr_float("dropout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CudnnRNNCanonicalToParamsV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNCanonicalToParamsV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub num_params_weights: ::std::option::Option<i64>,
    pub num_params_biases: ::std::option::Option<i64>,
    pub rnn_mode: ::std::option::Option<::std::string::String>,
    pub input_mode: ::std::option::Option<::std::string::String>,
    pub direction: ::std::option::Option<::std::string::String>,
    pub dropout: ::std::option::Option<f32>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub num_proj: ::std::option::Option<i64>,
}

impl CudnnRNNCanonicalToParamsV2 {
    /// Creates a new `CudnnRNNCanonicalToParamsV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cudnn_rnncanonical_to_params_v2 with default options.
pub fn cudnn_rnncanonical_to_params_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    num_layers: T0,
    num_units: T1,
    input_size: T2,
    weights: T3,
    biases: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = CudnnRNNCanonicalToParamsV2::new();
    cudnn_rnncanonical_to_params_v2_with_args(
        ctx, num_layers, num_units, input_size, weights, biases, &__args,
    )
}

/// cudnn_rnncanonical_to_params_v2 with options.
pub fn cudnn_rnncanonical_to_params_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    num_layers: T0,
    num_units: T1,
    input_size: T2,
    weights: T3,
    biases: T4,
    __args: &CudnnRNNCanonicalToParamsV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CudnnRNNCanonicalToParamsV2")?;

    // Required input arguments
    op.add_input(&num_layers.to_handle()?)?;
    op.add_input(&num_units.to_handle()?)?;
    op.add_input(&input_size.to_handle()?)?;
    op.add_input(&weights.to_handle()?)?;
    op.add_input(&biases.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_params_weights {
        op.set_attr_int("num_params_weights", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_params_biases {
        op.set_attr_int("num_params_biases", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.rnn_mode {
        op.set_attr_string("rnn_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_mode {
        op.set_attr_string("input_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.direction {
        op.set_attr_string("direction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dropout {
        op.set_attr_float("dropout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_proj {
        op.set_attr_int("num_proj", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CudnnRNNParamsSize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNParamsSize {
    pub T: ::std::option::Option<crate::DataType>,
    pub S: ::std::option::Option<crate::DataType>,
    pub rnn_mode: ::std::option::Option<::std::string::String>,
    pub input_mode: ::std::option::Option<::std::string::String>,
    pub direction: ::std::option::Option<::std::string::String>,
    pub dropout: ::std::option::Option<f32>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub num_proj: ::std::option::Option<i64>,
}

impl CudnnRNNParamsSize {
    /// Creates a new `CudnnRNNParamsSize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cudnn_rnnparams_size with default options.
pub fn cudnn_rnnparams_size<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    num_layers: T0,
    num_units: T1,
    input_size: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = CudnnRNNParamsSize::new();
    cudnn_rnnparams_size_with_args(ctx, num_layers, num_units, input_size, &__args)
}

/// cudnn_rnnparams_size with options.
pub fn cudnn_rnnparams_size_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    num_layers: T0,
    num_units: T1,
    input_size: T2,
    __args: &CudnnRNNParamsSize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CudnnRNNParamsSize")?;

    // Required input arguments
    op.add_input(&num_layers.to_handle()?)?;
    op.add_input(&num_units.to_handle()?)?;
    op.add_input(&input_size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.S {
        op.set_attr_type("S", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.rnn_mode {
        op.set_attr_string("rnn_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_mode {
        op.set_attr_string("input_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.direction {
        op.set_attr_string("direction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dropout {
        op.set_attr_float("dropout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_proj {
        op.set_attr_int("num_proj", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CudnnRNNParamsToCanonical
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNParamsToCanonical {
    pub T: ::std::option::Option<crate::DataType>,
    pub num_params: ::std::option::Option<i64>,
    pub rnn_mode: ::std::option::Option<::std::string::String>,
    pub input_mode: ::std::option::Option<::std::string::String>,
    pub direction: ::std::option::Option<::std::string::String>,
    pub dropout: ::std::option::Option<f32>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
}

impl CudnnRNNParamsToCanonical {
    /// Creates a new `CudnnRNNParamsToCanonical`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cudnn_rnnparams_to_canonical with default options.
pub fn cudnn_rnnparams_to_canonical<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    num_layers: T0,
    num_units: T1,
    input_size: T2,
    params: T3,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = CudnnRNNParamsToCanonical::new();
    cudnn_rnnparams_to_canonical_with_args(ctx, num_layers, num_units, input_size, params, &__args)
}

/// cudnn_rnnparams_to_canonical with options.
pub fn cudnn_rnnparams_to_canonical_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    num_layers: T0,
    num_units: T1,
    input_size: T2,
    params: T3,
    __args: &CudnnRNNParamsToCanonical,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CudnnRNNParamsToCanonical")?;

    // Required input arguments
    op.add_input(&num_layers.to_handle()?)?;
    op.add_input(&num_units.to_handle()?)?;
    op.add_input(&input_size.to_handle()?)?;
    op.add_input(&params.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_params {
        op.set_attr_int("num_params", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.rnn_mode {
        op.set_attr_string("rnn_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_mode {
        op.set_attr_string("input_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.direction {
        op.set_attr_string("direction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dropout {
        op.set_attr_float("dropout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CudnnRNNParamsToCanonicalV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNParamsToCanonicalV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub num_params_weights: ::std::option::Option<i64>,
    pub num_params_biases: ::std::option::Option<i64>,
    pub rnn_mode: ::std::option::Option<::std::string::String>,
    pub input_mode: ::std::option::Option<::std::string::String>,
    pub direction: ::std::option::Option<::std::string::String>,
    pub dropout: ::std::option::Option<f32>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub num_proj: ::std::option::Option<i64>,
}

impl CudnnRNNParamsToCanonicalV2 {
    /// Creates a new `CudnnRNNParamsToCanonicalV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cudnn_rnnparams_to_canonical_v2 with default options.
pub fn cudnn_rnnparams_to_canonical_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    num_layers: T0,
    num_units: T1,
    input_size: T2,
    params: T3,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = CudnnRNNParamsToCanonicalV2::new();
    cudnn_rnnparams_to_canonical_v2_with_args(
        ctx, num_layers, num_units, input_size, params, &__args,
    )
}

/// cudnn_rnnparams_to_canonical_v2 with options.
pub fn cudnn_rnnparams_to_canonical_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    num_layers: T0,
    num_units: T1,
    input_size: T2,
    params: T3,
    __args: &CudnnRNNParamsToCanonicalV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CudnnRNNParamsToCanonicalV2")?;

    // Required input arguments
    op.add_input(&num_layers.to_handle()?)?;
    op.add_input(&num_units.to_handle()?)?;
    op.add_input(&input_size.to_handle()?)?;
    op.add_input(&params.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_params_weights {
        op.set_attr_int("num_params_weights", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_params_biases {
        op.set_attr_int("num_params_biases", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.rnn_mode {
        op.set_attr_string("rnn_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_mode {
        op.set_attr_string("input_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.direction {
        op.set_attr_string("direction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dropout {
        op.set_attr_float("dropout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_proj {
        op.set_attr_int("num_proj", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CudnnRNNV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub rnn_mode: ::std::option::Option<::std::string::String>,
    pub input_mode: ::std::option::Option<::std::string::String>,
    pub direction: ::std::option::Option<::std::string::String>,
    pub dropout: ::std::option::Option<f32>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub is_training: ::std::option::Option<bool>,
}

impl CudnnRNNV2 {
    /// Creates a new `CudnnRNNV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cudnn_rnnv2 with default options.
pub fn cudnn_rnnv2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_h: T1,
    input_c: T2,
    params: T3,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let __args = CudnnRNNV2::new();
    cudnn_rnnv2_with_args(ctx, input, input_h, input_c, params, &__args)
}

/// cudnn_rnnv2 with options.
pub fn cudnn_rnnv2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_h: T1,
    input_c: T2,
    params: T3,
    __args: &CudnnRNNV2,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CudnnRNNV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_h.to_handle()?)?;
    op.add_input(&input_c.to_handle()?)?;
    op.add_input(&params.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.rnn_mode {
        op.set_attr_string("rnn_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_mode {
        op.set_attr_string("input_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.direction {
        op.set_attr_string("direction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dropout {
        op.set_attr_float("dropout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_training {
        op.set_attr_bool("is_training", *value);
    }

    // Execute Op
    let mut num_output = 5;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 5];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// CudnnRNNV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNV3 {
    pub T: ::std::option::Option<crate::DataType>,
    pub rnn_mode: ::std::option::Option<::std::string::String>,
    pub input_mode: ::std::option::Option<::std::string::String>,
    pub direction: ::std::option::Option<::std::string::String>,
    pub dropout: ::std::option::Option<f32>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub num_proj: ::std::option::Option<i64>,
    pub is_training: ::std::option::Option<bool>,
    pub time_major: ::std::option::Option<bool>,
}

impl CudnnRNNV3 {
    /// Creates a new `CudnnRNNV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cudnn_rnnv3 with default options.
pub fn cudnn_rnnv3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_h: T1,
    input_c: T2,
    params: T3,
    sequence_lengths: T4,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let __args = CudnnRNNV3::new();
    cudnn_rnnv3_with_args(
        ctx,
        input,
        input_h,
        input_c,
        params,
        sequence_lengths,
        &__args,
    )
}

/// cudnn_rnnv3 with options.
pub fn cudnn_rnnv3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_h: T1,
    input_c: T2,
    params: T3,
    sequence_lengths: T4,
    __args: &CudnnRNNV3,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CudnnRNNV3")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_h.to_handle()?)?;
    op.add_input(&input_c.to_handle()?)?;
    op.add_input(&params.to_handle()?)?;
    op.add_input(&sequence_lengths.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.rnn_mode {
        op.set_attr_string("rnn_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_mode {
        op.set_attr_string("input_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.direction {
        op.set_attr_string("direction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dropout {
        op.set_attr_float("dropout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_proj {
        op.set_attr_int("num_proj", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_training {
        op.set_attr_bool("is_training", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.time_major {
        op.set_attr_bool("time_major", *value);
    }

    // Execute Op
    let mut num_output = 5;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 5];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Cumprod
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cumprod {
    pub exclusive: ::std::option::Option<bool>,
    pub reverse: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl Cumprod {
    /// Creates a new `Cumprod`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cumprod with default options.
pub fn cumprod<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    axis: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Cumprod::new();
    cumprod_with_args(ctx, x, axis, &__args)
}

/// cumprod with options.
pub fn cumprod_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    axis: T1,
    __args: &Cumprod,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Cumprod")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.exclusive {
        op.set_attr_bool("exclusive", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.reverse {
        op.set_attr_bool("reverse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Cumsum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cumsum {
    pub exclusive: ::std::option::Option<bool>,
    pub reverse: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl Cumsum {
    /// Creates a new `Cumsum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cumsum with default options.
pub fn cumsum<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    axis: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Cumsum::new();
    cumsum_with_args(ctx, x, axis, &__args)
}

/// cumsum with options.
pub fn cumsum_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    axis: T1,
    __args: &Cumsum,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Cumsum")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.exclusive {
        op.set_attr_bool("exclusive", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.reverse {
        op.set_attr_bool("reverse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// CumulativeLogsumexp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CumulativeLogsumexp {
    pub exclusive: ::std::option::Option<bool>,
    pub reverse: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl CumulativeLogsumexp {
    /// Creates a new `CumulativeLogsumexp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// cumulative_logsumexp with default options.
pub fn cumulative_logsumexp<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    axis: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = CumulativeLogsumexp::new();
    cumulative_logsumexp_with_args(ctx, x, axis, &__args)
}

/// cumulative_logsumexp with options.
pub fn cumulative_logsumexp_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    axis: T1,
    __args: &CumulativeLogsumexp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "CumulativeLogsumexp")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.exclusive {
        op.set_attr_bool("exclusive", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.reverse {
        op.set_attr_bool("reverse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DataFormatDimMap
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DataFormatDimMap {
    pub T: ::std::option::Option<crate::DataType>,
    pub src_format: ::std::option::Option<::std::string::String>,
    pub dst_format: ::std::option::Option<::std::string::String>,
}

impl DataFormatDimMap {
    /// Creates a new `DataFormatDimMap`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// data_format_dim_map with default options.
pub fn data_format_dim_map<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DataFormatDimMap::new();
    data_format_dim_map_with_args(ctx, x, &__args)
}

/// data_format_dim_map with options.
pub fn data_format_dim_map_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &DataFormatDimMap,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DataFormatDimMap")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.src_format {
        op.set_attr_string("src_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dst_format {
        op.set_attr_string("dst_format", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DataFormatVecPermute
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DataFormatVecPermute {
    pub T: ::std::option::Option<crate::DataType>,
    pub src_format: ::std::option::Option<::std::string::String>,
    pub dst_format: ::std::option::Option<::std::string::String>,
}

impl DataFormatVecPermute {
    /// Creates a new `DataFormatVecPermute`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// data_format_vec_permute with default options.
pub fn data_format_vec_permute<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DataFormatVecPermute::new();
    data_format_vec_permute_with_args(ctx, x, &__args)
}

/// data_format_vec_permute with options.
pub fn data_format_vec_permute_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &DataFormatVecPermute,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DataFormatVecPermute")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.src_format {
        op.set_attr_string("src_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dst_format {
        op.set_attr_string("dst_format", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DataServiceDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DataServiceDataset {
    pub task_refresh_interval_hint_ms: ::std::option::Option<i64>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub data_transfer_protocol: ::std::option::Option<::std::string::String>,
    pub target_workers: ::std::option::Option<::std::string::String>,
}

impl DataServiceDataset {
    /// Creates a new `DataServiceDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// data_service_dataset with default options.
pub fn data_service_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    dataset_id: T0,
    processing_mode: T1,
    address: T2,
    protocol: T3,
    job_name: T4,
    max_outstanding_requests: T5,
    iteration_counter: T6,
) -> Result<crate::eager::TensorHandle> {
    let __args = DataServiceDataset::new();
    data_service_dataset_with_args(
        ctx,
        dataset_id,
        processing_mode,
        address,
        protocol,
        job_name,
        max_outstanding_requests,
        iteration_counter,
        &__args,
    )
}

/// data_service_dataset with options.
pub fn data_service_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    dataset_id: T0,
    processing_mode: T1,
    address: T2,
    protocol: T3,
    job_name: T4,
    max_outstanding_requests: T5,
    iteration_counter: T6,
    __args: &DataServiceDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DataServiceDataset")?;

    // Required input arguments
    op.add_input(&dataset_id.to_handle()?)?;
    op.add_input(&processing_mode.to_handle()?)?;
    op.add_input(&address.to_handle()?)?;
    op.add_input(&protocol.to_handle()?)?;
    op.add_input(&job_name.to_handle()?)?;
    op.add_input(&max_outstanding_requests.to_handle()?)?;
    op.add_input(&iteration_counter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.task_refresh_interval_hint_ms {
        op.set_attr_int("task_refresh_interval_hint_ms", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.data_transfer_protocol {
        op.set_attr_string("data_transfer_protocol", value);
    }
    if let ::std::option::Option::Some(value) = &__args.target_workers {
        op.set_attr_string("target_workers", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DataServiceDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DataServiceDatasetV2 {
    pub task_refresh_interval_hint_ms: ::std::option::Option<i64>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub data_transfer_protocol: ::std::option::Option<::std::string::String>,
    pub target_workers: ::std::option::Option<::std::string::String>,
}

impl DataServiceDatasetV2 {
    /// Creates a new `DataServiceDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// data_service_dataset_v2 with default options.
pub fn data_service_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    dataset_id: T0,
    processing_mode: T1,
    address: T2,
    protocol: T3,
    job_name: T4,
    consumer_index: T5,
    num_consumers: T6,
    max_outstanding_requests: T7,
    iteration_counter: T8,
) -> Result<crate::eager::TensorHandle> {
    let __args = DataServiceDatasetV2::new();
    data_service_dataset_v2_with_args(
        ctx,
        dataset_id,
        processing_mode,
        address,
        protocol,
        job_name,
        consumer_index,
        num_consumers,
        max_outstanding_requests,
        iteration_counter,
        &__args,
    )
}

/// data_service_dataset_v2 with options.
pub fn data_service_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    dataset_id: T0,
    processing_mode: T1,
    address: T2,
    protocol: T3,
    job_name: T4,
    consumer_index: T5,
    num_consumers: T6,
    max_outstanding_requests: T7,
    iteration_counter: T8,
    __args: &DataServiceDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DataServiceDatasetV2")?;

    // Required input arguments
    op.add_input(&dataset_id.to_handle()?)?;
    op.add_input(&processing_mode.to_handle()?)?;
    op.add_input(&address.to_handle()?)?;
    op.add_input(&protocol.to_handle()?)?;
    op.add_input(&job_name.to_handle()?)?;
    op.add_input(&consumer_index.to_handle()?)?;
    op.add_input(&num_consumers.to_handle()?)?;
    op.add_input(&max_outstanding_requests.to_handle()?)?;
    op.add_input(&iteration_counter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.task_refresh_interval_hint_ms {
        op.set_attr_int("task_refresh_interval_hint_ms", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.data_transfer_protocol {
        op.set_attr_string("data_transfer_protocol", value);
    }
    if let ::std::option::Option::Some(value) = &__args.target_workers {
        op.set_attr_string("target_workers", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DatasetCardinality
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DatasetCardinality {}

impl DatasetCardinality {
    /// Creates a new `DatasetCardinality`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dataset_cardinality with default options.
pub fn dataset_cardinality<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DatasetCardinality::new();
    dataset_cardinality_with_args(ctx, input_dataset, &__args)
}

/// dataset_cardinality with options.
pub fn dataset_cardinality_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &DatasetCardinality,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DatasetCardinality")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DatasetFromGraph
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DatasetFromGraph {}

impl DatasetFromGraph {
    /// Creates a new `DatasetFromGraph`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dataset_from_graph with default options.
pub fn dataset_from_graph<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    graph_def: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DatasetFromGraph::new();
    dataset_from_graph_with_args(ctx, graph_def, &__args)
}

/// dataset_from_graph with options.
pub fn dataset_from_graph_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    graph_def: T0,
    __args: &DatasetFromGraph,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DatasetFromGraph")?;

    // Required input arguments
    op.add_input(&graph_def.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DatasetToGraph
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DatasetToGraph {
    pub stateful_whitelist: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub allow_stateful: ::std::option::Option<bool>,
    pub strip_device_assignment: ::std::option::Option<bool>,
}

impl DatasetToGraph {
    /// Creates a new `DatasetToGraph`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dataset_to_graph with default options.
pub fn dataset_to_graph<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DatasetToGraph::new();
    dataset_to_graph_with_args(ctx, input_dataset, &__args)
}

/// dataset_to_graph with options.
pub fn dataset_to_graph_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &DatasetToGraph,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DatasetToGraph")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.stateful_whitelist {
        op.set_attr_string_list("stateful_whitelist", value);
    }
    if let ::std::option::Option::Some(value) = &__args.allow_stateful {
        op.set_attr_bool("allow_stateful", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strip_device_assignment {
        op.set_attr_bool("strip_device_assignment", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DatasetToGraphV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DatasetToGraphV2 {
    pub external_state_policy: ::std::option::Option<i64>,
    pub strip_device_assignment: ::std::option::Option<bool>,
}

impl DatasetToGraphV2 {
    /// Creates a new `DatasetToGraphV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dataset_to_graph_v2 with default options.
pub fn dataset_to_graph_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DatasetToGraphV2::new();
    dataset_to_graph_v2_with_args(ctx, input_dataset, &__args)
}

/// dataset_to_graph_v2 with options.
pub fn dataset_to_graph_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &DatasetToGraphV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DatasetToGraphV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.external_state_policy {
        op.set_attr_int("external_state_policy", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strip_device_assignment {
        op.set_attr_bool("strip_device_assignment", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DatasetToSingleElement
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DatasetToSingleElement {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl DatasetToSingleElement {
    /// Creates a new `DatasetToSingleElement`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dataset_to_single_element with default options.
pub fn dataset_to_single_element<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DatasetToSingleElement::new();
    dataset_to_single_element_with_args(ctx, dataset, &__args)
}

/// dataset_to_single_element with options.
pub fn dataset_to_single_element_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    dataset: T0,
    __args: &DatasetToSingleElement,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DatasetToSingleElement")?;

    // Required input arguments
    op.add_input(&dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DatasetToTFRecord
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DatasetToTFRecord {}

impl DatasetToTFRecord {
    /// Creates a new `DatasetToTFRecord`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dataset_to_tfrecord with default options.
pub fn dataset_to_tfrecord<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    filename: T1,
    compression_type: T2,
) -> Result<()> {
    let __args = DatasetToTFRecord::new();
    dataset_to_tfrecord_with_args(ctx, input_dataset, filename, compression_type, &__args)
}

/// dataset_to_tfrecord with options.
pub fn dataset_to_tfrecord_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    filename: T1,
    compression_type: T2,
    __args: &DatasetToTFRecord,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DatasetToTFRecord")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&filename.to_handle()?)?;
    op.add_input(&compression_type.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Dawsn
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Dawsn {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Dawsn {
    /// Creates a new `Dawsn`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dawsn with default options.
pub fn dawsn<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Dawsn::new();
    dawsn_with_args(ctx, x, &__args)
}

/// dawsn with options.
pub fn dawsn_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Dawsn,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Dawsn")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DebugGradientIdentity
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugGradientIdentity {
    pub T: ::std::option::Option<crate::DataType>,
}

impl DebugGradientIdentity {
    /// Creates a new `DebugGradientIdentity`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// debug_gradient_identity with default options.
pub fn debug_gradient_identity<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DebugGradientIdentity::new();
    debug_gradient_identity_with_args(ctx, input, &__args)
}

/// debug_gradient_identity with options.
pub fn debug_gradient_identity_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &DebugGradientIdentity,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DebugGradientIdentity")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DebugGradientRefIdentity
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugGradientRefIdentity {
    pub T: ::std::option::Option<crate::DataType>,
}

impl DebugGradientRefIdentity {
    /// Creates a new `DebugGradientRefIdentity`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// debug_gradient_ref_identity with default options.
pub fn debug_gradient_ref_identity<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DebugGradientRefIdentity::new();
    debug_gradient_ref_identity_with_args(ctx, input, &__args)
}

/// debug_gradient_ref_identity with options.
pub fn debug_gradient_ref_identity_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &DebugGradientRefIdentity,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DebugGradientRefIdentity")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DebugIdentity
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugIdentity {
    pub T: ::std::option::Option<crate::DataType>,
    pub device_name: ::std::option::Option<::std::string::String>,
    pub tensor_name: ::std::option::Option<::std::string::String>,
    pub debug_urls: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub gated_grpc: ::std::option::Option<bool>,
}

impl DebugIdentity {
    /// Creates a new `DebugIdentity`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// debug_identity with default options.
pub fn debug_identity<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DebugIdentity::new();
    debug_identity_with_args(ctx, input, &__args)
}

/// debug_identity with options.
pub fn debug_identity_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &DebugIdentity,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DebugIdentity")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.device_name {
        op.set_attr_string("device_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_name {
        op.set_attr_string("tensor_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.debug_urls {
        op.set_attr_string_list("debug_urls", value);
    }
    if let ::std::option::Option::Some(value) = &__args.gated_grpc {
        op.set_attr_bool("gated_grpc", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DebugIdentityV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugIdentityV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub tfdbg_context_id: ::std::option::Option<::std::string::String>,
    pub op_name: ::std::option::Option<::std::string::String>,
    pub output_slot: ::std::option::Option<i64>,
    pub tensor_debug_mode: ::std::option::Option<i64>,
    pub debug_urls: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub circular_buffer_size: ::std::option::Option<i64>,
    pub tfdbg_run_id: ::std::option::Option<::std::string::String>,
}

impl DebugIdentityV2 {
    /// Creates a new `DebugIdentityV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// debug_identity_v2 with default options.
pub fn debug_identity_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DebugIdentityV2::new();
    debug_identity_v2_with_args(ctx, input, &__args)
}

/// debug_identity_v2 with options.
pub fn debug_identity_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &DebugIdentityV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DebugIdentityV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tfdbg_context_id {
        op.set_attr_string("tfdbg_context_id", value);
    }
    if let ::std::option::Option::Some(value) = &__args.op_name {
        op.set_attr_string("op_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_slot {
        op.set_attr_int("output_slot", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_debug_mode {
        op.set_attr_int("tensor_debug_mode", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.debug_urls {
        op.set_attr_string_list("debug_urls", value);
    }
    if let ::std::option::Option::Some(value) = &__args.circular_buffer_size {
        op.set_attr_int("circular_buffer_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tfdbg_run_id {
        op.set_attr_string("tfdbg_run_id", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DebugNanCount
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugNanCount {
    pub T: ::std::option::Option<crate::DataType>,
    pub device_name: ::std::option::Option<::std::string::String>,
    pub tensor_name: ::std::option::Option<::std::string::String>,
    pub debug_urls: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub gated_grpc: ::std::option::Option<bool>,
}

impl DebugNanCount {
    /// Creates a new `DebugNanCount`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// debug_nan_count with default options.
pub fn debug_nan_count<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DebugNanCount::new();
    debug_nan_count_with_args(ctx, input, &__args)
}

/// debug_nan_count with options.
pub fn debug_nan_count_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &DebugNanCount,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DebugNanCount")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.device_name {
        op.set_attr_string("device_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_name {
        op.set_attr_string("tensor_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.debug_urls {
        op.set_attr_string_list("debug_urls", value);
    }
    if let ::std::option::Option::Some(value) = &__args.gated_grpc {
        op.set_attr_bool("gated_grpc", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DebugNumericSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugNumericSummary {
    pub T: ::std::option::Option<crate::DataType>,
    pub device_name: ::std::option::Option<::std::string::String>,
    pub tensor_name: ::std::option::Option<::std::string::String>,
    pub debug_urls: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub lower_bound: ::std::option::Option<f32>,
    pub upper_bound: ::std::option::Option<f32>,
    pub mute_if_healthy: ::std::option::Option<bool>,
    pub gated_grpc: ::std::option::Option<bool>,
}

impl DebugNumericSummary {
    /// Creates a new `DebugNumericSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// debug_numeric_summary with default options.
pub fn debug_numeric_summary<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DebugNumericSummary::new();
    debug_numeric_summary_with_args(ctx, input, &__args)
}

/// debug_numeric_summary with options.
pub fn debug_numeric_summary_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &DebugNumericSummary,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DebugNumericSummary")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.device_name {
        op.set_attr_string("device_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_name {
        op.set_attr_string("tensor_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.debug_urls {
        op.set_attr_string_list("debug_urls", value);
    }
    if let ::std::option::Option::Some(value) = &__args.lower_bound {
        op.set_attr_float("lower_bound", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.upper_bound {
        op.set_attr_float("upper_bound", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.mute_if_healthy {
        op.set_attr_bool("mute_if_healthy", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.gated_grpc {
        op.set_attr_bool("gated_grpc", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DebugNumericSummaryV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugNumericSummaryV2 {
    pub output_dtype: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub tensor_debug_mode: ::std::option::Option<i64>,
    pub tensor_id: ::std::option::Option<i64>,
}

impl DebugNumericSummaryV2 {
    /// Creates a new `DebugNumericSummaryV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// debug_numeric_summary_v2 with default options.
pub fn debug_numeric_summary_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DebugNumericSummaryV2::new();
    debug_numeric_summary_v2_with_args(ctx, input, &__args)
}

/// debug_numeric_summary_v2 with options.
pub fn debug_numeric_summary_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &DebugNumericSummaryV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DebugNumericSummaryV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_dtype {
        op.set_attr_type("output_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_debug_mode {
        op.set_attr_int("tensor_debug_mode", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_id {
        op.set_attr_int("tensor_id", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodeAndCropJpeg
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeAndCropJpeg {
    pub channels: ::std::option::Option<i64>,
    pub ratio: ::std::option::Option<i64>,
    pub fancy_upscaling: ::std::option::Option<bool>,
    pub try_recover_truncated: ::std::option::Option<bool>,
    pub acceptable_fraction: ::std::option::Option<f32>,
    pub dct_method: ::std::option::Option<::std::string::String>,
}

impl DecodeAndCropJpeg {
    /// Creates a new `DecodeAndCropJpeg`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_and_crop_jpeg with default options.
pub fn decode_and_crop_jpeg<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
    crop_window: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = DecodeAndCropJpeg::new();
    decode_and_crop_jpeg_with_args(ctx, contents, crop_window, &__args)
}

/// decode_and_crop_jpeg with options.
pub fn decode_and_crop_jpeg_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
    crop_window: T1,
    __args: &DecodeAndCropJpeg,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodeAndCropJpeg")?;

    // Required input arguments
    op.add_input(&contents.to_handle()?)?;
    op.add_input(&crop_window.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.channels {
        op.set_attr_int("channels", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ratio {
        op.set_attr_int("ratio", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.fancy_upscaling {
        op.set_attr_bool("fancy_upscaling", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.try_recover_truncated {
        op.set_attr_bool("try_recover_truncated", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.acceptable_fraction {
        op.set_attr_float("acceptable_fraction", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dct_method {
        op.set_attr_string("dct_method", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodeBase64
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeBase64 {}

impl DecodeBase64 {
    /// Creates a new `DecodeBase64`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_base64 with default options.
pub fn decode_base64<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DecodeBase64::new();
    decode_base64_with_args(ctx, input, &__args)
}

/// decode_base64 with options.
pub fn decode_base64_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &DecodeBase64,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodeBase64")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodeBmp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeBmp {
    pub channels: ::std::option::Option<i64>,
}

impl DecodeBmp {
    /// Creates a new `DecodeBmp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_bmp with default options.
pub fn decode_bmp<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DecodeBmp::new();
    decode_bmp_with_args(ctx, contents, &__args)
}

/// decode_bmp with options.
pub fn decode_bmp_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
    __args: &DecodeBmp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodeBmp")?;

    // Required input arguments
    op.add_input(&contents.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.channels {
        op.set_attr_int("channels", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodeCSV
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeCSV {
    pub OUT_TYPE: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub field_delim: ::std::option::Option<::std::string::String>,
    pub use_quote_delim: ::std::option::Option<bool>,
    pub na_value: ::std::option::Option<::std::string::String>,
    pub select_cols: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl DecodeCSV {
    /// Creates a new `DecodeCSV`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_csv with default options.
pub fn decode_csv<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    records: T0,
    record_defaults: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = DecodeCSV::new();
    decode_csv_with_args(ctx, records, record_defaults, &__args)
}

/// decode_csv with options.
pub fn decode_csv_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    records: T0,
    record_defaults: T1,
    __args: &DecodeCSV,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodeCSV")?;

    // Required input arguments
    op.add_input(&records.to_handle()?)?;
    op.add_input(&record_defaults.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.OUT_TYPE {
        op.set_attr_type_list("OUT_TYPE", value);
    }
    if let ::std::option::Option::Some(value) = &__args.field_delim {
        op.set_attr_string("field_delim", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_quote_delim {
        op.set_attr_bool("use_quote_delim", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.na_value {
        op.set_attr_string("na_value", value);
    }
    if let ::std::option::Option::Some(value) = &__args.select_cols {
        op.set_attr_int_list("select_cols", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodeCompressed
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeCompressed {
    pub compression_type: ::std::option::Option<::std::string::String>,
}

impl DecodeCompressed {
    /// Creates a new `DecodeCompressed`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_compressed with default options.
pub fn decode_compressed<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    bytes: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DecodeCompressed::new();
    decode_compressed_with_args(ctx, bytes, &__args)
}

/// decode_compressed with options.
pub fn decode_compressed_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    bytes: T0,
    __args: &DecodeCompressed,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodeCompressed")?;

    // Required input arguments
    op.add_input(&bytes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.compression_type {
        op.set_attr_string("compression_type", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodeGif
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeGif {}

impl DecodeGif {
    /// Creates a new `DecodeGif`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_gif with default options.
pub fn decode_gif<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DecodeGif::new();
    decode_gif_with_args(ctx, contents, &__args)
}

/// decode_gif with options.
pub fn decode_gif_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
    __args: &DecodeGif,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodeGif")?;

    // Required input arguments
    op.add_input(&contents.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodeImage
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeImage {
    pub channels: ::std::option::Option<i64>,
    pub dtype: ::std::option::Option<crate::DataType>,
    pub expand_animations: ::std::option::Option<bool>,
}

impl DecodeImage {
    /// Creates a new `DecodeImage`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_image with default options.
pub fn decode_image<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DecodeImage::new();
    decode_image_with_args(ctx, contents, &__args)
}

/// decode_image with options.
pub fn decode_image_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
    __args: &DecodeImage,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodeImage")?;

    // Required input arguments
    op.add_input(&contents.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.channels {
        op.set_attr_int("channels", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.expand_animations {
        op.set_attr_bool("expand_animations", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodeJSONExample
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeJSONExample {}

impl DecodeJSONExample {
    /// Creates a new `DecodeJSONExample`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_jsonexample with default options.
pub fn decode_jsonexample<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    json_examples: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DecodeJSONExample::new();
    decode_jsonexample_with_args(ctx, json_examples, &__args)
}

/// decode_jsonexample with options.
pub fn decode_jsonexample_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    json_examples: T0,
    __args: &DecodeJSONExample,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodeJSONExample")?;

    // Required input arguments
    op.add_input(&json_examples.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodeJpeg
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeJpeg {
    pub channels: ::std::option::Option<i64>,
    pub ratio: ::std::option::Option<i64>,
    pub fancy_upscaling: ::std::option::Option<bool>,
    pub try_recover_truncated: ::std::option::Option<bool>,
    pub acceptable_fraction: ::std::option::Option<f32>,
    pub dct_method: ::std::option::Option<::std::string::String>,
}

impl DecodeJpeg {
    /// Creates a new `DecodeJpeg`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_jpeg with default options.
pub fn decode_jpeg<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DecodeJpeg::new();
    decode_jpeg_with_args(ctx, contents, &__args)
}

/// decode_jpeg with options.
pub fn decode_jpeg_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
    __args: &DecodeJpeg,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodeJpeg")?;

    // Required input arguments
    op.add_input(&contents.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.channels {
        op.set_attr_int("channels", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ratio {
        op.set_attr_int("ratio", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.fancy_upscaling {
        op.set_attr_bool("fancy_upscaling", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.try_recover_truncated {
        op.set_attr_bool("try_recover_truncated", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.acceptable_fraction {
        op.set_attr_float("acceptable_fraction", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dct_method {
        op.set_attr_string("dct_method", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodePaddedRaw
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodePaddedRaw {
    pub out_type: ::std::option::Option<crate::DataType>,
    pub little_endian: ::std::option::Option<bool>,
}

impl DecodePaddedRaw {
    /// Creates a new `DecodePaddedRaw`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_padded_raw with default options.
pub fn decode_padded_raw<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_bytes: T0,
    fixed_length: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = DecodePaddedRaw::new();
    decode_padded_raw_with_args(ctx, input_bytes, fixed_length, &__args)
}

/// decode_padded_raw with options.
pub fn decode_padded_raw_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_bytes: T0,
    fixed_length: T1,
    __args: &DecodePaddedRaw,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodePaddedRaw")?;

    // Required input arguments
    op.add_input(&input_bytes.to_handle()?)?;
    op.add_input(&fixed_length.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.little_endian {
        op.set_attr_bool("little_endian", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodePng
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodePng {
    pub channels: ::std::option::Option<i64>,
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl DecodePng {
    /// Creates a new `DecodePng`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_png with default options.
pub fn decode_png<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DecodePng::new();
    decode_png_with_args(ctx, contents, &__args)
}

/// decode_png with options.
pub fn decode_png_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
    __args: &DecodePng,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodePng")?;

    // Required input arguments
    op.add_input(&contents.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.channels {
        op.set_attr_int("channels", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodeProtoV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeProtoV2 {
    pub message_type: ::std::option::Option<::std::string::String>,
    pub field_names: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub descriptor_source: ::std::option::Option<::std::string::String>,
    pub message_format: ::std::option::Option<::std::string::String>,
    pub sanitize: ::std::option::Option<bool>,
}

impl DecodeProtoV2 {
    /// Creates a new `DecodeProtoV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_proto_v2 with default options.
pub fn decode_proto_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    bytes: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = DecodeProtoV2::new();
    decode_proto_v2_with_args(ctx, bytes, &__args)
}

/// decode_proto_v2 with options.
pub fn decode_proto_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    bytes: T0,
    __args: &DecodeProtoV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodeProtoV2")?;

    // Required input arguments
    op.add_input(&bytes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.message_type {
        op.set_attr_string("message_type", value);
    }
    if let ::std::option::Option::Some(value) = &__args.field_names {
        op.set_attr_string_list("field_names", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.descriptor_source {
        op.set_attr_string("descriptor_source", value);
    }
    if let ::std::option::Option::Some(value) = &__args.message_format {
        op.set_attr_string("message_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.sanitize {
        op.set_attr_bool("sanitize", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// DecodeRaw
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeRaw {
    pub out_type: ::std::option::Option<crate::DataType>,
    pub little_endian: ::std::option::Option<bool>,
}

impl DecodeRaw {
    /// Creates a new `DecodeRaw`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_raw with default options.
pub fn decode_raw<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    bytes: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DecodeRaw::new();
    decode_raw_with_args(ctx, bytes, &__args)
}

/// decode_raw with options.
pub fn decode_raw_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    bytes: T0,
    __args: &DecodeRaw,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodeRaw")?;

    // Required input arguments
    op.add_input(&bytes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.little_endian {
        op.set_attr_bool("little_endian", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DecodeWav
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeWav {
    pub desired_channels: ::std::option::Option<i64>,
    pub desired_samples: ::std::option::Option<i64>,
}

impl DecodeWav {
    /// Creates a new `DecodeWav`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// decode_wav with default options.
pub fn decode_wav<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = DecodeWav::new();
    decode_wav_with_args(ctx, contents, &__args)
}

/// decode_wav with options.
pub fn decode_wav_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
    __args: &DecodeWav,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DecodeWav")?;

    // Required input arguments
    op.add_input(&contents.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.desired_channels {
        op.set_attr_int("desired_channels", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.desired_samples {
        op.set_attr_int("desired_samples", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// DeepCopy
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeepCopy {
    pub T: ::std::option::Option<crate::DataType>,
}

impl DeepCopy {
    /// Creates a new `DeepCopy`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// deep_copy with default options.
pub fn deep_copy<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DeepCopy::new();
    deep_copy_with_args(ctx, x, &__args)
}

/// deep_copy with options.
pub fn deep_copy_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &DeepCopy,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DeepCopy")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DeleteIterator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeleteIterator {}

impl DeleteIterator {
    /// Creates a new `DeleteIterator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// delete_iterator with default options.
pub fn delete_iterator<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    deleter: T1,
) -> Result<()> {
    let __args = DeleteIterator::new();
    delete_iterator_with_args(ctx, handle, deleter, &__args)
}

/// delete_iterator with options.
pub fn delete_iterator_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    deleter: T1,
    __args: &DeleteIterator,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DeleteIterator")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&deleter.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// DeleteMemoryCache
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeleteMemoryCache {}

impl DeleteMemoryCache {
    /// Creates a new `DeleteMemoryCache`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// delete_memory_cache with default options.
pub fn delete_memory_cache<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    deleter: T1,
) -> Result<()> {
    let __args = DeleteMemoryCache::new();
    delete_memory_cache_with_args(ctx, handle, deleter, &__args)
}

/// delete_memory_cache with options.
pub fn delete_memory_cache_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    deleter: T1,
    __args: &DeleteMemoryCache,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DeleteMemoryCache")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&deleter.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// DeleteMultiDeviceIterator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeleteMultiDeviceIterator {
    pub N: ::std::option::Option<i64>,
}

impl DeleteMultiDeviceIterator {
    /// Creates a new `DeleteMultiDeviceIterator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// delete_multi_device_iterator with default options.
pub fn delete_multi_device_iterator<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    multi_device_iterator: T0,
    iterators: T1,
    deleter: T2,
) -> Result<()> {
    let __args = DeleteMultiDeviceIterator::new();
    delete_multi_device_iterator_with_args(ctx, multi_device_iterator, iterators, deleter, &__args)
}

/// delete_multi_device_iterator with options.
pub fn delete_multi_device_iterator_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    multi_device_iterator: T0,
    iterators: T1,
    deleter: T2,
    __args: &DeleteMultiDeviceIterator,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DeleteMultiDeviceIterator")?;

    // Required input arguments
    op.add_input(&multi_device_iterator.to_handle()?)?;
    op.add_input(&iterators.to_handle()?)?;
    op.add_input(&deleter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// DeleteRandomSeedGenerator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeleteRandomSeedGenerator {}

impl DeleteRandomSeedGenerator {
    /// Creates a new `DeleteRandomSeedGenerator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// delete_random_seed_generator with default options.
pub fn delete_random_seed_generator<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    deleter: T1,
) -> Result<()> {
    let __args = DeleteRandomSeedGenerator::new();
    delete_random_seed_generator_with_args(ctx, handle, deleter, &__args)
}

/// delete_random_seed_generator with options.
pub fn delete_random_seed_generator_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    deleter: T1,
    __args: &DeleteRandomSeedGenerator,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DeleteRandomSeedGenerator")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&deleter.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// DeleteSeedGenerator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeleteSeedGenerator {}

impl DeleteSeedGenerator {
    /// Creates a new `DeleteSeedGenerator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// delete_seed_generator with default options.
pub fn delete_seed_generator<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    deleter: T1,
) -> Result<()> {
    let __args = DeleteSeedGenerator::new();
    delete_seed_generator_with_args(ctx, handle, deleter, &__args)
}

/// delete_seed_generator with options.
pub fn delete_seed_generator_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    deleter: T1,
    __args: &DeleteSeedGenerator,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DeleteSeedGenerator")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&deleter.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// DeleteSessionTensor
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeleteSessionTensor {}

impl DeleteSessionTensor {
    /// Creates a new `DeleteSessionTensor`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// delete_session_tensor with default options.
pub fn delete_session_tensor<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<()> {
    let __args = DeleteSessionTensor::new();
    delete_session_tensor_with_args(ctx, handle, &__args)
}

/// delete_session_tensor with options.
pub fn delete_session_tensor_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &DeleteSessionTensor,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DeleteSessionTensor")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// DenseBincount
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DenseBincount {
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub binary_output: ::std::option::Option<bool>,
}

impl DenseBincount {
    /// Creates a new `DenseBincount`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dense_bincount with default options.
pub fn dense_bincount<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    size: T1,
    weights: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = DenseBincount::new();
    dense_bincount_with_args(ctx, input, size, weights, &__args)
}

/// dense_bincount with options.
pub fn dense_bincount_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    size: T1,
    weights: T2,
    __args: &DenseBincount,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DenseBincount")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;
    op.add_input(&weights.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.binary_output {
        op.set_attr_bool("binary_output", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DenseCountSparseOutput
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DenseCountSparseOutput {
    pub T: ::std::option::Option<crate::DataType>,
    pub minlength: ::std::option::Option<i64>,
    pub maxlength: ::std::option::Option<i64>,
    pub binary_output: ::std::option::Option<bool>,
    pub output_type: ::std::option::Option<crate::DataType>,
}

impl DenseCountSparseOutput {
    /// Creates a new `DenseCountSparseOutput`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dense_count_sparse_output with default options.
pub fn dense_count_sparse_output<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    values: T0,
    weights: T1,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = DenseCountSparseOutput::new();
    dense_count_sparse_output_with_args(ctx, values, weights, &__args)
}

/// dense_count_sparse_output with options.
pub fn dense_count_sparse_output_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    values: T0,
    weights: T1,
    __args: &DenseCountSparseOutput,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DenseCountSparseOutput")?;

    // Required input arguments
    op.add_input(&values.to_handle()?)?;
    op.add_input(&weights.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.minlength {
        op.set_attr_int("minlength", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.maxlength {
        op.set_attr_int("maxlength", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.binary_output {
        op.set_attr_bool("binary_output", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_type {
        op.set_attr_type("output_type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// DenseToCSRSparseMatrix
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DenseToCSRSparseMatrix {
    pub T: ::std::option::Option<crate::DataType>,
}

impl DenseToCSRSparseMatrix {
    /// Creates a new `DenseToCSRSparseMatrix`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dense_to_csrsparse_matrix with default options.
pub fn dense_to_csrsparse_matrix<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    dense_input: T0,
    indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = DenseToCSRSparseMatrix::new();
    dense_to_csrsparse_matrix_with_args(ctx, dense_input, indices, &__args)
}

/// dense_to_csrsparse_matrix with options.
pub fn dense_to_csrsparse_matrix_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    dense_input: T0,
    indices: T1,
    __args: &DenseToCSRSparseMatrix,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DenseToCSRSparseMatrix")?;

    // Required input arguments
    op.add_input(&dense_input.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DenseToDenseSetOperation
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DenseToDenseSetOperation {
    pub set_operation: ::std::option::Option<::std::string::String>,
    pub validate_indices: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl DenseToDenseSetOperation {
    /// Creates a new `DenseToDenseSetOperation`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dense_to_dense_set_operation with default options.
pub fn dense_to_dense_set_operation<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    set1: T0,
    set2: T1,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = DenseToDenseSetOperation::new();
    dense_to_dense_set_operation_with_args(ctx, set1, set2, &__args)
}

/// dense_to_dense_set_operation with options.
pub fn dense_to_dense_set_operation_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    set1: T0,
    set2: T1,
    __args: &DenseToDenseSetOperation,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DenseToDenseSetOperation")?;

    // Required input arguments
    op.add_input(&set1.to_handle()?)?;
    op.add_input(&set2.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.set_operation {
        op.set_attr_string("set_operation", value);
    }
    if let ::std::option::Option::Some(value) = &__args.validate_indices {
        op.set_attr_bool("validate_indices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// DenseToSparseBatchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DenseToSparseBatchDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl DenseToSparseBatchDataset {
    /// Creates a new `DenseToSparseBatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dense_to_sparse_batch_dataset with default options.
pub fn dense_to_sparse_batch_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    row_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = DenseToSparseBatchDataset::new();
    dense_to_sparse_batch_dataset_with_args(ctx, input_dataset, batch_size, row_shape, &__args)
}

/// dense_to_sparse_batch_dataset with options.
pub fn dense_to_sparse_batch_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    row_shape: T2,
    __args: &DenseToSparseBatchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DenseToSparseBatchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&batch_size.to_handle()?)?;
    op.add_input(&row_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DenseToSparseSetOperation
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DenseToSparseSetOperation {
    pub set_operation: ::std::option::Option<::std::string::String>,
    pub validate_indices: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl DenseToSparseSetOperation {
    /// Creates a new `DenseToSparseSetOperation`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dense_to_sparse_set_operation with default options.
pub fn dense_to_sparse_set_operation<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    set1: T0,
    set2_indices: T1,
    set2_values: T2,
    set2_shape: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = DenseToSparseSetOperation::new();
    dense_to_sparse_set_operation_with_args(
        ctx,
        set1,
        set2_indices,
        set2_values,
        set2_shape,
        &__args,
    )
}

/// dense_to_sparse_set_operation with options.
pub fn dense_to_sparse_set_operation_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    set1: T0,
    set2_indices: T1,
    set2_values: T2,
    set2_shape: T3,
    __args: &DenseToSparseSetOperation,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DenseToSparseSetOperation")?;

    // Required input arguments
    op.add_input(&set1.to_handle()?)?;
    op.add_input(&set2_indices.to_handle()?)?;
    op.add_input(&set2_values.to_handle()?)?;
    op.add_input(&set2_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.set_operation {
        op.set_attr_string("set_operation", value);
    }
    if let ::std::option::Option::Some(value) = &__args.validate_indices {
        op.set_attr_bool("validate_indices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// DepthToSpace
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DepthToSpace {
    pub T: ::std::option::Option<crate::DataType>,
    pub block_size: ::std::option::Option<i64>,
    pub data_format: ::std::option::Option<::std::string::String>,
}

impl DepthToSpace {
    /// Creates a new `DepthToSpace`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// depth_to_space with default options.
pub fn depth_to_space<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DepthToSpace::new();
    depth_to_space_with_args(ctx, input, &__args)
}

/// depth_to_space with options.
pub fn depth_to_space_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &DepthToSpace,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DepthToSpace")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.block_size {
        op.set_attr_int("block_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DepthwiseConv2dNative
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DepthwiseConv2dNative {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl DepthwiseConv2dNative {
    /// Creates a new `DepthwiseConv2dNative`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// depthwise_conv2d_native with default options.
pub fn depthwise_conv2d_native<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = DepthwiseConv2dNative::new();
    depthwise_conv2d_native_with_args(ctx, input, filter, &__args)
}

/// depthwise_conv2d_native with options.
pub fn depthwise_conv2d_native_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    __args: &DepthwiseConv2dNative,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DepthwiseConv2dNative")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.explicit_paddings {
        op.set_attr_int_list("explicit_paddings", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DepthwiseConv2dNativeBackpropFilter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DepthwiseConv2dNativeBackpropFilter {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl DepthwiseConv2dNativeBackpropFilter {
    /// Creates a new `DepthwiseConv2dNativeBackpropFilter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// depthwise_conv2d_native_backprop_filter with default options.
pub fn depthwise_conv2d_native_backprop_filter<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter_sizes: T1,
    out_backprop: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = DepthwiseConv2dNativeBackpropFilter::new();
    depthwise_conv2d_native_backprop_filter_with_args(
        ctx,
        input,
        filter_sizes,
        out_backprop,
        &__args,
    )
}

/// depthwise_conv2d_native_backprop_filter with options.
pub fn depthwise_conv2d_native_backprop_filter_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter_sizes: T1,
    out_backprop: T2,
    __args: &DepthwiseConv2dNativeBackpropFilter,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DepthwiseConv2dNativeBackpropFilter")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter_sizes.to_handle()?)?;
    op.add_input(&out_backprop.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.explicit_paddings {
        op.set_attr_int_list("explicit_paddings", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DepthwiseConv2dNativeBackpropInput
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DepthwiseConv2dNativeBackpropInput {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl DepthwiseConv2dNativeBackpropInput {
    /// Creates a new `DepthwiseConv2dNativeBackpropInput`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// depthwise_conv2d_native_backprop_input with default options.
pub fn depthwise_conv2d_native_backprop_input<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_sizes: T0,
    filter: T1,
    out_backprop: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = DepthwiseConv2dNativeBackpropInput::new();
    depthwise_conv2d_native_backprop_input_with_args(
        ctx,
        input_sizes,
        filter,
        out_backprop,
        &__args,
    )
}

/// depthwise_conv2d_native_backprop_input with options.
pub fn depthwise_conv2d_native_backprop_input_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_sizes: T0,
    filter: T1,
    out_backprop: T2,
    __args: &DepthwiseConv2dNativeBackpropInput,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DepthwiseConv2dNativeBackpropInput")?;

    // Required input arguments
    op.add_input(&input_sizes.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&out_backprop.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.explicit_paddings {
        op.set_attr_int_list("explicit_paddings", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Dequantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Dequantize {
    pub T: ::std::option::Option<crate::DataType>,
    pub mode: ::std::option::Option<::std::string::String>,
    pub narrow_range: ::std::option::Option<bool>,
    pub axis: ::std::option::Option<i64>,
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl Dequantize {
    /// Creates a new `Dequantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dequantize with default options.
pub fn dequantize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    min_range: T1,
    max_range: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Dequantize::new();
    dequantize_with_args(ctx, input, min_range, max_range, &__args)
}

/// dequantize with options.
pub fn dequantize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    min_range: T1,
    max_range: T2,
    __args: &Dequantize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Dequantize")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&min_range.to_handle()?)?;
    op.add_input(&max_range.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.mode {
        op.set_attr_string("mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.narrow_range {
        op.set_attr_bool("narrow_range", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.axis {
        op.set_attr_int("axis", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DeserializeIterator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeserializeIterator {}

impl DeserializeIterator {
    /// Creates a new `DeserializeIterator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// deserialize_iterator with default options.
pub fn deserialize_iterator<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource_handle: T0,
    serialized: T1,
) -> Result<()> {
    let __args = DeserializeIterator::new();
    deserialize_iterator_with_args(ctx, resource_handle, serialized, &__args)
}

/// deserialize_iterator with options.
pub fn deserialize_iterator_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource_handle: T0,
    serialized: T1,
    __args: &DeserializeIterator,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DeserializeIterator")?;

    // Required input arguments
    op.add_input(&resource_handle.to_handle()?)?;
    op.add_input(&serialized.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// DeserializeManySparse
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeserializeManySparse {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl DeserializeManySparse {
    /// Creates a new `DeserializeManySparse`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// deserialize_many_sparse with default options.
pub fn deserialize_many_sparse<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    serialized_sparse: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = DeserializeManySparse::new();
    deserialize_many_sparse_with_args(ctx, serialized_sparse, &__args)
}

/// deserialize_many_sparse with options.
pub fn deserialize_many_sparse_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    serialized_sparse: T0,
    __args: &DeserializeManySparse,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DeserializeManySparse")?;

    // Required input arguments
    op.add_input(&serialized_sparse.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// DeserializeSparse
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeserializeSparse {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tserialized: ::std::option::Option<crate::DataType>,
}

impl DeserializeSparse {
    /// Creates a new `DeserializeSparse`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// deserialize_sparse with default options.
pub fn deserialize_sparse<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    serialized_sparse: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = DeserializeSparse::new();
    deserialize_sparse_with_args(ctx, serialized_sparse, &__args)
}

/// deserialize_sparse with options.
pub fn deserialize_sparse_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    serialized_sparse: T0,
    __args: &DeserializeSparse,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DeserializeSparse")?;

    // Required input arguments
    op.add_input(&serialized_sparse.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tserialized {
        op.set_attr_type("Tserialized", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// DestroyResourceOp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DestroyResourceOp {
    pub ignore_lookup_error: ::std::option::Option<bool>,
}

impl DestroyResourceOp {
    /// Creates a new `DestroyResourceOp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// destroy_resource_op with default options.
pub fn destroy_resource_op<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
) -> Result<()> {
    let __args = DestroyResourceOp::new();
    destroy_resource_op_with_args(ctx, resource, &__args)
}

/// destroy_resource_op with options.
pub fn destroy_resource_op_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    __args: &DestroyResourceOp,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DestroyResourceOp")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ignore_lookup_error {
        op.set_attr_bool("ignore_lookup_error", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// DestroyTemporaryVariable
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DestroyTemporaryVariable {
    pub T: ::std::option::Option<crate::DataType>,
    pub var_name: ::std::option::Option<::std::string::String>,
}

impl DestroyTemporaryVariable {
    /// Creates a new `DestroyTemporaryVariable`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// destroy_temporary_variable with default options.
pub fn destroy_temporary_variable<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    ref_: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DestroyTemporaryVariable::new();
    destroy_temporary_variable_with_args(ctx, ref_, &__args)
}

/// destroy_temporary_variable with options.
pub fn destroy_temporary_variable_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    ref_: T0,
    __args: &DestroyTemporaryVariable,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DestroyTemporaryVariable")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.var_name {
        op.set_attr_string("var_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DeviceIndex
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeviceIndex {
    pub device_names: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}

impl DeviceIndex {
    /// Creates a new `DeviceIndex`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// device_index with default options.
pub fn device_index(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = DeviceIndex::new();
    device_index_with_args(ctx, &__args)
}

/// device_index with options.
pub fn device_index_with_args(
    ctx: &crate::eager::Context,
    __args: &DeviceIndex,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DeviceIndex")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.device_names {
        op.set_attr_string_list("device_names", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Diag
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Diag {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Diag {
    /// Creates a new `Diag`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// diag with default options.
pub fn diag<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    diagonal: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Diag::new();
    diag_with_args(ctx, diagonal, &__args)
}

/// diag with options.
pub fn diag_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    diagonal: T0,
    __args: &Diag,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Diag")?;

    // Required input arguments
    op.add_input(&diagonal.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DiagPart
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DiagPart {
    pub T: ::std::option::Option<crate::DataType>,
}

impl DiagPart {
    /// Creates a new `DiagPart`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// diag_part with default options.
pub fn diag_part<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = DiagPart::new();
    diag_part_with_args(ctx, input, &__args)
}

/// diag_part with options.
pub fn diag_part_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &DiagPart,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DiagPart")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Digamma
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Digamma {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Digamma {
    /// Creates a new `Digamma`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// digamma with default options.
pub fn digamma<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Digamma::new();
    digamma_with_args(ctx, x, &__args)
}

/// digamma with options.
pub fn digamma_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Digamma,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Digamma")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Dilation2D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Dilation2D {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub rates: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
}

impl Dilation2D {
    /// Creates a new `Dilation2D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dilation2_d with default options.
pub fn dilation2_d<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Dilation2D::new();
    dilation2_d_with_args(ctx, input, filter, &__args)
}

/// dilation2_d with options.
pub fn dilation2_d_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    __args: &Dilation2D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Dilation2D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.rates {
        op.set_attr_int_list("rates", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Dilation2DBackpropFilter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Dilation2DBackpropFilter {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub rates: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
}

impl Dilation2DBackpropFilter {
    /// Creates a new `Dilation2DBackpropFilter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dilation2_dbackprop_filter with default options.
pub fn dilation2_dbackprop_filter<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    out_backprop: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Dilation2DBackpropFilter::new();
    dilation2_dbackprop_filter_with_args(ctx, input, filter, out_backprop, &__args)
}

/// dilation2_dbackprop_filter with options.
pub fn dilation2_dbackprop_filter_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    out_backprop: T2,
    __args: &Dilation2DBackpropFilter,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Dilation2DBackpropFilter")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&out_backprop.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.rates {
        op.set_attr_int_list("rates", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Dilation2DBackpropInput
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Dilation2DBackpropInput {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub rates: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
}

impl Dilation2DBackpropInput {
    /// Creates a new `Dilation2DBackpropInput`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dilation2_dbackprop_input with default options.
pub fn dilation2_dbackprop_input<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    out_backprop: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Dilation2DBackpropInput::new();
    dilation2_dbackprop_input_with_args(ctx, input, filter, out_backprop, &__args)
}

/// dilation2_dbackprop_input with options.
pub fn dilation2_dbackprop_input_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    out_backprop: T2,
    __args: &Dilation2DBackpropInput,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Dilation2DBackpropInput")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&out_backprop.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.rates {
        op.set_attr_int_list("rates", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DirectedInterleaveDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DirectedInterleaveDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub N: ::std::option::Option<i64>,
    pub stop_on_empty_dataset: ::std::option::Option<bool>,
}

impl DirectedInterleaveDataset {
    /// Creates a new `DirectedInterleaveDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// directed_interleave_dataset with default options.
pub fn directed_interleave_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    selector_input_dataset: T0,
    data_input_datasets: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = DirectedInterleaveDataset::new();
    directed_interleave_dataset_with_args(ctx, selector_input_dataset, data_input_datasets, &__args)
}

/// directed_interleave_dataset with options.
pub fn directed_interleave_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    selector_input_dataset: T0,
    data_input_datasets: T1,
    __args: &DirectedInterleaveDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DirectedInterleaveDataset")?;

    // Required input arguments
    op.add_input(&selector_input_dataset.to_handle()?)?;
    op.add_input(&data_input_datasets.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.stop_on_empty_dataset {
        op.set_attr_bool("stop_on_empty_dataset", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Div
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Div {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Div {
    /// Creates a new `Div`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// div with default options.
pub fn div<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Div::new();
    div_with_args(ctx, x, y, &__args)
}

/// div with options.
pub fn div_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Div,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Div")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DivNoNan
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DivNoNan {
    pub T: ::std::option::Option<crate::DataType>,
}

impl DivNoNan {
    /// Creates a new `DivNoNan`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// div_no_nan with default options.
pub fn div_no_nan<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = DivNoNan::new();
    div_no_nan_with_args(ctx, x, y, &__args)
}

/// div_no_nan with options.
pub fn div_no_nan_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &DivNoNan,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DivNoNan")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DrawBoundingBoxes
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DrawBoundingBoxes {
    pub T: ::std::option::Option<crate::DataType>,
}

impl DrawBoundingBoxes {
    /// Creates a new `DrawBoundingBoxes`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// draw_bounding_boxes with default options.
pub fn draw_bounding_boxes<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    boxes: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = DrawBoundingBoxes::new();
    draw_bounding_boxes_with_args(ctx, images, boxes, &__args)
}

/// draw_bounding_boxes with options.
pub fn draw_bounding_boxes_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    boxes: T1,
    __args: &DrawBoundingBoxes,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DrawBoundingBoxes")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&boxes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DrawBoundingBoxesV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DrawBoundingBoxesV2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl DrawBoundingBoxesV2 {
    /// Creates a new `DrawBoundingBoxesV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// draw_bounding_boxes_v2 with default options.
pub fn draw_bounding_boxes_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    boxes: T1,
    colors: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = DrawBoundingBoxesV2::new();
    draw_bounding_boxes_v2_with_args(ctx, images, boxes, colors, &__args)
}

/// draw_bounding_boxes_v2 with options.
pub fn draw_bounding_boxes_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    boxes: T1,
    colors: T2,
    __args: &DrawBoundingBoxesV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DrawBoundingBoxesV2")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&boxes.to_handle()?)?;
    op.add_input(&colors.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DummyIterationCounter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DummyIterationCounter {}

impl DummyIterationCounter {
    /// Creates a new `DummyIterationCounter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dummy_iteration_counter with default options.
pub fn dummy_iteration_counter(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = DummyIterationCounter::new();
    dummy_iteration_counter_with_args(ctx, &__args)
}

/// dummy_iteration_counter with options.
pub fn dummy_iteration_counter_with_args(
    ctx: &crate::eager::Context,
    __args: &DummyIterationCounter,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DummyIterationCounter")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DummyMemoryCache
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DummyMemoryCache {}

impl DummyMemoryCache {
    /// Creates a new `DummyMemoryCache`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dummy_memory_cache with default options.
pub fn dummy_memory_cache(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = DummyMemoryCache::new();
    dummy_memory_cache_with_args(ctx, &__args)
}

/// dummy_memory_cache with options.
pub fn dummy_memory_cache_with_args(
    ctx: &crate::eager::Context,
    __args: &DummyMemoryCache,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DummyMemoryCache")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DummySeedGenerator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DummySeedGenerator {}

impl DummySeedGenerator {
    /// Creates a new `DummySeedGenerator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dummy_seed_generator with default options.
pub fn dummy_seed_generator(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = DummySeedGenerator::new();
    dummy_seed_generator_with_args(ctx, &__args)
}

/// dummy_seed_generator with options.
pub fn dummy_seed_generator_with_args(
    ctx: &crate::eager::Context,
    __args: &DummySeedGenerator,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DummySeedGenerator")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DynamicPartition
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DynamicPartition {
    pub num_partitions: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl DynamicPartition {
    /// Creates a new `DynamicPartition`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dynamic_partition with default options.
pub fn dynamic_partition<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    partitions: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = DynamicPartition::new();
    dynamic_partition_with_args(ctx, data, partitions, &__args)
}

/// dynamic_partition with options.
pub fn dynamic_partition_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    partitions: T1,
    __args: &DynamicPartition,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DynamicPartition")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&partitions.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_partitions {
        op.set_attr_int("num_partitions", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// DynamicStitch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DynamicStitch {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl DynamicStitch {
    /// Creates a new `DynamicStitch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// dynamic_stitch with default options.
pub fn dynamic_stitch<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    indices: T0,
    data: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = DynamicStitch::new();
    dynamic_stitch_with_args(ctx, indices, data, &__args)
}

/// dynamic_stitch with options.
pub fn dynamic_stitch_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    indices: T0,
    data: T1,
    __args: &DynamicStitch,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "DynamicStitch")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EagerPyFunc
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EagerPyFunc {
    pub token: ::std::option::Option<::std::string::String>,
    pub is_async: ::std::option::Option<bool>,
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl EagerPyFunc {
    /// Creates a new `EagerPyFunc`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// eager_py_func with default options.
pub fn eager_py_func<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = EagerPyFunc::new();
    eager_py_func_with_args(ctx, input, &__args)
}

/// eager_py_func with options.
pub fn eager_py_func_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &EagerPyFunc,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EagerPyFunc")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.token {
        op.set_attr_string("token", value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_async {
        op.set_attr_bool("is_async", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EditDistance
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EditDistance {
    pub normalize: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl EditDistance {
    /// Creates a new `EditDistance`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// edit_distance with default options.
pub fn edit_distance<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    hypothesis_indices: T0,
    hypothesis_values: T1,
    hypothesis_shape: T2,
    truth_indices: T3,
    truth_values: T4,
    truth_shape: T5,
) -> Result<crate::eager::TensorHandle> {
    let __args = EditDistance::new();
    edit_distance_with_args(
        ctx,
        hypothesis_indices,
        hypothesis_values,
        hypothesis_shape,
        truth_indices,
        truth_values,
        truth_shape,
        &__args,
    )
}

/// edit_distance with options.
pub fn edit_distance_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    hypothesis_indices: T0,
    hypothesis_values: T1,
    hypothesis_shape: T2,
    truth_indices: T3,
    truth_values: T4,
    truth_shape: T5,
    __args: &EditDistance,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EditDistance")?;

    // Required input arguments
    op.add_input(&hypothesis_indices.to_handle()?)?;
    op.add_input(&hypothesis_values.to_handle()?)?;
    op.add_input(&hypothesis_shape.to_handle()?)?;
    op.add_input(&truth_indices.to_handle()?)?;
    op.add_input(&truth_values.to_handle()?)?;
    op.add_input(&truth_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.normalize {
        op.set_attr_bool("normalize", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Eig
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Eig {
    pub compute_v: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl Eig {
    /// Creates a new `Eig`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// eig with default options.
pub fn eig<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = Eig::new();
    eig_with_args(ctx, input, &__args)
}

/// eig with options.
pub fn eig_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Eig,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Eig")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.compute_v {
        op.set_attr_bool("compute_v", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Einsum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Einsum {
    pub equation: ::std::option::Option<::std::string::String>,
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl Einsum {
    /// Creates a new `Einsum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// einsum with default options.
pub fn einsum<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Einsum::new();
    einsum_with_args(ctx, inputs, &__args)
}

/// einsum with options.
pub fn einsum_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &Einsum,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Einsum")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.equation {
        op.set_attr_string("equation", value);
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Elu
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Elu {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Elu {
    /// Creates a new `Elu`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// elu with default options.
pub fn elu<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Elu::new();
    elu_with_args(ctx, features, &__args)
}

/// elu with options.
pub fn elu_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
    __args: &Elu,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Elu")?;

    // Required input arguments
    op.add_input(&features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EluGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EluGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl EluGrad {
    /// Creates a new `EluGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// elu_grad with default options.
pub fn elu_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    outputs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = EluGrad::new();
    elu_grad_with_args(ctx, gradients, outputs, &__args)
}

/// elu_grad with options.
pub fn elu_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    outputs: T1,
    __args: &EluGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EluGrad")?;

    // Required input arguments
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&outputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Empty
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Empty {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub init: ::std::option::Option<bool>,
}

impl Empty {
    /// Creates a new `Empty`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// empty with default options.
pub fn empty<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Empty::new();
    empty_with_args(ctx, shape, &__args)
}

/// empty with options.
pub fn empty_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    __args: &Empty,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Empty")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.init {
        op.set_attr_bool("init", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EmptyTensorList
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EmptyTensorList {
    pub element_dtype: ::std::option::Option<crate::DataType>,
    pub shape_type: ::std::option::Option<crate::DataType>,
}

impl EmptyTensorList {
    /// Creates a new `EmptyTensorList`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// empty_tensor_list with default options.
pub fn empty_tensor_list<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    element_shape: T0,
    max_num_elements: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = EmptyTensorList::new();
    empty_tensor_list_with_args(ctx, element_shape, max_num_elements, &__args)
}

/// empty_tensor_list with options.
pub fn empty_tensor_list_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    element_shape: T0,
    max_num_elements: T1,
    __args: &EmptyTensorList,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EmptyTensorList")?;

    // Required input arguments
    op.add_input(&element_shape.to_handle()?)?;
    op.add_input(&max_num_elements.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_type {
        op.set_attr_type("shape_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EmptyTensorMap
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EmptyTensorMap {}

impl EmptyTensorMap {
    /// Creates a new `EmptyTensorMap`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// empty_tensor_map with default options.
pub fn empty_tensor_map(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = EmptyTensorMap::new();
    empty_tensor_map_with_args(ctx, &__args)
}

/// empty_tensor_map with options.
pub fn empty_tensor_map_with_args(
    ctx: &crate::eager::Context,
    __args: &EmptyTensorMap,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EmptyTensorMap")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EncodeBase64
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EncodeBase64 {
    pub pad: ::std::option::Option<bool>,
}

impl EncodeBase64 {
    /// Creates a new `EncodeBase64`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// encode_base64 with default options.
pub fn encode_base64<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = EncodeBase64::new();
    encode_base64_with_args(ctx, input, &__args)
}

/// encode_base64 with options.
pub fn encode_base64_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &EncodeBase64,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EncodeBase64")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.pad {
        op.set_attr_bool("pad", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EncodeJpeg
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EncodeJpeg {
    pub format: ::std::option::Option<::std::string::String>,
    pub quality: ::std::option::Option<i64>,
    pub progressive: ::std::option::Option<bool>,
    pub optimize_size: ::std::option::Option<bool>,
    pub chroma_downsampling: ::std::option::Option<bool>,
    pub density_unit: ::std::option::Option<::std::string::String>,
    pub x_density: ::std::option::Option<i64>,
    pub y_density: ::std::option::Option<i64>,
    pub xmp_metadata: ::std::option::Option<::std::string::String>,
}

impl EncodeJpeg {
    /// Creates a new `EncodeJpeg`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// encode_jpeg with default options.
pub fn encode_jpeg<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    image: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = EncodeJpeg::new();
    encode_jpeg_with_args(ctx, image, &__args)
}

/// encode_jpeg with options.
pub fn encode_jpeg_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    image: T0,
    __args: &EncodeJpeg,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EncodeJpeg")?;

    // Required input arguments
    op.add_input(&image.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.format {
        op.set_attr_string("format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.quality {
        op.set_attr_int("quality", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.progressive {
        op.set_attr_bool("progressive", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.optimize_size {
        op.set_attr_bool("optimize_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.chroma_downsampling {
        op.set_attr_bool("chroma_downsampling", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.density_unit {
        op.set_attr_string("density_unit", value);
    }
    if let ::std::option::Option::Some(value) = &__args.x_density {
        op.set_attr_int("x_density", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.y_density {
        op.set_attr_int("y_density", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.xmp_metadata {
        op.set_attr_string("xmp_metadata", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EncodeJpegVariableQuality
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EncodeJpegVariableQuality {}

impl EncodeJpegVariableQuality {
    /// Creates a new `EncodeJpegVariableQuality`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// encode_jpeg_variable_quality with default options.
pub fn encode_jpeg_variable_quality<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    quality: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = EncodeJpegVariableQuality::new();
    encode_jpeg_variable_quality_with_args(ctx, images, quality, &__args)
}

/// encode_jpeg_variable_quality with options.
pub fn encode_jpeg_variable_quality_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    quality: T1,
    __args: &EncodeJpegVariableQuality,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EncodeJpegVariableQuality")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&quality.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EncodePng
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EncodePng {
    pub compression: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl EncodePng {
    /// Creates a new `EncodePng`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// encode_png with default options.
pub fn encode_png<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    image: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = EncodePng::new();
    encode_png_with_args(ctx, image, &__args)
}

/// encode_png with options.
pub fn encode_png_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    image: T0,
    __args: &EncodePng,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EncodePng")?;

    // Required input arguments
    op.add_input(&image.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.compression {
        op.set_attr_int("compression", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EncodeProto
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EncodeProto {
    pub field_names: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub message_type: ::std::option::Option<::std::string::String>,
    pub descriptor_source: ::std::option::Option<::std::string::String>,
    pub Tinput_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl EncodeProto {
    /// Creates a new `EncodeProto`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// encode_proto with default options.
pub fn encode_proto<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sizes: T0,
    values: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = EncodeProto::new();
    encode_proto_with_args(ctx, sizes, values, &__args)
}

/// encode_proto with options.
pub fn encode_proto_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sizes: T0,
    values: T1,
    __args: &EncodeProto,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EncodeProto")?;

    // Required input arguments
    op.add_input(&sizes.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.field_names {
        op.set_attr_string_list("field_names", value);
    }
    if let ::std::option::Option::Some(value) = &__args.message_type {
        op.set_attr_string("message_type", value);
    }
    if let ::std::option::Option::Some(value) = &__args.descriptor_source {
        op.set_attr_string("descriptor_source", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tinput_types {
        op.set_attr_type_list("Tinput_types", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EncodeWav
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EncodeWav {}

impl EncodeWav {
    /// Creates a new `EncodeWav`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// encode_wav with default options.
pub fn encode_wav<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    audio: T0,
    sample_rate: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = EncodeWav::new();
    encode_wav_with_args(ctx, audio, sample_rate, &__args)
}

/// encode_wav with options.
pub fn encode_wav_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    audio: T0,
    sample_rate: T1,
    __args: &EncodeWav,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EncodeWav")?;

    // Required input arguments
    op.add_input(&audio.to_handle()?)?;
    op.add_input(&sample_rate.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EnqueueTPUEmbeddingIntegerBatch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EnqueueTPUEmbeddingIntegerBatch {
    pub N: ::std::option::Option<i64>,
    pub device_ordinal: ::std::option::Option<i64>,
}

impl EnqueueTPUEmbeddingIntegerBatch {
    /// Creates a new `EnqueueTPUEmbeddingIntegerBatch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// enqueue_tpuembedding_integer_batch with default options.
pub fn enqueue_tpuembedding_integer_batch<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    batch: T0,
    mode_override: T1,
) -> Result<()> {
    let __args = EnqueueTPUEmbeddingIntegerBatch::new();
    enqueue_tpuembedding_integer_batch_with_args(ctx, batch, mode_override, &__args)
}

/// enqueue_tpuembedding_integer_batch with options.
pub fn enqueue_tpuembedding_integer_batch_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    batch: T0,
    mode_override: T1,
    __args: &EnqueueTPUEmbeddingIntegerBatch,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EnqueueTPUEmbeddingIntegerBatch")?;

    // Required input arguments
    op.add_input(&batch.to_handle()?)?;
    op.add_input(&mode_override.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.device_ordinal {
        op.set_attr_int("device_ordinal", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// EnqueueTPUEmbeddingRaggedTensorBatch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EnqueueTPUEmbeddingRaggedTensorBatch {
    pub T1: ::std::option::Option<crate::DataType>,
    pub T2: ::std::option::Option<crate::DataType>,
    pub T3: ::std::option::Option<crate::DataType>,
    pub N: ::std::option::Option<i64>,
    pub device_ordinal: ::std::option::Option<i64>,
    pub combiners: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub table_ids: ::std::option::Option<::std::vec::Vec<i64>>,
    pub max_sequence_lengths: ::std::option::Option<::std::vec::Vec<i64>>,
    pub num_features: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl EnqueueTPUEmbeddingRaggedTensorBatch {
    /// Creates a new `EnqueueTPUEmbeddingRaggedTensorBatch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// enqueue_tpuembedding_ragged_tensor_batch with default options.
pub fn enqueue_tpuembedding_ragged_tensor_batch<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sample_splits: T0,
    embedding_indices: T1,
    aggregation_weights: T2,
    mode_override: T3,
) -> Result<()> {
    let __args = EnqueueTPUEmbeddingRaggedTensorBatch::new();
    enqueue_tpuembedding_ragged_tensor_batch_with_args(
        ctx,
        sample_splits,
        embedding_indices,
        aggregation_weights,
        mode_override,
        &__args,
    )
}

/// enqueue_tpuembedding_ragged_tensor_batch with options.
pub fn enqueue_tpuembedding_ragged_tensor_batch_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sample_splits: T0,
    embedding_indices: T1,
    aggregation_weights: T2,
    mode_override: T3,
    __args: &EnqueueTPUEmbeddingRaggedTensorBatch,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EnqueueTPUEmbeddingRaggedTensorBatch")?;

    // Required input arguments
    op.add_input(&sample_splits.to_handle()?)?;
    op.add_input(&embedding_indices.to_handle()?)?;
    op.add_input(&aggregation_weights.to_handle()?)?;
    op.add_input(&mode_override.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T1 {
        op.set_attr_type("T1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T2 {
        op.set_attr_type("T2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T3 {
        op.set_attr_type("T3", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.device_ordinal {
        op.set_attr_int("device_ordinal", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.combiners {
        op.set_attr_string_list("combiners", value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_ids {
        op.set_attr_int_list("table_ids", value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_sequence_lengths {
        op.set_attr_int_list("max_sequence_lengths", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int_list("num_features", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// EnqueueTPUEmbeddingSparseBatch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EnqueueTPUEmbeddingSparseBatch {
    pub T1: ::std::option::Option<crate::DataType>,
    pub T2: ::std::option::Option<crate::DataType>,
    pub T3: ::std::option::Option<crate::DataType>,
    pub N: ::std::option::Option<i64>,
    pub device_ordinal: ::std::option::Option<i64>,
    pub combiners: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}

impl EnqueueTPUEmbeddingSparseBatch {
    /// Creates a new `EnqueueTPUEmbeddingSparseBatch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// enqueue_tpuembedding_sparse_batch with default options.
pub fn enqueue_tpuembedding_sparse_batch<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sample_indices: T0,
    embedding_indices: T1,
    aggregation_weights: T2,
    mode_override: T3,
) -> Result<()> {
    let __args = EnqueueTPUEmbeddingSparseBatch::new();
    enqueue_tpuembedding_sparse_batch_with_args(
        ctx,
        sample_indices,
        embedding_indices,
        aggregation_weights,
        mode_override,
        &__args,
    )
}

/// enqueue_tpuembedding_sparse_batch with options.
pub fn enqueue_tpuembedding_sparse_batch_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sample_indices: T0,
    embedding_indices: T1,
    aggregation_weights: T2,
    mode_override: T3,
    __args: &EnqueueTPUEmbeddingSparseBatch,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EnqueueTPUEmbeddingSparseBatch")?;

    // Required input arguments
    op.add_input(&sample_indices.to_handle()?)?;
    op.add_input(&embedding_indices.to_handle()?)?;
    op.add_input(&aggregation_weights.to_handle()?)?;
    op.add_input(&mode_override.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T1 {
        op.set_attr_type("T1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T2 {
        op.set_attr_type("T2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T3 {
        op.set_attr_type("T3", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.device_ordinal {
        op.set_attr_int("device_ordinal", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.combiners {
        op.set_attr_string_list("combiners", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// EnqueueTPUEmbeddingSparseTensorBatch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EnqueueTPUEmbeddingSparseTensorBatch {
    pub T1: ::std::option::Option<crate::DataType>,
    pub T2: ::std::option::Option<crate::DataType>,
    pub T3: ::std::option::Option<crate::DataType>,
    pub N: ::std::option::Option<i64>,
    pub device_ordinal: ::std::option::Option<i64>,
    pub combiners: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub table_ids: ::std::option::Option<::std::vec::Vec<i64>>,
    pub max_sequence_lengths: ::std::option::Option<::std::vec::Vec<i64>>,
    pub num_features: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl EnqueueTPUEmbeddingSparseTensorBatch {
    /// Creates a new `EnqueueTPUEmbeddingSparseTensorBatch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// enqueue_tpuembedding_sparse_tensor_batch with default options.
pub fn enqueue_tpuembedding_sparse_tensor_batch<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sample_indices: T0,
    embedding_indices: T1,
    aggregation_weights: T2,
    mode_override: T3,
) -> Result<()> {
    let __args = EnqueueTPUEmbeddingSparseTensorBatch::new();
    enqueue_tpuembedding_sparse_tensor_batch_with_args(
        ctx,
        sample_indices,
        embedding_indices,
        aggregation_weights,
        mode_override,
        &__args,
    )
}

/// enqueue_tpuembedding_sparse_tensor_batch with options.
pub fn enqueue_tpuembedding_sparse_tensor_batch_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sample_indices: T0,
    embedding_indices: T1,
    aggregation_weights: T2,
    mode_override: T3,
    __args: &EnqueueTPUEmbeddingSparseTensorBatch,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EnqueueTPUEmbeddingSparseTensorBatch")?;

    // Required input arguments
    op.add_input(&sample_indices.to_handle()?)?;
    op.add_input(&embedding_indices.to_handle()?)?;
    op.add_input(&aggregation_weights.to_handle()?)?;
    op.add_input(&mode_override.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T1 {
        op.set_attr_type("T1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T2 {
        op.set_attr_type("T2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T3 {
        op.set_attr_type("T3", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.device_ordinal {
        op.set_attr_int("device_ordinal", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.combiners {
        op.set_attr_string_list("combiners", value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_ids {
        op.set_attr_int_list("table_ids", value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_sequence_lengths {
        op.set_attr_int_list("max_sequence_lengths", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int_list("num_features", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// EnsureShape
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EnsureShape {
    pub shape: ::std::option::Option<crate::Shape>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl EnsureShape {
    /// Creates a new `EnsureShape`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ensure_shape with default options.
pub fn ensure_shape<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = EnsureShape::new();
    ensure_shape_with_args(ctx, input, &__args)
}

/// ensure_shape with options.
pub fn ensure_shape_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &EnsureShape,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EnsureShape")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Enter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Enter {
    pub T: ::std::option::Option<crate::DataType>,
    pub frame_name: ::std::option::Option<::std::string::String>,
    pub is_constant: ::std::option::Option<bool>,
    pub parallel_iterations: ::std::option::Option<i64>,
}

impl Enter {
    /// Creates a new `Enter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// enter with default options.
pub fn enter<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Enter::new();
    enter_with_args(ctx, data, &__args)
}

/// enter with options.
pub fn enter_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    __args: &Enter,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Enter")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.frame_name {
        op.set_attr_string("frame_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_constant {
        op.set_attr_bool("is_constant", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.parallel_iterations {
        op.set_attr_int("parallel_iterations", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Equal
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Equal {
    pub T: ::std::option::Option<crate::DataType>,
    pub incompatible_shape_error: ::std::option::Option<bool>,
}

impl Equal {
    /// Creates a new `Equal`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// equal with default options.
pub fn equal<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Equal::new();
    equal_with_args(ctx, x, y, &__args)
}

/// equal with options.
pub fn equal_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Equal,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Equal")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.incompatible_shape_error {
        op.set_attr_bool("incompatible_shape_error", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Erf
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Erf {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Erf {
    /// Creates a new `Erf`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// erf with default options.
pub fn erf<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Erf::new();
    erf_with_args(ctx, x, &__args)
}

/// erf with options.
pub fn erf_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Erf,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Erf")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Erfc
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Erfc {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Erfc {
    /// Creates a new `Erfc`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// erfc with default options.
pub fn erfc<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Erfc::new();
    erfc_with_args(ctx, x, &__args)
}

/// erfc with options.
pub fn erfc_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Erfc,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Erfc")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Erfinv
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Erfinv {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Erfinv {
    /// Creates a new `Erfinv`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// erfinv with default options.
pub fn erfinv<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Erfinv::new();
    erfinv_with_args(ctx, x, &__args)
}

/// erfinv with options.
pub fn erfinv_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Erfinv,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Erfinv")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// EuclideanNorm
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EuclideanNorm {
    pub keep_dims: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl EuclideanNorm {
    /// Creates a new `EuclideanNorm`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// euclidean_norm with default options.
pub fn euclidean_norm<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = EuclideanNorm::new();
    euclidean_norm_with_args(ctx, input, reduction_indices, &__args)
}

/// euclidean_norm with options.
pub fn euclidean_norm_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
    __args: &EuclideanNorm,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "EuclideanNorm")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&reduction_indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Exit
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Exit {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Exit {
    /// Creates a new `Exit`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// exit with default options.
pub fn exit<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Exit::new();
    exit_with_args(ctx, data, &__args)
}

/// exit with options.
pub fn exit_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    __args: &Exit,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Exit")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Exp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Exp {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Exp {
    /// Creates a new `Exp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// exp with default options.
pub fn exp<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Exp::new();
    exp_with_args(ctx, x, &__args)
}

/// exp with options.
pub fn exp_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Exp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Exp")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExpandDims
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExpandDims {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tdim: ::std::option::Option<crate::DataType>,
}

impl ExpandDims {
    /// Creates a new `ExpandDims`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// expand_dims with default options.
pub fn expand_dims<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    dim: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExpandDims::new();
    expand_dims_with_args(ctx, input, dim, &__args)
}

/// expand_dims with options.
pub fn expand_dims_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    dim: T1,
    __args: &ExpandDims,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExpandDims")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&dim.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tdim {
        op.set_attr_type("Tdim", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalAssertNextDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalAssertNextDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalAssertNextDataset {
    /// Creates a new `ExperimentalAssertNextDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_assert_next_dataset with default options.
pub fn experimental_assert_next_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    transformations: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalAssertNextDataset::new();
    experimental_assert_next_dataset_with_args(ctx, input_dataset, transformations, &__args)
}

/// experimental_assert_next_dataset with options.
pub fn experimental_assert_next_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    transformations: T1,
    __args: &ExperimentalAssertNextDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalAssertNextDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&transformations.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalAutoShardDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalAutoShardDataset {
    pub auto_shard_policy: ::std::option::Option<i64>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalAutoShardDataset {
    /// Creates a new `ExperimentalAutoShardDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_auto_shard_dataset with default options.
pub fn experimental_auto_shard_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_workers: T1,
    index: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalAutoShardDataset::new();
    experimental_auto_shard_dataset_with_args(ctx, input_dataset, num_workers, index, &__args)
}

/// experimental_auto_shard_dataset with options.
pub fn experimental_auto_shard_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_workers: T1,
    index: T2,
    __args: &ExperimentalAutoShardDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalAutoShardDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&num_workers.to_handle()?)?;
    op.add_input(&index.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.auto_shard_policy {
        op.set_attr_int("auto_shard_policy", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalBytesProducedStatsDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalBytesProducedStatsDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalBytesProducedStatsDataset {
    /// Creates a new `ExperimentalBytesProducedStatsDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_bytes_produced_stats_dataset with default options.
pub fn experimental_bytes_produced_stats_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    tag: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalBytesProducedStatsDataset::new();
    experimental_bytes_produced_stats_dataset_with_args(ctx, input_dataset, tag, &__args)
}

/// experimental_bytes_produced_stats_dataset with options.
pub fn experimental_bytes_produced_stats_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    tag: T1,
    __args: &ExperimentalBytesProducedStatsDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalBytesProducedStatsDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&tag.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalCSVDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalCSVDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalCSVDataset {
    /// Creates a new `ExperimentalCSVDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_csvdataset with default options.
pub fn experimental_csvdataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    compression_type: T1,
    buffer_size: T2,
    header: T3,
    field_delim: T4,
    use_quote_delim: T5,
    na_value: T6,
    select_cols: T7,
    record_defaults: T8,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalCSVDataset::new();
    experimental_csvdataset_with_args(
        ctx,
        filenames,
        compression_type,
        buffer_size,
        header,
        field_delim,
        use_quote_delim,
        na_value,
        select_cols,
        record_defaults,
        &__args,
    )
}

/// experimental_csvdataset with options.
pub fn experimental_csvdataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    compression_type: T1,
    buffer_size: T2,
    header: T3,
    field_delim: T4,
    use_quote_delim: T5,
    na_value: T6,
    select_cols: T7,
    record_defaults: T8,
    __args: &ExperimentalCSVDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalCSVDataset")?;

    // Required input arguments
    op.add_input(&filenames.to_handle()?)?;
    op.add_input(&compression_type.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;
    op.add_input(&header.to_handle()?)?;
    op.add_input(&field_delim.to_handle()?)?;
    op.add_input(&use_quote_delim.to_handle()?)?;
    op.add_input(&na_value.to_handle()?)?;
    op.add_input(&select_cols.to_handle()?)?;
    op.add_input(&record_defaults.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalChooseFastestDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalChooseFastestDataset {
    pub N: ::std::option::Option<i64>,
    pub num_experiments: ::std::option::Option<i64>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalChooseFastestDataset {
    /// Creates a new `ExperimentalChooseFastestDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_choose_fastest_dataset with default options.
pub fn experimental_choose_fastest_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_datasets: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalChooseFastestDataset::new();
    experimental_choose_fastest_dataset_with_args(ctx, input_datasets, &__args)
}

/// experimental_choose_fastest_dataset with options.
pub fn experimental_choose_fastest_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_datasets: T0,
    __args: &ExperimentalChooseFastestDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalChooseFastestDataset")?;

    // Required input arguments
    op.add_input(&input_datasets.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_experiments {
        op.set_attr_int("num_experiments", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalDatasetCardinality
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalDatasetCardinality {}

impl ExperimentalDatasetCardinality {
    /// Creates a new `ExperimentalDatasetCardinality`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_dataset_cardinality with default options.
pub fn experimental_dataset_cardinality<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalDatasetCardinality::new();
    experimental_dataset_cardinality_with_args(ctx, input_dataset, &__args)
}

/// experimental_dataset_cardinality with options.
pub fn experimental_dataset_cardinality_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &ExperimentalDatasetCardinality,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalDatasetCardinality")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalDatasetToTFRecord
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalDatasetToTFRecord {}

impl ExperimentalDatasetToTFRecord {
    /// Creates a new `ExperimentalDatasetToTFRecord`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_dataset_to_tfrecord with default options.
pub fn experimental_dataset_to_tfrecord<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    filename: T1,
    compression_type: T2,
) -> Result<()> {
    let __args = ExperimentalDatasetToTFRecord::new();
    experimental_dataset_to_tfrecord_with_args(
        ctx,
        input_dataset,
        filename,
        compression_type,
        &__args,
    )
}

/// experimental_dataset_to_tfrecord with options.
pub fn experimental_dataset_to_tfrecord_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    filename: T1,
    compression_type: T2,
    __args: &ExperimentalDatasetToTFRecord,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalDatasetToTFRecord")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&filename.to_handle()?)?;
    op.add_input(&compression_type.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ExperimentalDenseToSparseBatchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalDenseToSparseBatchDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalDenseToSparseBatchDataset {
    /// Creates a new `ExperimentalDenseToSparseBatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_dense_to_sparse_batch_dataset with default options.
pub fn experimental_dense_to_sparse_batch_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    row_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalDenseToSparseBatchDataset::new();
    experimental_dense_to_sparse_batch_dataset_with_args(
        ctx,
        input_dataset,
        batch_size,
        row_shape,
        &__args,
    )
}

/// experimental_dense_to_sparse_batch_dataset with options.
pub fn experimental_dense_to_sparse_batch_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    row_shape: T2,
    __args: &ExperimentalDenseToSparseBatchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalDenseToSparseBatchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&batch_size.to_handle()?)?;
    op.add_input(&row_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalDirectedInterleaveDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalDirectedInterleaveDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub N: ::std::option::Option<i64>,
}

impl ExperimentalDirectedInterleaveDataset {
    /// Creates a new `ExperimentalDirectedInterleaveDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_directed_interleave_dataset with default options.
pub fn experimental_directed_interleave_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    selector_input_dataset: T0,
    data_input_datasets: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalDirectedInterleaveDataset::new();
    experimental_directed_interleave_dataset_with_args(
        ctx,
        selector_input_dataset,
        data_input_datasets,
        &__args,
    )
}

/// experimental_directed_interleave_dataset with options.
pub fn experimental_directed_interleave_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    selector_input_dataset: T0,
    data_input_datasets: T1,
    __args: &ExperimentalDirectedInterleaveDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalDirectedInterleaveDataset")?;

    // Required input arguments
    op.add_input(&selector_input_dataset.to_handle()?)?;
    op.add_input(&data_input_datasets.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalGroupByReducerDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalGroupByReducerDataset {
    pub key_func: ::std::option::Option<::std::string::String>,
    pub init_func: ::std::option::Option<::std::string::String>,
    pub reduce_func: ::std::option::Option<::std::string::String>,
    pub finalize_func: ::std::option::Option<::std::string::String>,
    pub Tkey_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tinit_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Treduce_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tfinalize_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalGroupByReducerDataset {
    /// Creates a new `ExperimentalGroupByReducerDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_group_by_reducer_dataset with default options.
pub fn experimental_group_by_reducer_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    key_func_other_arguments: T1,
    init_func_other_arguments: T2,
    reduce_func_other_arguments: T3,
    finalize_func_other_arguments: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalGroupByReducerDataset::new();
    experimental_group_by_reducer_dataset_with_args(
        ctx,
        input_dataset,
        key_func_other_arguments,
        init_func_other_arguments,
        reduce_func_other_arguments,
        finalize_func_other_arguments,
        &__args,
    )
}

/// experimental_group_by_reducer_dataset with options.
pub fn experimental_group_by_reducer_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    key_func_other_arguments: T1,
    init_func_other_arguments: T2,
    reduce_func_other_arguments: T3,
    finalize_func_other_arguments: T4,
    __args: &ExperimentalGroupByReducerDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalGroupByReducerDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&key_func_other_arguments.to_handle()?)?;
    op.add_input(&init_func_other_arguments.to_handle()?)?;
    op.add_input(&reduce_func_other_arguments.to_handle()?)?;
    op.add_input(&finalize_func_other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.key_func {
        op.set_attr_string("key_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.init_func {
        op.set_attr_string("init_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.reduce_func {
        op.set_attr_string("reduce_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.finalize_func {
        op.set_attr_string("finalize_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tkey_func_other_arguments {
        op.set_attr_type_list("Tkey_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tinit_func_other_arguments {
        op.set_attr_type_list("Tinit_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Treduce_func_other_arguments {
        op.set_attr_type_list("Treduce_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfinalize_func_other_arguments {
        op.set_attr_type_list("Tfinalize_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalGroupByWindowDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalGroupByWindowDataset {
    pub key_func: ::std::option::Option<::std::string::String>,
    pub reduce_func: ::std::option::Option<::std::string::String>,
    pub window_size_func: ::std::option::Option<::std::string::String>,
    pub Tkey_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Treduce_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Twindow_size_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalGroupByWindowDataset {
    /// Creates a new `ExperimentalGroupByWindowDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_group_by_window_dataset with default options.
pub fn experimental_group_by_window_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    key_func_other_arguments: T1,
    reduce_func_other_arguments: T2,
    window_size_func_other_arguments: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalGroupByWindowDataset::new();
    experimental_group_by_window_dataset_with_args(
        ctx,
        input_dataset,
        key_func_other_arguments,
        reduce_func_other_arguments,
        window_size_func_other_arguments,
        &__args,
    )
}

/// experimental_group_by_window_dataset with options.
pub fn experimental_group_by_window_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    key_func_other_arguments: T1,
    reduce_func_other_arguments: T2,
    window_size_func_other_arguments: T3,
    __args: &ExperimentalGroupByWindowDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalGroupByWindowDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&key_func_other_arguments.to_handle()?)?;
    op.add_input(&reduce_func_other_arguments.to_handle()?)?;
    op.add_input(&window_size_func_other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.key_func {
        op.set_attr_string("key_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.reduce_func {
        op.set_attr_string("reduce_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.window_size_func {
        op.set_attr_string("window_size_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tkey_func_other_arguments {
        op.set_attr_type_list("Tkey_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Treduce_func_other_arguments {
        op.set_attr_type_list("Treduce_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Twindow_size_func_other_arguments {
        op.set_attr_type_list("Twindow_size_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalIgnoreErrorsDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalIgnoreErrorsDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub log_warning: ::std::option::Option<bool>,
}

impl ExperimentalIgnoreErrorsDataset {
    /// Creates a new `ExperimentalIgnoreErrorsDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_ignore_errors_dataset with default options.
pub fn experimental_ignore_errors_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalIgnoreErrorsDataset::new();
    experimental_ignore_errors_dataset_with_args(ctx, input_dataset, &__args)
}

/// experimental_ignore_errors_dataset with options.
pub fn experimental_ignore_errors_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &ExperimentalIgnoreErrorsDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalIgnoreErrorsDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.log_warning {
        op.set_attr_bool("log_warning", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalIteratorGetDevice
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalIteratorGetDevice {}

impl ExperimentalIteratorGetDevice {
    /// Creates a new `ExperimentalIteratorGetDevice`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_iterator_get_device with default options.
pub fn experimental_iterator_get_device<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalIteratorGetDevice::new();
    experimental_iterator_get_device_with_args(ctx, resource, &__args)
}

/// experimental_iterator_get_device with options.
pub fn experimental_iterator_get_device_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    __args: &ExperimentalIteratorGetDevice,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalIteratorGetDevice")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalLMDBDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalLMDBDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalLMDBDataset {
    /// Creates a new `ExperimentalLMDBDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_lmdbdataset with default options.
pub fn experimental_lmdbdataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    filenames: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalLMDBDataset::new();
    experimental_lmdbdataset_with_args(ctx, filenames, &__args)
}

/// experimental_lmdbdataset with options.
pub fn experimental_lmdbdataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    filenames: T0,
    __args: &ExperimentalLMDBDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalLMDBDataset")?;

    // Required input arguments
    op.add_input(&filenames.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalLatencyStatsDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalLatencyStatsDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalLatencyStatsDataset {
    /// Creates a new `ExperimentalLatencyStatsDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_latency_stats_dataset with default options.
pub fn experimental_latency_stats_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    tag: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalLatencyStatsDataset::new();
    experimental_latency_stats_dataset_with_args(ctx, input_dataset, tag, &__args)
}

/// experimental_latency_stats_dataset with options.
pub fn experimental_latency_stats_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    tag: T1,
    __args: &ExperimentalLatencyStatsDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalLatencyStatsDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&tag.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalMapAndBatchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalMapAndBatchDataset {
    pub f: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub preserve_cardinality: ::std::option::Option<bool>,
}

impl ExperimentalMapAndBatchDataset {
    /// Creates a new `ExperimentalMapAndBatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_map_and_batch_dataset with default options.
pub fn experimental_map_and_batch_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    batch_size: T2,
    num_parallel_calls: T3,
    drop_remainder: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalMapAndBatchDataset::new();
    experimental_map_and_batch_dataset_with_args(
        ctx,
        input_dataset,
        other_arguments,
        batch_size,
        num_parallel_calls,
        drop_remainder,
        &__args,
    )
}

/// experimental_map_and_batch_dataset with options.
pub fn experimental_map_and_batch_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    batch_size: T2,
    num_parallel_calls: T3,
    drop_remainder: T4,
    __args: &ExperimentalMapAndBatchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalMapAndBatchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;
    op.add_input(&batch_size.to_handle()?)?;
    op.add_input(&num_parallel_calls.to_handle()?)?;
    op.add_input(&drop_remainder.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.preserve_cardinality {
        op.set_attr_bool("preserve_cardinality", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalMapDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalMapDataset {
    pub f: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub use_inter_op_parallelism: ::std::option::Option<bool>,
    pub preserve_cardinality: ::std::option::Option<bool>,
}

impl ExperimentalMapDataset {
    /// Creates a new `ExperimentalMapDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_map_dataset with default options.
pub fn experimental_map_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalMapDataset::new();
    experimental_map_dataset_with_args(ctx, input_dataset, other_arguments, &__args)
}

/// experimental_map_dataset with options.
pub fn experimental_map_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    __args: &ExperimentalMapDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalMapDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.use_inter_op_parallelism {
        op.set_attr_bool("use_inter_op_parallelism", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.preserve_cardinality {
        op.set_attr_bool("preserve_cardinality", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalMatchingFilesDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalMatchingFilesDataset {}

impl ExperimentalMatchingFilesDataset {
    /// Creates a new `ExperimentalMatchingFilesDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_matching_files_dataset with default options.
pub fn experimental_matching_files_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    patterns: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalMatchingFilesDataset::new();
    experimental_matching_files_dataset_with_args(ctx, patterns, &__args)
}

/// experimental_matching_files_dataset with options.
pub fn experimental_matching_files_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    patterns: T0,
    __args: &ExperimentalMatchingFilesDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalMatchingFilesDataset")?;

    // Required input arguments
    op.add_input(&patterns.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalMaxIntraOpParallelismDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalMaxIntraOpParallelismDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalMaxIntraOpParallelismDataset {
    /// Creates a new `ExperimentalMaxIntraOpParallelismDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_max_intra_op_parallelism_dataset with default options.
pub fn experimental_max_intra_op_parallelism_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    max_intra_op_parallelism: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalMaxIntraOpParallelismDataset::new();
    experimental_max_intra_op_parallelism_dataset_with_args(
        ctx,
        input_dataset,
        max_intra_op_parallelism,
        &__args,
    )
}

/// experimental_max_intra_op_parallelism_dataset with options.
pub fn experimental_max_intra_op_parallelism_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    max_intra_op_parallelism: T1,
    __args: &ExperimentalMaxIntraOpParallelismDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalMaxIntraOpParallelismDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&max_intra_op_parallelism.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalNonSerializableDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalNonSerializableDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalNonSerializableDataset {
    /// Creates a new `ExperimentalNonSerializableDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_non_serializable_dataset with default options.
pub fn experimental_non_serializable_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalNonSerializableDataset::new();
    experimental_non_serializable_dataset_with_args(ctx, input_dataset, &__args)
}

/// experimental_non_serializable_dataset with options.
pub fn experimental_non_serializable_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &ExperimentalNonSerializableDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalNonSerializableDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalParallelInterleaveDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalParallelInterleaveDataset {
    pub f: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalParallelInterleaveDataset {
    /// Creates a new `ExperimentalParallelInterleaveDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_parallel_interleave_dataset with default options.
pub fn experimental_parallel_interleave_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    sloppy: T4,
    buffer_output_elements: T5,
    prefetch_input_elements: T6,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalParallelInterleaveDataset::new();
    experimental_parallel_interleave_dataset_with_args(
        ctx,
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        sloppy,
        buffer_output_elements,
        prefetch_input_elements,
        &__args,
    )
}

/// experimental_parallel_interleave_dataset with options.
pub fn experimental_parallel_interleave_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    sloppy: T4,
    buffer_output_elements: T5,
    prefetch_input_elements: T6,
    __args: &ExperimentalParallelInterleaveDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalParallelInterleaveDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;
    op.add_input(&cycle_length.to_handle()?)?;
    op.add_input(&block_length.to_handle()?)?;
    op.add_input(&sloppy.to_handle()?)?;
    op.add_input(&buffer_output_elements.to_handle()?)?;
    op.add_input(&prefetch_input_elements.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalParseExampleDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalParseExampleDataset {
    pub sparse_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub dense_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tdense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub sloppy: ::std::option::Option<bool>,
}

impl ExperimentalParseExampleDataset {
    /// Creates a new `ExperimentalParseExampleDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_parse_example_dataset with default options.
pub fn experimental_parse_example_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_parallel_calls: T1,
    dense_defaults: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalParseExampleDataset::new();
    experimental_parse_example_dataset_with_args(
        ctx,
        input_dataset,
        num_parallel_calls,
        dense_defaults,
        &__args,
    )
}

/// experimental_parse_example_dataset with options.
pub fn experimental_parse_example_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_parallel_calls: T1,
    dense_defaults: T2,
    __args: &ExperimentalParseExampleDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalParseExampleDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&num_parallel_calls.to_handle()?)?;
    op.add_input(&dense_defaults.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.sparse_keys {
        op.set_attr_string_list("sparse_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_keys {
        op.set_attr_string_list("dense_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.sparse_types {
        op.set_attr_type_list("sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tdense {
        op.set_attr_type_list("Tdense", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_shapes {
        op.set_attr_shape_list("dense_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.sloppy {
        op.set_attr_bool("sloppy", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalPrivateThreadPoolDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalPrivateThreadPoolDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalPrivateThreadPoolDataset {
    /// Creates a new `ExperimentalPrivateThreadPoolDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_private_thread_pool_dataset with default options.
pub fn experimental_private_thread_pool_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_threads: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalPrivateThreadPoolDataset::new();
    experimental_private_thread_pool_dataset_with_args(ctx, input_dataset, num_threads, &__args)
}

/// experimental_private_thread_pool_dataset with options.
pub fn experimental_private_thread_pool_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_threads: T1,
    __args: &ExperimentalPrivateThreadPoolDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalPrivateThreadPoolDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&num_threads.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalRandomDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalRandomDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalRandomDataset {
    /// Creates a new `ExperimentalRandomDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_random_dataset with default options.
pub fn experimental_random_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    seed: T0,
    seed2: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalRandomDataset::new();
    experimental_random_dataset_with_args(ctx, seed, seed2, &__args)
}

/// experimental_random_dataset with options.
pub fn experimental_random_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    seed: T0,
    seed2: T1,
    __args: &ExperimentalRandomDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalRandomDataset")?;

    // Required input arguments
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&seed2.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalRebatchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalRebatchDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub use_fallback: ::std::option::Option<bool>,
}

impl ExperimentalRebatchDataset {
    /// Creates a new `ExperimentalRebatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_rebatch_dataset with default options.
pub fn experimental_rebatch_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_replicas: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalRebatchDataset::new();
    experimental_rebatch_dataset_with_args(ctx, input_dataset, num_replicas, &__args)
}

/// experimental_rebatch_dataset with options.
pub fn experimental_rebatch_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_replicas: T1,
    __args: &ExperimentalRebatchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalRebatchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&num_replicas.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.use_fallback {
        op.set_attr_bool("use_fallback", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalScanDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalScanDataset {
    pub f: ::std::option::Option<::std::string::String>,
    pub Tstate: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub preserve_cardinality: ::std::option::Option<bool>,
}

impl ExperimentalScanDataset {
    /// Creates a new `ExperimentalScanDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_scan_dataset with default options.
pub fn experimental_scan_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    initial_state: T1,
    other_arguments: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalScanDataset::new();
    experimental_scan_dataset_with_args(ctx, input_dataset, initial_state, other_arguments, &__args)
}

/// experimental_scan_dataset with options.
pub fn experimental_scan_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    initial_state: T1,
    other_arguments: T2,
    __args: &ExperimentalScanDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalScanDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&initial_state.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tstate {
        op.set_attr_type_list("Tstate", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.preserve_cardinality {
        op.set_attr_bool("preserve_cardinality", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalSetStatsAggregatorDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalSetStatsAggregatorDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalSetStatsAggregatorDataset {
    /// Creates a new `ExperimentalSetStatsAggregatorDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_set_stats_aggregator_dataset with default options.
pub fn experimental_set_stats_aggregator_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    stats_aggregator: T1,
    tag: T2,
    counter_prefix: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalSetStatsAggregatorDataset::new();
    experimental_set_stats_aggregator_dataset_with_args(
        ctx,
        input_dataset,
        stats_aggregator,
        tag,
        counter_prefix,
        &__args,
    )
}

/// experimental_set_stats_aggregator_dataset with options.
pub fn experimental_set_stats_aggregator_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    stats_aggregator: T1,
    tag: T2,
    counter_prefix: T3,
    __args: &ExperimentalSetStatsAggregatorDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalSetStatsAggregatorDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&stats_aggregator.to_handle()?)?;
    op.add_input(&tag.to_handle()?)?;
    op.add_input(&counter_prefix.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalSleepDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalSleepDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalSleepDataset {
    /// Creates a new `ExperimentalSleepDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_sleep_dataset with default options.
pub fn experimental_sleep_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    sleep_microseconds: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalSleepDataset::new();
    experimental_sleep_dataset_with_args(ctx, input_dataset, sleep_microseconds, &__args)
}

/// experimental_sleep_dataset with options.
pub fn experimental_sleep_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    sleep_microseconds: T1,
    __args: &ExperimentalSleepDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalSleepDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&sleep_microseconds.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalSlidingWindowDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalSlidingWindowDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalSlidingWindowDataset {
    /// Creates a new `ExperimentalSlidingWindowDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_sliding_window_dataset with default options.
pub fn experimental_sliding_window_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    window_size: T1,
    window_shift: T2,
    window_stride: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalSlidingWindowDataset::new();
    experimental_sliding_window_dataset_with_args(
        ctx,
        input_dataset,
        window_size,
        window_shift,
        window_stride,
        &__args,
    )
}

/// experimental_sliding_window_dataset with options.
pub fn experimental_sliding_window_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    window_size: T1,
    window_shift: T2,
    window_stride: T3,
    __args: &ExperimentalSlidingWindowDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalSlidingWindowDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&window_size.to_handle()?)?;
    op.add_input(&window_shift.to_handle()?)?;
    op.add_input(&window_stride.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalSqlDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalSqlDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalSqlDataset {
    /// Creates a new `ExperimentalSqlDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_sql_dataset with default options.
pub fn experimental_sql_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    driver_name: T0,
    data_source_name: T1,
    query: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalSqlDataset::new();
    experimental_sql_dataset_with_args(ctx, driver_name, data_source_name, query, &__args)
}

/// experimental_sql_dataset with options.
pub fn experimental_sql_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    driver_name: T0,
    data_source_name: T1,
    query: T2,
    __args: &ExperimentalSqlDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalSqlDataset")?;

    // Required input arguments
    op.add_input(&driver_name.to_handle()?)?;
    op.add_input(&data_source_name.to_handle()?)?;
    op.add_input(&query.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalStatsAggregatorHandle
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalStatsAggregatorHandle {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl ExperimentalStatsAggregatorHandle {
    /// Creates a new `ExperimentalStatsAggregatorHandle`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_stats_aggregator_handle with default options.
pub fn experimental_stats_aggregator_handle(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalStatsAggregatorHandle::new();
    experimental_stats_aggregator_handle_with_args(ctx, &__args)
}

/// experimental_stats_aggregator_handle with options.
pub fn experimental_stats_aggregator_handle_with_args(
    ctx: &crate::eager::Context,
    __args: &ExperimentalStatsAggregatorHandle,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalStatsAggregatorHandle")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalStatsAggregatorSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalStatsAggregatorSummary {}

impl ExperimentalStatsAggregatorSummary {
    /// Creates a new `ExperimentalStatsAggregatorSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_stats_aggregator_summary with default options.
pub fn experimental_stats_aggregator_summary<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    iterator: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalStatsAggregatorSummary::new();
    experimental_stats_aggregator_summary_with_args(ctx, iterator, &__args)
}

/// experimental_stats_aggregator_summary with options.
pub fn experimental_stats_aggregator_summary_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    iterator: T0,
    __args: &ExperimentalStatsAggregatorSummary,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalStatsAggregatorSummary")?;

    // Required input arguments
    op.add_input(&iterator.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalTakeWhileDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalTakeWhileDataset {
    pub predicate: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalTakeWhileDataset {
    /// Creates a new `ExperimentalTakeWhileDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_take_while_dataset with default options.
pub fn experimental_take_while_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalTakeWhileDataset::new();
    experimental_take_while_dataset_with_args(ctx, input_dataset, other_arguments, &__args)
}

/// experimental_take_while_dataset with options.
pub fn experimental_take_while_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    __args: &ExperimentalTakeWhileDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalTakeWhileDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.predicate {
        op.set_attr_string("predicate", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalThreadPoolDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalThreadPoolDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalThreadPoolDataset {
    /// Creates a new `ExperimentalThreadPoolDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_thread_pool_dataset with default options.
pub fn experimental_thread_pool_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    thread_pool: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalThreadPoolDataset::new();
    experimental_thread_pool_dataset_with_args(ctx, input_dataset, thread_pool, &__args)
}

/// experimental_thread_pool_dataset with options.
pub fn experimental_thread_pool_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    thread_pool: T1,
    __args: &ExperimentalThreadPoolDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalThreadPoolDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&thread_pool.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalThreadPoolHandle
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalThreadPoolHandle {
    pub num_threads: ::std::option::Option<i64>,
    pub max_intra_op_parallelism: ::std::option::Option<i64>,
    pub display_name: ::std::option::Option<::std::string::String>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl ExperimentalThreadPoolHandle {
    /// Creates a new `ExperimentalThreadPoolHandle`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_thread_pool_handle with default options.
pub fn experimental_thread_pool_handle(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalThreadPoolHandle::new();
    experimental_thread_pool_handle_with_args(ctx, &__args)
}

/// experimental_thread_pool_handle with options.
pub fn experimental_thread_pool_handle_with_args(
    ctx: &crate::eager::Context,
    __args: &ExperimentalThreadPoolHandle,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalThreadPoolHandle")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_threads {
        op.set_attr_int("num_threads", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_intra_op_parallelism {
        op.set_attr_int("max_intra_op_parallelism", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.display_name {
        op.set_attr_string("display_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalUnbatchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalUnbatchDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalUnbatchDataset {
    /// Creates a new `ExperimentalUnbatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_unbatch_dataset with default options.
pub fn experimental_unbatch_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalUnbatchDataset::new();
    experimental_unbatch_dataset_with_args(ctx, input_dataset, &__args)
}

/// experimental_unbatch_dataset with options.
pub fn experimental_unbatch_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &ExperimentalUnbatchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalUnbatchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExperimentalUniqueDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalUniqueDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ExperimentalUniqueDataset {
    /// Creates a new `ExperimentalUniqueDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// experimental_unique_dataset with default options.
pub fn experimental_unique_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExperimentalUniqueDataset::new();
    experimental_unique_dataset_with_args(ctx, input_dataset, &__args)
}

/// experimental_unique_dataset with options.
pub fn experimental_unique_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &ExperimentalUniqueDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExperimentalUniqueDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Expint
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Expint {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Expint {
    /// Creates a new `Expint`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// expint with default options.
pub fn expint<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Expint::new();
    expint_with_args(ctx, x, &__args)
}

/// expint with options.
pub fn expint_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Expint,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Expint")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Expm1
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Expm1 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Expm1 {
    /// Creates a new `Expm1`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// expm1 with default options.
pub fn expm1<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Expm1::new();
    expm1_with_args(ctx, x, &__args)
}

/// expm1 with options.
pub fn expm1_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Expm1,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Expm1")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExtractGlimpse
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExtractGlimpse {
    pub centered: ::std::option::Option<bool>,
    pub normalized: ::std::option::Option<bool>,
    pub uniform_noise: ::std::option::Option<bool>,
    pub noise: ::std::option::Option<::std::string::String>,
}

impl ExtractGlimpse {
    /// Creates a new `ExtractGlimpse`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// extract_glimpse with default options.
pub fn extract_glimpse<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    size: T1,
    offsets: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExtractGlimpse::new();
    extract_glimpse_with_args(ctx, input, size, offsets, &__args)
}

/// extract_glimpse with options.
pub fn extract_glimpse_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    size: T1,
    offsets: T2,
    __args: &ExtractGlimpse,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExtractGlimpse")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;
    op.add_input(&offsets.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.centered {
        op.set_attr_bool("centered", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.normalized {
        op.set_attr_bool("normalized", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.uniform_noise {
        op.set_attr_bool("uniform_noise", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.noise {
        op.set_attr_string("noise", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExtractGlimpseV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExtractGlimpseV2 {
    pub centered: ::std::option::Option<bool>,
    pub normalized: ::std::option::Option<bool>,
    pub uniform_noise: ::std::option::Option<bool>,
    pub noise: ::std::option::Option<::std::string::String>,
}

impl ExtractGlimpseV2 {
    /// Creates a new `ExtractGlimpseV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// extract_glimpse_v2 with default options.
pub fn extract_glimpse_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    size: T1,
    offsets: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExtractGlimpseV2::new();
    extract_glimpse_v2_with_args(ctx, input, size, offsets, &__args)
}

/// extract_glimpse_v2 with options.
pub fn extract_glimpse_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    size: T1,
    offsets: T2,
    __args: &ExtractGlimpseV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExtractGlimpseV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;
    op.add_input(&offsets.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.centered {
        op.set_attr_bool("centered", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.normalized {
        op.set_attr_bool("normalized", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.uniform_noise {
        op.set_attr_bool("uniform_noise", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.noise {
        op.set_attr_string("noise", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExtractImagePatches
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExtractImagePatches {
    pub ksizes: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub rates: ::std::option::Option<::std::vec::Vec<i64>>,
    pub T: ::std::option::Option<crate::DataType>,
    pub padding: ::std::option::Option<::std::string::String>,
}

impl ExtractImagePatches {
    /// Creates a new `ExtractImagePatches`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// extract_image_patches with default options.
pub fn extract_image_patches<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExtractImagePatches::new();
    extract_image_patches_with_args(ctx, images, &__args)
}

/// extract_image_patches with options.
pub fn extract_image_patches_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    __args: &ExtractImagePatches,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExtractImagePatches")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksizes {
        op.set_attr_int_list("ksizes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.rates {
        op.set_attr_int_list("rates", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExtractJpegShape
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExtractJpegShape {
    pub output_type: ::std::option::Option<crate::DataType>,
}

impl ExtractJpegShape {
    /// Creates a new `ExtractJpegShape`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// extract_jpeg_shape with default options.
pub fn extract_jpeg_shape<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExtractJpegShape::new();
    extract_jpeg_shape_with_args(ctx, contents, &__args)
}

/// extract_jpeg_shape with options.
pub fn extract_jpeg_shape_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    contents: T0,
    __args: &ExtractJpegShape,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExtractJpegShape")?;

    // Required input arguments
    op.add_input(&contents.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_type {
        op.set_attr_type("output_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ExtractVolumePatches
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExtractVolumePatches {
    pub ksizes: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub T: ::std::option::Option<crate::DataType>,
    pub padding: ::std::option::Option<::std::string::String>,
}

impl ExtractVolumePatches {
    /// Creates a new `ExtractVolumePatches`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// extract_volume_patches with default options.
pub fn extract_volume_patches<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ExtractVolumePatches::new();
    extract_volume_patches_with_args(ctx, input, &__args)
}

/// extract_volume_patches with options.
pub fn extract_volume_patches_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &ExtractVolumePatches,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ExtractVolumePatches")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksizes {
        op.set_attr_int_list("ksizes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FFT
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FFT {
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl FFT {
    /// Creates a new `FFT`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fft with default options.
pub fn fft<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = FFT::new();
    fft_with_args(ctx, input, &__args)
}

/// fft with options.
pub fn fft_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &FFT,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FFT")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FFT2D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FFT2D {
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl FFT2D {
    /// Creates a new `FFT2D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fft2_d with default options.
pub fn fft2_d<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = FFT2D::new();
    fft2_d_with_args(ctx, input, &__args)
}

/// fft2_d with options.
pub fn fft2_d_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &FFT2D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FFT2D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FFT3D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FFT3D {
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl FFT3D {
    /// Creates a new `FFT3D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fft3_d with default options.
pub fn fft3_d<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = FFT3D::new();
    fft3_d_with_args(ctx, input, &__args)
}

/// fft3_d with options.
pub fn fft3_d_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &FFT3D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FFT3D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FIFOQueue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FIFOQueue {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub capacity: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl FIFOQueue {
    /// Creates a new `FIFOQueue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fifoqueue with default options.
pub fn fifoqueue(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = FIFOQueue::new();
    fifoqueue_with_args(ctx, &__args)
}

/// fifoqueue with options.
pub fn fifoqueue_with_args(
    ctx: &crate::eager::Context,
    __args: &FIFOQueue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FIFOQueue")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FIFOQueueV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FIFOQueueV2 {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub capacity: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl FIFOQueueV2 {
    /// Creates a new `FIFOQueueV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fifoqueue_v2 with default options.
pub fn fifoqueue_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = FIFOQueueV2::new();
    fifoqueue_v2_with_args(ctx, &__args)
}

/// fifoqueue_v2 with options.
pub fn fifoqueue_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &FIFOQueueV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FIFOQueueV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Fact
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Fact {}

impl Fact {
    /// Creates a new `Fact`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fact with default options.
pub fn fact(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = Fact::new();
    fact_with_args(ctx, &__args)
}

/// fact with options.
pub fn fact_with_args(
    ctx: &crate::eager::Context,
    __args: &Fact,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Fact")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FakeParam
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeParam {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
}

impl FakeParam {
    /// Creates a new `FakeParam`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fake_param with default options.
pub fn fake_param(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = FakeParam::new();
    fake_param_with_args(ctx, &__args)
}

/// fake_param with options.
pub fn fake_param_with_args(
    ctx: &crate::eager::Context,
    __args: &FakeParam,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FakeParam")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FakeQuantWithMinMaxArgs
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQuantWithMinMaxArgs {
    pub min: ::std::option::Option<f32>,
    pub max: ::std::option::Option<f32>,
    pub num_bits: ::std::option::Option<i64>,
    pub narrow_range: ::std::option::Option<bool>,
}

impl FakeQuantWithMinMaxArgs {
    /// Creates a new `FakeQuantWithMinMaxArgs`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fake_quant_with_min_max_args with default options.
pub fn fake_quant_with_min_max_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = FakeQuantWithMinMaxArgs::new();
    fake_quant_with_min_max_args_with_args(ctx, inputs, &__args)
}

/// fake_quant_with_min_max_args with options.
pub fn fake_quant_with_min_max_args_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &FakeQuantWithMinMaxArgs,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FakeQuantWithMinMaxArgs")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.min {
        op.set_attr_float("min", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max {
        op.set_attr_float("max", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_bits {
        op.set_attr_int("num_bits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.narrow_range {
        op.set_attr_bool("narrow_range", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FakeQuantWithMinMaxArgsGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQuantWithMinMaxArgsGradient {
    pub min: ::std::option::Option<f32>,
    pub max: ::std::option::Option<f32>,
    pub num_bits: ::std::option::Option<i64>,
    pub narrow_range: ::std::option::Option<bool>,
}

impl FakeQuantWithMinMaxArgsGradient {
    /// Creates a new `FakeQuantWithMinMaxArgsGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fake_quant_with_min_max_args_gradient with default options.
pub fn fake_quant_with_min_max_args_gradient<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    gradients: T0,
    inputs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = FakeQuantWithMinMaxArgsGradient::new();
    fake_quant_with_min_max_args_gradient_with_args(ctx, gradients, inputs, &__args)
}

/// fake_quant_with_min_max_args_gradient with options.
pub fn fake_quant_with_min_max_args_gradient_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    gradients: T0,
    inputs: T1,
    __args: &FakeQuantWithMinMaxArgsGradient,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FakeQuantWithMinMaxArgsGradient")?;

    // Required input arguments
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.min {
        op.set_attr_float("min", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max {
        op.set_attr_float("max", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_bits {
        op.set_attr_int("num_bits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.narrow_range {
        op.set_attr_bool("narrow_range", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FakeQuantWithMinMaxVars
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQuantWithMinMaxVars {
    pub num_bits: ::std::option::Option<i64>,
    pub narrow_range: ::std::option::Option<bool>,
}

impl FakeQuantWithMinMaxVars {
    /// Creates a new `FakeQuantWithMinMaxVars`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fake_quant_with_min_max_vars with default options.
pub fn fake_quant_with_min_max_vars<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    inputs: T0,
    min: T1,
    max: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = FakeQuantWithMinMaxVars::new();
    fake_quant_with_min_max_vars_with_args(ctx, inputs, min, max, &__args)
}

/// fake_quant_with_min_max_vars with options.
pub fn fake_quant_with_min_max_vars_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    inputs: T0,
    min: T1,
    max: T2,
    __args: &FakeQuantWithMinMaxVars,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FakeQuantWithMinMaxVars")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;
    op.add_input(&min.to_handle()?)?;
    op.add_input(&max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_bits {
        op.set_attr_int("num_bits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.narrow_range {
        op.set_attr_bool("narrow_range", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FakeQuantWithMinMaxVarsGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQuantWithMinMaxVarsGradient {
    pub num_bits: ::std::option::Option<i64>,
    pub narrow_range: ::std::option::Option<bool>,
}

impl FakeQuantWithMinMaxVarsGradient {
    /// Creates a new `FakeQuantWithMinMaxVarsGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fake_quant_with_min_max_vars_gradient with default options.
pub fn fake_quant_with_min_max_vars_gradient<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    gradients: T0,
    inputs: T1,
    min: T2,
    max: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = FakeQuantWithMinMaxVarsGradient::new();
    fake_quant_with_min_max_vars_gradient_with_args(ctx, gradients, inputs, min, max, &__args)
}

/// fake_quant_with_min_max_vars_gradient with options.
pub fn fake_quant_with_min_max_vars_gradient_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    gradients: T0,
    inputs: T1,
    min: T2,
    max: T3,
    __args: &FakeQuantWithMinMaxVarsGradient,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FakeQuantWithMinMaxVarsGradient")?;

    // Required input arguments
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&inputs.to_handle()?)?;
    op.add_input(&min.to_handle()?)?;
    op.add_input(&max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_bits {
        op.set_attr_int("num_bits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.narrow_range {
        op.set_attr_bool("narrow_range", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// FakeQuantWithMinMaxVarsPerChannel
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQuantWithMinMaxVarsPerChannel {
    pub num_bits: ::std::option::Option<i64>,
    pub narrow_range: ::std::option::Option<bool>,
}

impl FakeQuantWithMinMaxVarsPerChannel {
    /// Creates a new `FakeQuantWithMinMaxVarsPerChannel`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fake_quant_with_min_max_vars_per_channel with default options.
pub fn fake_quant_with_min_max_vars_per_channel<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    inputs: T0,
    min: T1,
    max: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = FakeQuantWithMinMaxVarsPerChannel::new();
    fake_quant_with_min_max_vars_per_channel_with_args(ctx, inputs, min, max, &__args)
}

/// fake_quant_with_min_max_vars_per_channel with options.
pub fn fake_quant_with_min_max_vars_per_channel_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    inputs: T0,
    min: T1,
    max: T2,
    __args: &FakeQuantWithMinMaxVarsPerChannel,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FakeQuantWithMinMaxVarsPerChannel")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;
    op.add_input(&min.to_handle()?)?;
    op.add_input(&max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_bits {
        op.set_attr_int("num_bits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.narrow_range {
        op.set_attr_bool("narrow_range", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FakeQuantWithMinMaxVarsPerChannelGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQuantWithMinMaxVarsPerChannelGradient {
    pub num_bits: ::std::option::Option<i64>,
    pub narrow_range: ::std::option::Option<bool>,
}

impl FakeQuantWithMinMaxVarsPerChannelGradient {
    /// Creates a new `FakeQuantWithMinMaxVarsPerChannelGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fake_quant_with_min_max_vars_per_channel_gradient with default options.
pub fn fake_quant_with_min_max_vars_per_channel_gradient<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    gradients: T0,
    inputs: T1,
    min: T2,
    max: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = FakeQuantWithMinMaxVarsPerChannelGradient::new();
    fake_quant_with_min_max_vars_per_channel_gradient_with_args(
        ctx, gradients, inputs, min, max, &__args,
    )
}

/// fake_quant_with_min_max_vars_per_channel_gradient with options.
pub fn fake_quant_with_min_max_vars_per_channel_gradient_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    gradients: T0,
    inputs: T1,
    min: T2,
    max: T3,
    __args: &FakeQuantWithMinMaxVarsPerChannelGradient,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FakeQuantWithMinMaxVarsPerChannelGradient")?;

    // Required input arguments
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&inputs.to_handle()?)?;
    op.add_input(&min.to_handle()?)?;
    op.add_input(&max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_bits {
        op.set_attr_int("num_bits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.narrow_range {
        op.set_attr_bool("narrow_range", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// FakeQueue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQueue {}

impl FakeQueue {
    /// Creates a new `FakeQueue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fake_queue with default options.
pub fn fake_queue<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = FakeQueue::new();
    fake_queue_with_args(ctx, resource, &__args)
}

/// fake_queue with options.
pub fn fake_queue_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    __args: &FakeQueue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FakeQueue")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Fill
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Fill {
    pub T: ::std::option::Option<crate::DataType>,
    pub index_type: ::std::option::Option<crate::DataType>,
}

impl Fill {
    /// Creates a new `Fill`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fill with default options.
pub fn fill<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    dims: T0,
    value: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Fill::new();
    fill_with_args(ctx, dims, value, &__args)
}

/// fill with options.
pub fn fill_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    dims: T0,
    value: T1,
    __args: &Fill,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Fill")?;

    // Required input arguments
    op.add_input(&dims.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.index_type {
        op.set_attr_type("index_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FilterByLastComponentDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FilterByLastComponentDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl FilterByLastComponentDataset {
    /// Creates a new `FilterByLastComponentDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// filter_by_last_component_dataset with default options.
pub fn filter_by_last_component_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = FilterByLastComponentDataset::new();
    filter_by_last_component_dataset_with_args(ctx, input_dataset, &__args)
}

/// filter_by_last_component_dataset with options.
pub fn filter_by_last_component_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &FilterByLastComponentDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FilterByLastComponentDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FilterDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FilterDataset {
    pub predicate: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl FilterDataset {
    /// Creates a new `FilterDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// filter_dataset with default options.
pub fn filter_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = FilterDataset::new();
    filter_dataset_with_args(ctx, input_dataset, other_arguments, &__args)
}

/// filter_dataset with options.
pub fn filter_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    __args: &FilterDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FilterDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.predicate {
        op.set_attr_string("predicate", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FinalizeDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FinalizeDataset {
    pub has_captured_ref: ::std::option::Option<bool>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl FinalizeDataset {
    /// Creates a new `FinalizeDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// finalize_dataset with default options.
pub fn finalize_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = FinalizeDataset::new();
    finalize_dataset_with_args(ctx, input_dataset, &__args)
}

/// finalize_dataset with options.
pub fn finalize_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &FinalizeDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FinalizeDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.has_captured_ref {
        op.set_attr_bool("has_captured_ref", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Fingerprint
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Fingerprint {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Fingerprint {
    /// Creates a new `Fingerprint`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fingerprint with default options.
pub fn fingerprint<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    method: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Fingerprint::new();
    fingerprint_with_args(ctx, data, method, &__args)
}

/// fingerprint with options.
pub fn fingerprint_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    method: T1,
    __args: &Fingerprint,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Fingerprint")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&method.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FixedLengthRecordDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FixedLengthRecordDataset {}

impl FixedLengthRecordDataset {
    /// Creates a new `FixedLengthRecordDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fixed_length_record_dataset with default options.
pub fn fixed_length_record_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    header_bytes: T1,
    record_bytes: T2,
    footer_bytes: T3,
    buffer_size: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = FixedLengthRecordDataset::new();
    fixed_length_record_dataset_with_args(
        ctx,
        filenames,
        header_bytes,
        record_bytes,
        footer_bytes,
        buffer_size,
        &__args,
    )
}

/// fixed_length_record_dataset with options.
pub fn fixed_length_record_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    header_bytes: T1,
    record_bytes: T2,
    footer_bytes: T3,
    buffer_size: T4,
    __args: &FixedLengthRecordDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FixedLengthRecordDataset")?;

    // Required input arguments
    op.add_input(&filenames.to_handle()?)?;
    op.add_input(&header_bytes.to_handle()?)?;
    op.add_input(&record_bytes.to_handle()?)?;
    op.add_input(&footer_bytes.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FixedLengthRecordDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FixedLengthRecordDatasetV2 {}

impl FixedLengthRecordDatasetV2 {
    /// Creates a new `FixedLengthRecordDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fixed_length_record_dataset_v2 with default options.
pub fn fixed_length_record_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    header_bytes: T1,
    record_bytes: T2,
    footer_bytes: T3,
    buffer_size: T4,
    compression_type: T5,
) -> Result<crate::eager::TensorHandle> {
    let __args = FixedLengthRecordDatasetV2::new();
    fixed_length_record_dataset_v2_with_args(
        ctx,
        filenames,
        header_bytes,
        record_bytes,
        footer_bytes,
        buffer_size,
        compression_type,
        &__args,
    )
}

/// fixed_length_record_dataset_v2 with options.
pub fn fixed_length_record_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    header_bytes: T1,
    record_bytes: T2,
    footer_bytes: T3,
    buffer_size: T4,
    compression_type: T5,
    __args: &FixedLengthRecordDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FixedLengthRecordDatasetV2")?;

    // Required input arguments
    op.add_input(&filenames.to_handle()?)?;
    op.add_input(&header_bytes.to_handle()?)?;
    op.add_input(&record_bytes.to_handle()?)?;
    op.add_input(&footer_bytes.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;
    op.add_input(&compression_type.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FixedLengthRecordReader
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FixedLengthRecordReader {
    pub header_bytes: ::std::option::Option<i64>,
    pub record_bytes: ::std::option::Option<i64>,
    pub footer_bytes: ::std::option::Option<i64>,
    pub hop_bytes: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl FixedLengthRecordReader {
    /// Creates a new `FixedLengthRecordReader`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fixed_length_record_reader with default options.
pub fn fixed_length_record_reader(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = FixedLengthRecordReader::new();
    fixed_length_record_reader_with_args(ctx, &__args)
}

/// fixed_length_record_reader with options.
pub fn fixed_length_record_reader_with_args(
    ctx: &crate::eager::Context,
    __args: &FixedLengthRecordReader,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FixedLengthRecordReader")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.header_bytes {
        op.set_attr_int("header_bytes", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.record_bytes {
        op.set_attr_int("record_bytes", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.footer_bytes {
        op.set_attr_int("footer_bytes", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.hop_bytes {
        op.set_attr_int("hop_bytes", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FixedLengthRecordReaderV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FixedLengthRecordReaderV2 {
    pub header_bytes: ::std::option::Option<i64>,
    pub record_bytes: ::std::option::Option<i64>,
    pub footer_bytes: ::std::option::Option<i64>,
    pub hop_bytes: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub encoding: ::std::option::Option<::std::string::String>,
}

impl FixedLengthRecordReaderV2 {
    /// Creates a new `FixedLengthRecordReaderV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fixed_length_record_reader_v2 with default options.
pub fn fixed_length_record_reader_v2(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = FixedLengthRecordReaderV2::new();
    fixed_length_record_reader_v2_with_args(ctx, &__args)
}

/// fixed_length_record_reader_v2 with options.
pub fn fixed_length_record_reader_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &FixedLengthRecordReaderV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FixedLengthRecordReaderV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.header_bytes {
        op.set_attr_int("header_bytes", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.record_bytes {
        op.set_attr_int("record_bytes", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.footer_bytes {
        op.set_attr_int("footer_bytes", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.hop_bytes {
        op.set_attr_int("hop_bytes", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.encoding {
        op.set_attr_string("encoding", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FixedUnigramCandidateSampler
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FixedUnigramCandidateSampler {
    pub num_true: ::std::option::Option<i64>,
    pub num_sampled: ::std::option::Option<i64>,
    pub unique: ::std::option::Option<bool>,
    pub range_max: ::std::option::Option<i64>,
    pub vocab_file: ::std::option::Option<::std::string::String>,
    pub distortion: ::std::option::Option<f32>,
    pub num_reserved_ids: ::std::option::Option<i64>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard: ::std::option::Option<i64>,
    pub unigrams: ::std::option::Option<::std::vec::Vec<f32>>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
}

impl FixedUnigramCandidateSampler {
    /// Creates a new `FixedUnigramCandidateSampler`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fixed_unigram_candidate_sampler with default options.
pub fn fixed_unigram_candidate_sampler<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = FixedUnigramCandidateSampler::new();
    fixed_unigram_candidate_sampler_with_args(ctx, true_classes, &__args)
}

/// fixed_unigram_candidate_sampler with options.
pub fn fixed_unigram_candidate_sampler_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
    __args: &FixedUnigramCandidateSampler,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FixedUnigramCandidateSampler")?;

    // Required input arguments
    op.add_input(&true_classes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_true {
        op.set_attr_int("num_true", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_sampled {
        op.set_attr_int("num_sampled", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.unique {
        op.set_attr_bool("unique", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.range_max {
        op.set_attr_int("range_max", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.vocab_file {
        op.set_attr_string("vocab_file", value);
    }
    if let ::std::option::Option::Some(value) = &__args.distortion {
        op.set_attr_float("distortion", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_reserved_ids {
        op.set_attr_int("num_reserved_ids", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard {
        op.set_attr_int("shard", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.unigrams {
        op.set_attr_float_list("unigrams", value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// FlatMapDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FlatMapDataset {
    pub f: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl FlatMapDataset {
    /// Creates a new `FlatMapDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// flat_map_dataset with default options.
pub fn flat_map_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = FlatMapDataset::new();
    flat_map_dataset_with_args(ctx, input_dataset, other_arguments, &__args)
}

/// flat_map_dataset with options.
pub fn flat_map_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    __args: &FlatMapDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FlatMapDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Floor
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Floor {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Floor {
    /// Creates a new `Floor`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// floor with default options.
pub fn floor<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Floor::new();
    floor_with_args(ctx, x, &__args)
}

/// floor with options.
pub fn floor_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Floor,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Floor")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FloorDiv
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FloorDiv {
    pub T: ::std::option::Option<crate::DataType>,
}

impl FloorDiv {
    /// Creates a new `FloorDiv`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// floor_div with default options.
pub fn floor_div<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = FloorDiv::new();
    floor_div_with_args(ctx, x, y, &__args)
}

/// floor_div with options.
pub fn floor_div_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &FloorDiv,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FloorDiv")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FloorMod
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FloorMod {
    pub T: ::std::option::Option<crate::DataType>,
}

impl FloorMod {
    /// Creates a new `FloorMod`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// floor_mod with default options.
pub fn floor_mod<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = FloorMod::new();
    floor_mod_with_args(ctx, x, y, &__args)
}

/// floor_mod with options.
pub fn floor_mod_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &FloorMod,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FloorMod")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FlushSummaryWriter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FlushSummaryWriter {}

impl FlushSummaryWriter {
    /// Creates a new `FlushSummaryWriter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// flush_summary_writer with default options.
pub fn flush_summary_writer<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    writer: T0,
) -> Result<()> {
    let __args = FlushSummaryWriter::new();
    flush_summary_writer_with_args(ctx, writer, &__args)
}

/// flush_summary_writer with options.
pub fn flush_summary_writer_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    writer: T0,
    __args: &FlushSummaryWriter,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FlushSummaryWriter")?;

    // Required input arguments
    op.add_input(&writer.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// For
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct For {
    pub T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub body: ::std::option::Option<::std::string::String>,
}

impl For {
    /// Creates a new `For`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// for_ with default options.
pub fn for_<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    start: T0,
    limit: T1,
    delta: T2,
    input: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = For::new();
    for__with_args(ctx, start, limit, delta, input, &__args)
}

/// for_ with options.
pub fn for__with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    start: T0,
    limit: T1,
    delta: T2,
    input: T3,
    __args: &For,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "For")?;

    // Required input arguments
    op.add_input(&start.to_handle()?)?;
    op.add_input(&limit.to_handle()?)?;
    op.add_input(&delta.to_handle()?)?;
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type_list("T", value);
    }
    if let ::std::option::Option::Some(value) = &__args.body {
        op.set_attr_string("body", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FractionalAvgPool
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FractionalAvgPool {
    pub pooling_ratio: ::std::option::Option<::std::vec::Vec<f32>>,
    pub pseudo_random: ::std::option::Option<bool>,
    pub overlapping: ::std::option::Option<bool>,
    pub deterministic: ::std::option::Option<bool>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl FractionalAvgPool {
    /// Creates a new `FractionalAvgPool`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fractional_avg_pool with default options.
pub fn fractional_avg_pool<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = FractionalAvgPool::new();
    fractional_avg_pool_with_args(ctx, value, &__args)
}

/// fractional_avg_pool with options.
pub fn fractional_avg_pool_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
    __args: &FractionalAvgPool,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FractionalAvgPool")?;

    // Required input arguments
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.pooling_ratio {
        op.set_attr_float_list("pooling_ratio", value);
    }
    if let ::std::option::Option::Some(value) = &__args.pseudo_random {
        op.set_attr_bool("pseudo_random", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.overlapping {
        op.set_attr_bool("overlapping", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.deterministic {
        op.set_attr_bool("deterministic", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// FractionalAvgPoolGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FractionalAvgPoolGrad {
    pub overlapping: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl FractionalAvgPoolGrad {
    /// Creates a new `FractionalAvgPoolGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fractional_avg_pool_grad with default options.
pub fn fractional_avg_pool_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input_tensor_shape: T0,
    out_backprop: T1,
    row_pooling_sequence: T2,
    col_pooling_sequence: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = FractionalAvgPoolGrad::new();
    fractional_avg_pool_grad_with_args(
        ctx,
        orig_input_tensor_shape,
        out_backprop,
        row_pooling_sequence,
        col_pooling_sequence,
        &__args,
    )
}

/// fractional_avg_pool_grad with options.
pub fn fractional_avg_pool_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input_tensor_shape: T0,
    out_backprop: T1,
    row_pooling_sequence: T2,
    col_pooling_sequence: T3,
    __args: &FractionalAvgPoolGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FractionalAvgPoolGrad")?;

    // Required input arguments
    op.add_input(&orig_input_tensor_shape.to_handle()?)?;
    op.add_input(&out_backprop.to_handle()?)?;
    op.add_input(&row_pooling_sequence.to_handle()?)?;
    op.add_input(&col_pooling_sequence.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.overlapping {
        op.set_attr_bool("overlapping", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FractionalMaxPool
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FractionalMaxPool {
    pub pooling_ratio: ::std::option::Option<::std::vec::Vec<f32>>,
    pub pseudo_random: ::std::option::Option<bool>,
    pub overlapping: ::std::option::Option<bool>,
    pub deterministic: ::std::option::Option<bool>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl FractionalMaxPool {
    /// Creates a new `FractionalMaxPool`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fractional_max_pool with default options.
pub fn fractional_max_pool<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = FractionalMaxPool::new();
    fractional_max_pool_with_args(ctx, value, &__args)
}

/// fractional_max_pool with options.
pub fn fractional_max_pool_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
    __args: &FractionalMaxPool,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FractionalMaxPool")?;

    // Required input arguments
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.pooling_ratio {
        op.set_attr_float_list("pooling_ratio", value);
    }
    if let ::std::option::Option::Some(value) = &__args.pseudo_random {
        op.set_attr_bool("pseudo_random", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.overlapping {
        op.set_attr_bool("overlapping", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.deterministic {
        op.set_attr_bool("deterministic", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// FractionalMaxPoolGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FractionalMaxPoolGrad {
    pub overlapping: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl FractionalMaxPoolGrad {
    /// Creates a new `FractionalMaxPoolGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fractional_max_pool_grad with default options.
pub fn fractional_max_pool_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    out_backprop: T2,
    row_pooling_sequence: T3,
    col_pooling_sequence: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = FractionalMaxPoolGrad::new();
    fractional_max_pool_grad_with_args(
        ctx,
        orig_input,
        orig_output,
        out_backprop,
        row_pooling_sequence,
        col_pooling_sequence,
        &__args,
    )
}

/// fractional_max_pool_grad with options.
pub fn fractional_max_pool_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    out_backprop: T2,
    row_pooling_sequence: T3,
    col_pooling_sequence: T4,
    __args: &FractionalMaxPoolGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FractionalMaxPoolGrad")?;

    // Required input arguments
    op.add_input(&orig_input.to_handle()?)?;
    op.add_input(&orig_output.to_handle()?)?;
    op.add_input(&out_backprop.to_handle()?)?;
    op.add_input(&row_pooling_sequence.to_handle()?)?;
    op.add_input(&col_pooling_sequence.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.overlapping {
        op.set_attr_bool("overlapping", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FresnelCos
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FresnelCos {
    pub T: ::std::option::Option<crate::DataType>,
}

impl FresnelCos {
    /// Creates a new `FresnelCos`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fresnel_cos with default options.
pub fn fresnel_cos<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = FresnelCos::new();
    fresnel_cos_with_args(ctx, x, &__args)
}

/// fresnel_cos with options.
pub fn fresnel_cos_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &FresnelCos,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FresnelCos")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FresnelSin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FresnelSin {
    pub T: ::std::option::Option<crate::DataType>,
}

impl FresnelSin {
    /// Creates a new `FresnelSin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fresnel_sin with default options.
pub fn fresnel_sin<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = FresnelSin::new();
    fresnel_sin_with_args(ctx, x, &__args)
}

/// fresnel_sin with options.
pub fn fresnel_sin_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &FresnelSin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FresnelSin")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FusedBatchNorm
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedBatchNorm {
    pub T: ::std::option::Option<crate::DataType>,
    pub epsilon: ::std::option::Option<f32>,
    pub exponential_avg_factor: ::std::option::Option<f32>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub is_training: ::std::option::Option<bool>,
}

impl FusedBatchNorm {
    /// Creates a new `FusedBatchNorm`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fused_batch_norm with default options.
pub fn fused_batch_norm<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    scale: T1,
    offset: T2,
    mean: T3,
    variance: T4,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let __args = FusedBatchNorm::new();
    fused_batch_norm_with_args(ctx, x, scale, offset, mean, variance, &__args)
}

/// fused_batch_norm with options.
pub fn fused_batch_norm_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    scale: T1,
    offset: T2,
    mean: T3,
    variance: T4,
    __args: &FusedBatchNorm,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FusedBatchNorm")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&scale.to_handle()?)?;
    op.add_input(&offset.to_handle()?)?;
    op.add_input(&mean.to_handle()?)?;
    op.add_input(&variance.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.epsilon {
        op.set_attr_float("epsilon", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.exponential_avg_factor {
        op.set_attr_float("exponential_avg_factor", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_training {
        op.set_attr_bool("is_training", *value);
    }

    // Execute Op
    let mut num_output = 5;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 5];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// FusedBatchNormGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedBatchNormGrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub epsilon: ::std::option::Option<f32>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub is_training: ::std::option::Option<bool>,
}

impl FusedBatchNormGrad {
    /// Creates a new `FusedBatchNormGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fused_batch_norm_grad with default options.
pub fn fused_batch_norm_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    y_backprop: T0,
    x: T1,
    scale: T2,
    reserve_space_1: T3,
    reserve_space_2: T4,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let __args = FusedBatchNormGrad::new();
    fused_batch_norm_grad_with_args(
        ctx,
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        &__args,
    )
}

/// fused_batch_norm_grad with options.
pub fn fused_batch_norm_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    y_backprop: T0,
    x: T1,
    scale: T2,
    reserve_space_1: T3,
    reserve_space_2: T4,
    __args: &FusedBatchNormGrad,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FusedBatchNormGrad")?;

    // Required input arguments
    op.add_input(&y_backprop.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;
    op.add_input(&scale.to_handle()?)?;
    op.add_input(&reserve_space_1.to_handle()?)?;
    op.add_input(&reserve_space_2.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.epsilon {
        op.set_attr_float("epsilon", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_training {
        op.set_attr_bool("is_training", *value);
    }

    // Execute Op
    let mut num_output = 5;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 5];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// FusedBatchNormGradV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedBatchNormGradV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub U: ::std::option::Option<crate::DataType>,
    pub epsilon: ::std::option::Option<f32>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub is_training: ::std::option::Option<bool>,
}

impl FusedBatchNormGradV2 {
    /// Creates a new `FusedBatchNormGradV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fused_batch_norm_grad_v2 with default options.
pub fn fused_batch_norm_grad_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    y_backprop: T0,
    x: T1,
    scale: T2,
    reserve_space_1: T3,
    reserve_space_2: T4,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let __args = FusedBatchNormGradV2::new();
    fused_batch_norm_grad_v2_with_args(
        ctx,
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        &__args,
    )
}

/// fused_batch_norm_grad_v2 with options.
pub fn fused_batch_norm_grad_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    y_backprop: T0,
    x: T1,
    scale: T2,
    reserve_space_1: T3,
    reserve_space_2: T4,
    __args: &FusedBatchNormGradV2,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FusedBatchNormGradV2")?;

    // Required input arguments
    op.add_input(&y_backprop.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;
    op.add_input(&scale.to_handle()?)?;
    op.add_input(&reserve_space_1.to_handle()?)?;
    op.add_input(&reserve_space_2.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.U {
        op.set_attr_type("U", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.epsilon {
        op.set_attr_float("epsilon", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_training {
        op.set_attr_bool("is_training", *value);
    }

    // Execute Op
    let mut num_output = 5;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 5];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// FusedBatchNormGradV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedBatchNormGradV3 {
    pub T: ::std::option::Option<crate::DataType>,
    pub U: ::std::option::Option<crate::DataType>,
    pub epsilon: ::std::option::Option<f32>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub is_training: ::std::option::Option<bool>,
}

impl FusedBatchNormGradV3 {
    /// Creates a new `FusedBatchNormGradV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fused_batch_norm_grad_v3 with default options.
pub fn fused_batch_norm_grad_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    y_backprop: T0,
    x: T1,
    scale: T2,
    reserve_space_1: T3,
    reserve_space_2: T4,
    reserve_space_3: T5,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let __args = FusedBatchNormGradV3::new();
    fused_batch_norm_grad_v3_with_args(
        ctx,
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        reserve_space_3,
        &__args,
    )
}

/// fused_batch_norm_grad_v3 with options.
pub fn fused_batch_norm_grad_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    y_backprop: T0,
    x: T1,
    scale: T2,
    reserve_space_1: T3,
    reserve_space_2: T4,
    reserve_space_3: T5,
    __args: &FusedBatchNormGradV3,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FusedBatchNormGradV3")?;

    // Required input arguments
    op.add_input(&y_backprop.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;
    op.add_input(&scale.to_handle()?)?;
    op.add_input(&reserve_space_1.to_handle()?)?;
    op.add_input(&reserve_space_2.to_handle()?)?;
    op.add_input(&reserve_space_3.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.U {
        op.set_attr_type("U", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.epsilon {
        op.set_attr_float("epsilon", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_training {
        op.set_attr_bool("is_training", *value);
    }

    // Execute Op
    let mut num_output = 5;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 5];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// FusedBatchNormV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedBatchNormV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub U: ::std::option::Option<crate::DataType>,
    pub epsilon: ::std::option::Option<f32>,
    pub exponential_avg_factor: ::std::option::Option<f32>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub is_training: ::std::option::Option<bool>,
}

impl FusedBatchNormV2 {
    /// Creates a new `FusedBatchNormV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fused_batch_norm_v2 with default options.
pub fn fused_batch_norm_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    scale: T1,
    offset: T2,
    mean: T3,
    variance: T4,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let __args = FusedBatchNormV2::new();
    fused_batch_norm_v2_with_args(ctx, x, scale, offset, mean, variance, &__args)
}

/// fused_batch_norm_v2 with options.
pub fn fused_batch_norm_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    scale: T1,
    offset: T2,
    mean: T3,
    variance: T4,
    __args: &FusedBatchNormV2,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FusedBatchNormV2")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&scale.to_handle()?)?;
    op.add_input(&offset.to_handle()?)?;
    op.add_input(&mean.to_handle()?)?;
    op.add_input(&variance.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.U {
        op.set_attr_type("U", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.epsilon {
        op.set_attr_float("epsilon", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.exponential_avg_factor {
        op.set_attr_float("exponential_avg_factor", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_training {
        op.set_attr_bool("is_training", *value);
    }

    // Execute Op
    let mut num_output = 5;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 5];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// FusedBatchNormV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedBatchNormV3 {
    pub T: ::std::option::Option<crate::DataType>,
    pub U: ::std::option::Option<crate::DataType>,
    pub epsilon: ::std::option::Option<f32>,
    pub exponential_avg_factor: ::std::option::Option<f32>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub is_training: ::std::option::Option<bool>,
}

impl FusedBatchNormV3 {
    /// Creates a new `FusedBatchNormV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fused_batch_norm_v3 with default options.
pub fn fused_batch_norm_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    scale: T1,
    offset: T2,
    mean: T3,
    variance: T4,
) -> Result<[crate::eager::TensorHandle; 6]> {
    let __args = FusedBatchNormV3::new();
    fused_batch_norm_v3_with_args(ctx, x, scale, offset, mean, variance, &__args)
}

/// fused_batch_norm_v3 with options.
pub fn fused_batch_norm_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    scale: T1,
    offset: T2,
    mean: T3,
    variance: T4,
    __args: &FusedBatchNormV3,
) -> Result<[crate::eager::TensorHandle; 6]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FusedBatchNormV3")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&scale.to_handle()?)?;
    op.add_input(&offset.to_handle()?)?;
    op.add_input(&mean.to_handle()?)?;
    op.add_input(&variance.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.U {
        op.set_attr_type("U", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.epsilon {
        op.set_attr_float("epsilon", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.exponential_avg_factor {
        op.set_attr_float("exponential_avg_factor", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_training {
        op.set_attr_bool("is_training", *value);
    }

    // Execute Op
    let mut num_output = 6;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 6];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// FusedPadConv2D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedPadConv2D {
    pub T: ::std::option::Option<crate::DataType>,
    pub mode: ::std::option::Option<::std::string::String>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
}

impl FusedPadConv2D {
    /// Creates a new `FusedPadConv2D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fused_pad_conv2_d with default options.
pub fn fused_pad_conv2_d<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
    filter: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = FusedPadConv2D::new();
    fused_pad_conv2_d_with_args(ctx, input, paddings, filter, &__args)
}

/// fused_pad_conv2_d with options.
pub fn fused_pad_conv2_d_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
    filter: T2,
    __args: &FusedPadConv2D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FusedPadConv2D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&paddings.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.mode {
        op.set_attr_string("mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// FusedResizeAndPadConv2D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedResizeAndPadConv2D {
    pub T: ::std::option::Option<crate::DataType>,
    pub resize_align_corners: ::std::option::Option<bool>,
    pub mode: ::std::option::Option<::std::string::String>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
}

impl FusedResizeAndPadConv2D {
    /// Creates a new `FusedResizeAndPadConv2D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// fused_resize_and_pad_conv2_d with default options.
pub fn fused_resize_and_pad_conv2_d<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    size: T1,
    paddings: T2,
    filter: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = FusedResizeAndPadConv2D::new();
    fused_resize_and_pad_conv2_d_with_args(ctx, input, size, paddings, filter, &__args)
}

/// fused_resize_and_pad_conv2_d with options.
pub fn fused_resize_and_pad_conv2_d_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    size: T1,
    paddings: T2,
    filter: T3,
    __args: &FusedResizeAndPadConv2D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "FusedResizeAndPadConv2D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;
    op.add_input(&paddings.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.resize_align_corners {
        op.set_attr_bool("resize_align_corners", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.mode {
        op.set_attr_string("mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// GRUBlockCell
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GRUBlockCell {
    pub T: ::std::option::Option<crate::DataType>,
}

impl GRUBlockCell {
    /// Creates a new `GRUBlockCell`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// grublock_cell with default options.
pub fn grublock_cell<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    h_prev: T1,
    w_ru: T2,
    w_c: T3,
    b_ru: T4,
    b_c: T5,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = GRUBlockCell::new();
    grublock_cell_with_args(ctx, x, h_prev, w_ru, w_c, b_ru, b_c, &__args)
}

/// grublock_cell with options.
pub fn grublock_cell_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    h_prev: T1,
    w_ru: T2,
    w_c: T3,
    b_ru: T4,
    b_c: T5,
    __args: &GRUBlockCell,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GRUBlockCell")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&h_prev.to_handle()?)?;
    op.add_input(&w_ru.to_handle()?)?;
    op.add_input(&w_c.to_handle()?)?;
    op.add_input(&b_ru.to_handle()?)?;
    op.add_input(&b_c.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// GRUBlockCellGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GRUBlockCellGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl GRUBlockCellGrad {
    /// Creates a new `GRUBlockCellGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// grublock_cell_grad with default options.
pub fn grublock_cell_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    h_prev: T1,
    w_ru: T2,
    w_c: T3,
    b_ru: T4,
    b_c: T5,
    r: T6,
    u: T7,
    c: T8,
    d_h: T9,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = GRUBlockCellGrad::new();
    grublock_cell_grad_with_args(ctx, x, h_prev, w_ru, w_c, b_ru, b_c, r, u, c, d_h, &__args)
}

/// grublock_cell_grad with options.
pub fn grublock_cell_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    h_prev: T1,
    w_ru: T2,
    w_c: T3,
    b_ru: T4,
    b_c: T5,
    r: T6,
    u: T7,
    c: T8,
    d_h: T9,
    __args: &GRUBlockCellGrad,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GRUBlockCellGrad")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&h_prev.to_handle()?)?;
    op.add_input(&w_ru.to_handle()?)?;
    op.add_input(&w_c.to_handle()?)?;
    op.add_input(&b_ru.to_handle()?)?;
    op.add_input(&b_c.to_handle()?)?;
    op.add_input(&r.to_handle()?)?;
    op.add_input(&u.to_handle()?)?;
    op.add_input(&c.to_handle()?)?;
    op.add_input(&d_h.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Gather
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Gather {
    pub validate_indices: ::std::option::Option<bool>,
    pub Tparams: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl Gather {
    /// Creates a new `Gather`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// gather with default options.
pub fn gather<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    params: T0,
    indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Gather::new();
    gather_with_args(ctx, params, indices, &__args)
}

/// gather with options.
pub fn gather_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    params: T0,
    indices: T1,
    __args: &Gather,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Gather")?;

    // Required input arguments
    op.add_input(&params.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.validate_indices {
        op.set_attr_bool("validate_indices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tparams {
        op.set_attr_type("Tparams", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// GatherNd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GatherNd {
    pub Tparams: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl GatherNd {
    /// Creates a new `GatherNd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// gather_nd with default options.
pub fn gather_nd<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    params: T0,
    indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = GatherNd::new();
    gather_nd_with_args(ctx, params, indices, &__args)
}

/// gather_nd with options.
pub fn gather_nd_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    params: T0,
    indices: T1,
    __args: &GatherNd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GatherNd")?;

    // Required input arguments
    op.add_input(&params.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tparams {
        op.set_attr_type("Tparams", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// GatherV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GatherV2 {
    pub batch_dims: ::std::option::Option<i64>,
    pub Tparams: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub Taxis: ::std::option::Option<crate::DataType>,
}

impl GatherV2 {
    /// Creates a new `GatherV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// gather_v2 with default options.
pub fn gather_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    params: T0,
    indices: T1,
    axis: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = GatherV2::new();
    gather_v2_with_args(ctx, params, indices, axis, &__args)
}

/// gather_v2 with options.
pub fn gather_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    params: T0,
    indices: T1,
    axis: T2,
    __args: &GatherV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GatherV2")?;

    // Required input arguments
    op.add_input(&params.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.batch_dims {
        op.set_attr_int("batch_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tparams {
        op.set_attr_type("Tparams", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Taxis {
        op.set_attr_type("Taxis", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// GenerateBoundingBoxProposals
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GenerateBoundingBoxProposals {
    pub post_nms_topn: ::std::option::Option<i64>,
}

impl GenerateBoundingBoxProposals {
    /// Creates a new `GenerateBoundingBoxProposals`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// generate_bounding_box_proposals with default options.
pub fn generate_bounding_box_proposals<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    scores: T0,
    bbox_deltas: T1,
    image_info: T2,
    anchors: T3,
    nms_threshold: T4,
    pre_nms_topn: T5,
    min_size: T6,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = GenerateBoundingBoxProposals::new();
    generate_bounding_box_proposals_with_args(
        ctx,
        scores,
        bbox_deltas,
        image_info,
        anchors,
        nms_threshold,
        pre_nms_topn,
        min_size,
        &__args,
    )
}

/// generate_bounding_box_proposals with options.
pub fn generate_bounding_box_proposals_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    scores: T0,
    bbox_deltas: T1,
    image_info: T2,
    anchors: T3,
    nms_threshold: T4,
    pre_nms_topn: T5,
    min_size: T6,
    __args: &GenerateBoundingBoxProposals,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GenerateBoundingBoxProposals")?;

    // Required input arguments
    op.add_input(&scores.to_handle()?)?;
    op.add_input(&bbox_deltas.to_handle()?)?;
    op.add_input(&image_info.to_handle()?)?;
    op.add_input(&anchors.to_handle()?)?;
    op.add_input(&nms_threshold.to_handle()?)?;
    op.add_input(&pre_nms_topn.to_handle()?)?;
    op.add_input(&min_size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.post_nms_topn {
        op.set_attr_int("post_nms_topn", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// GenerateVocabRemapping
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GenerateVocabRemapping {
    pub new_vocab_offset: ::std::option::Option<i64>,
    pub num_new_vocab: ::std::option::Option<i64>,
    pub old_vocab_size: ::std::option::Option<i64>,
}

impl GenerateVocabRemapping {
    /// Creates a new `GenerateVocabRemapping`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// generate_vocab_remapping with default options.
pub fn generate_vocab_remapping<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    new_vocab_file: T0,
    old_vocab_file: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = GenerateVocabRemapping::new();
    generate_vocab_remapping_with_args(ctx, new_vocab_file, old_vocab_file, &__args)
}

/// generate_vocab_remapping with options.
pub fn generate_vocab_remapping_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    new_vocab_file: T0,
    old_vocab_file: T1,
    __args: &GenerateVocabRemapping,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GenerateVocabRemapping")?;

    // Required input arguments
    op.add_input(&new_vocab_file.to_handle()?)?;
    op.add_input(&old_vocab_file.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.new_vocab_offset {
        op.set_attr_int("new_vocab_offset", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_new_vocab {
        op.set_attr_int("num_new_vocab", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.old_vocab_size {
        op.set_attr_int("old_vocab_size", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// GeneratorDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GeneratorDataset {
    pub init_func: ::std::option::Option<::std::string::String>,
    pub next_func: ::std::option::Option<::std::string::String>,
    pub finalize_func: ::std::option::Option<::std::string::String>,
    pub Tinit_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tnext_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tfinalize_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl GeneratorDataset {
    /// Creates a new `GeneratorDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// generator_dataset with default options.
pub fn generator_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    init_func_other_args: T0,
    next_func_other_args: T1,
    finalize_func_other_args: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = GeneratorDataset::new();
    generator_dataset_with_args(
        ctx,
        init_func_other_args,
        next_func_other_args,
        finalize_func_other_args,
        &__args,
    )
}

/// generator_dataset with options.
pub fn generator_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    init_func_other_args: T0,
    next_func_other_args: T1,
    finalize_func_other_args: T2,
    __args: &GeneratorDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GeneratorDataset")?;

    // Required input arguments
    op.add_input(&init_func_other_args.to_handle()?)?;
    op.add_input(&next_func_other_args.to_handle()?)?;
    op.add_input(&finalize_func_other_args.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.init_func {
        op.set_attr_string("init_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.next_func {
        op.set_attr_string("next_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.finalize_func {
        op.set_attr_string("finalize_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tinit_func_args {
        op.set_attr_type_list("Tinit_func_args", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tnext_func_args {
        op.set_attr_type_list("Tnext_func_args", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfinalize_func_args {
        op.set_attr_type_list("Tfinalize_func_args", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// GetOptions
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GetOptions {}

impl GetOptions {
    /// Creates a new `GetOptions`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// get_options with default options.
pub fn get_options<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = GetOptions::new();
    get_options_with_args(ctx, input_dataset, &__args)
}

/// get_options with options.
pub fn get_options_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &GetOptions,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GetOptions")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// GetSessionHandle
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GetSessionHandle {
    pub T: ::std::option::Option<crate::DataType>,
}

impl GetSessionHandle {
    /// Creates a new `GetSessionHandle`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// get_session_handle with default options.
pub fn get_session_handle<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = GetSessionHandle::new();
    get_session_handle_with_args(ctx, value, &__args)
}

/// get_session_handle with options.
pub fn get_session_handle_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
    __args: &GetSessionHandle,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GetSessionHandle")?;

    // Required input arguments
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// GetSessionHandleV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GetSessionHandleV2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl GetSessionHandleV2 {
    /// Creates a new `GetSessionHandleV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// get_session_handle_v2 with default options.
pub fn get_session_handle_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = GetSessionHandleV2::new();
    get_session_handle_v2_with_args(ctx, value, &__args)
}

/// get_session_handle_v2 with options.
pub fn get_session_handle_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
    __args: &GetSessionHandleV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GetSessionHandleV2")?;

    // Required input arguments
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// GetSessionTensor
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GetSessionTensor {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl GetSessionTensor {
    /// Creates a new `GetSessionTensor`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// get_session_tensor with default options.
pub fn get_session_tensor<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = GetSessionTensor::new();
    get_session_tensor_with_args(ctx, handle, &__args)
}

/// get_session_tensor with options.
pub fn get_session_tensor_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &GetSessionTensor,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GetSessionTensor")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Greater
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Greater {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Greater {
    /// Creates a new `Greater`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// greater with default options.
pub fn greater<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Greater::new();
    greater_with_args(ctx, x, y, &__args)
}

/// greater with options.
pub fn greater_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Greater,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Greater")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// GreaterEqual
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GreaterEqual {
    pub T: ::std::option::Option<crate::DataType>,
}

impl GreaterEqual {
    /// Creates a new `GreaterEqual`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// greater_equal with default options.
pub fn greater_equal<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = GreaterEqual::new();
    greater_equal_with_args(ctx, x, y, &__args)
}

/// greater_equal with options.
pub fn greater_equal_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &GreaterEqual,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GreaterEqual")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// GroupByReducerDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GroupByReducerDataset {
    pub key_func: ::std::option::Option<::std::string::String>,
    pub init_func: ::std::option::Option<::std::string::String>,
    pub reduce_func: ::std::option::Option<::std::string::String>,
    pub finalize_func: ::std::option::Option<::std::string::String>,
    pub Tkey_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tinit_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Treduce_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tfinalize_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl GroupByReducerDataset {
    /// Creates a new `GroupByReducerDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// group_by_reducer_dataset with default options.
pub fn group_by_reducer_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    key_func_other_arguments: T1,
    init_func_other_arguments: T2,
    reduce_func_other_arguments: T3,
    finalize_func_other_arguments: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = GroupByReducerDataset::new();
    group_by_reducer_dataset_with_args(
        ctx,
        input_dataset,
        key_func_other_arguments,
        init_func_other_arguments,
        reduce_func_other_arguments,
        finalize_func_other_arguments,
        &__args,
    )
}

/// group_by_reducer_dataset with options.
pub fn group_by_reducer_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    key_func_other_arguments: T1,
    init_func_other_arguments: T2,
    reduce_func_other_arguments: T3,
    finalize_func_other_arguments: T4,
    __args: &GroupByReducerDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GroupByReducerDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&key_func_other_arguments.to_handle()?)?;
    op.add_input(&init_func_other_arguments.to_handle()?)?;
    op.add_input(&reduce_func_other_arguments.to_handle()?)?;
    op.add_input(&finalize_func_other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.key_func {
        op.set_attr_string("key_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.init_func {
        op.set_attr_string("init_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.reduce_func {
        op.set_attr_string("reduce_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.finalize_func {
        op.set_attr_string("finalize_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tkey_func_other_arguments {
        op.set_attr_type_list("Tkey_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tinit_func_other_arguments {
        op.set_attr_type_list("Tinit_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Treduce_func_other_arguments {
        op.set_attr_type_list("Treduce_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfinalize_func_other_arguments {
        op.set_attr_type_list("Tfinalize_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// GroupByWindowDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GroupByWindowDataset {
    pub key_func: ::std::option::Option<::std::string::String>,
    pub reduce_func: ::std::option::Option<::std::string::String>,
    pub window_size_func: ::std::option::Option<::std::string::String>,
    pub Tkey_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Treduce_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Twindow_size_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl GroupByWindowDataset {
    /// Creates a new `GroupByWindowDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// group_by_window_dataset with default options.
pub fn group_by_window_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    key_func_other_arguments: T1,
    reduce_func_other_arguments: T2,
    window_size_func_other_arguments: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = GroupByWindowDataset::new();
    group_by_window_dataset_with_args(
        ctx,
        input_dataset,
        key_func_other_arguments,
        reduce_func_other_arguments,
        window_size_func_other_arguments,
        &__args,
    )
}

/// group_by_window_dataset with options.
pub fn group_by_window_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    key_func_other_arguments: T1,
    reduce_func_other_arguments: T2,
    window_size_func_other_arguments: T3,
    __args: &GroupByWindowDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GroupByWindowDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&key_func_other_arguments.to_handle()?)?;
    op.add_input(&reduce_func_other_arguments.to_handle()?)?;
    op.add_input(&window_size_func_other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.key_func {
        op.set_attr_string("key_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.reduce_func {
        op.set_attr_string("reduce_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.window_size_func {
        op.set_attr_string("window_size_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tkey_func_other_arguments {
        op.set_attr_type_list("Tkey_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Treduce_func_other_arguments {
        op.set_attr_type_list("Treduce_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Twindow_size_func_other_arguments {
        op.set_attr_type_list("Twindow_size_func_other_arguments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// GuaranteeConst
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GuaranteeConst {
    pub T: ::std::option::Option<crate::DataType>,
}

impl GuaranteeConst {
    /// Creates a new `GuaranteeConst`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// guarantee_const with default options.
pub fn guarantee_const<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = GuaranteeConst::new();
    guarantee_const_with_args(ctx, input, &__args)
}

/// guarantee_const with options.
pub fn guarantee_const_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &GuaranteeConst,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "GuaranteeConst")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// HSVToRGB
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct HSVToRGB {
    pub T: ::std::option::Option<crate::DataType>,
}

impl HSVToRGB {
    /// Creates a new `HSVToRGB`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// hsvto_rgb with default options.
pub fn hsvto_rgb<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = HSVToRGB::new();
    hsvto_rgb_with_args(ctx, images, &__args)
}

/// hsvto_rgb with options.
pub fn hsvto_rgb_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    __args: &HSVToRGB,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "HSVToRGB")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// HashTable
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct HashTable {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub use_node_name_sharing: ::std::option::Option<bool>,
    pub key_dtype: ::std::option::Option<crate::DataType>,
    pub value_dtype: ::std::option::Option<crate::DataType>,
}

impl HashTable {
    /// Creates a new `HashTable`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// hash_table with default options.
pub fn hash_table(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = HashTable::new();
    hash_table_with_args(ctx, &__args)
}

/// hash_table with options.
pub fn hash_table_with_args(
    ctx: &crate::eager::Context,
    __args: &HashTable,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "HashTable")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_node_name_sharing {
        op.set_attr_bool("use_node_name_sharing", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_dtype {
        op.set_attr_type("value_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// HashTableV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct HashTableV2 {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub use_node_name_sharing: ::std::option::Option<bool>,
    pub key_dtype: ::std::option::Option<crate::DataType>,
    pub value_dtype: ::std::option::Option<crate::DataType>,
}

impl HashTableV2 {
    /// Creates a new `HashTableV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// hash_table_v2 with default options.
pub fn hash_table_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = HashTableV2::new();
    hash_table_v2_with_args(ctx, &__args)
}

/// hash_table_v2 with options.
pub fn hash_table_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &HashTableV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "HashTableV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_node_name_sharing {
        op.set_attr_bool("use_node_name_sharing", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_dtype {
        op.set_attr_type("value_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// HistogramFixedWidth
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct HistogramFixedWidth {
    pub T: ::std::option::Option<crate::DataType>,
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl HistogramFixedWidth {
    /// Creates a new `HistogramFixedWidth`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// histogram_fixed_width with default options.
pub fn histogram_fixed_width<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    values: T0,
    value_range: T1,
    nbins: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = HistogramFixedWidth::new();
    histogram_fixed_width_with_args(ctx, values, value_range, nbins, &__args)
}

/// histogram_fixed_width with options.
pub fn histogram_fixed_width_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    values: T0,
    value_range: T1,
    nbins: T2,
    __args: &HistogramFixedWidth,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "HistogramFixedWidth")?;

    // Required input arguments
    op.add_input(&values.to_handle()?)?;
    op.add_input(&value_range.to_handle()?)?;
    op.add_input(&nbins.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// HistogramSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct HistogramSummary {
    pub T: ::std::option::Option<crate::DataType>,
}

impl HistogramSummary {
    /// Creates a new `HistogramSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// histogram_summary with default options.
pub fn histogram_summary<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tag: T0,
    values: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = HistogramSummary::new();
    histogram_summary_with_args(ctx, tag, values, &__args)
}

/// histogram_summary with options.
pub fn histogram_summary_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tag: T0,
    values: T1,
    __args: &HistogramSummary,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "HistogramSummary")?;

    // Required input arguments
    op.add_input(&tag.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// HostConst
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct HostConst {
    value: ::std::option::Option<::std::boxed::Box<dyn crate::AnyTensor>>,
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl HostConst {
    /// Creates a new `HostConst`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// host_const with default options.
pub fn host_const(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = HostConst::new();
    host_const_with_args(ctx, &__args)
}

/// host_const with options.
pub fn host_const_with_args(
    ctx: &crate::eager::Context,
    __args: &HostConst,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "HostConst")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.value {
        op.set_attr_any_tensor("value", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IFFT
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IFFT {
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl IFFT {
    /// Creates a new `IFFT`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ifft with default options.
pub fn ifft<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IFFT::new();
    ifft_with_args(ctx, input, &__args)
}

/// ifft with options.
pub fn ifft_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &IFFT,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IFFT")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IFFT2D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IFFT2D {
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl IFFT2D {
    /// Creates a new `IFFT2D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ifft2_d with default options.
pub fn ifft2_d<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IFFT2D::new();
    ifft2_d_with_args(ctx, input, &__args)
}

/// ifft2_d with options.
pub fn ifft2_d_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &IFFT2D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IFFT2D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IFFT3D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IFFT3D {
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl IFFT3D {
    /// Creates a new `IFFT3D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ifft3_d with default options.
pub fn ifft3_d<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IFFT3D::new();
    ifft3_d_with_args(ctx, input, &__args)
}

/// ifft3_d with options.
pub fn ifft3_d_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &IFFT3D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IFFT3D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IRFFT
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IRFFT {
    pub Treal: ::std::option::Option<crate::DataType>,
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl IRFFT {
    /// Creates a new `IRFFT`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// irfft with default options.
pub fn irfft<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    fft_length: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = IRFFT::new();
    irfft_with_args(ctx, input, fft_length, &__args)
}

/// irfft with options.
pub fn irfft_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    fft_length: T1,
    __args: &IRFFT,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IRFFT")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&fft_length.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Treal {
        op.set_attr_type("Treal", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IRFFT2D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IRFFT2D {
    pub Treal: ::std::option::Option<crate::DataType>,
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl IRFFT2D {
    /// Creates a new `IRFFT2D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// irfft2_d with default options.
pub fn irfft2_d<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    fft_length: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = IRFFT2D::new();
    irfft2_d_with_args(ctx, input, fft_length, &__args)
}

/// irfft2_d with options.
pub fn irfft2_d_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    fft_length: T1,
    __args: &IRFFT2D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IRFFT2D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&fft_length.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Treal {
        op.set_attr_type("Treal", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IRFFT3D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IRFFT3D {
    pub Treal: ::std::option::Option<crate::DataType>,
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl IRFFT3D {
    /// Creates a new `IRFFT3D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// irfft3_d with default options.
pub fn irfft3_d<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    fft_length: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = IRFFT3D::new();
    irfft3_d_with_args(ctx, input, fft_length, &__args)
}

/// irfft3_d with options.
pub fn irfft3_d_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    fft_length: T1,
    __args: &IRFFT3D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IRFFT3D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&fft_length.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Treal {
        op.set_attr_type("Treal", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Identity
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Identity {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Identity {
    /// Creates a new `Identity`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// identity with default options.
pub fn identity<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Identity::new();
    identity_with_args(ctx, input, &__args)
}

/// identity with options.
pub fn identity_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Identity,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Identity")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IdentityN
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IdentityN {
    pub T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl IdentityN {
    /// Creates a new `IdentityN`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// identity_n with default options.
pub fn identity_n<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IdentityN::new();
    identity_n_with_args(ctx, input, &__args)
}

/// identity_n with options.
pub fn identity_n_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &IdentityN,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IdentityN")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type_list("T", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IdentityReader
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IdentityReader {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl IdentityReader {
    /// Creates a new `IdentityReader`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// identity_reader with default options.
pub fn identity_reader(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = IdentityReader::new();
    identity_reader_with_args(ctx, &__args)
}

/// identity_reader with options.
pub fn identity_reader_with_args(
    ctx: &crate::eager::Context,
    __args: &IdentityReader,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IdentityReader")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IdentityReaderV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IdentityReaderV2 {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl IdentityReaderV2 {
    /// Creates a new `IdentityReaderV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// identity_reader_v2 with default options.
pub fn identity_reader_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = IdentityReaderV2::new();
    identity_reader_v2_with_args(ctx, &__args)
}

/// identity_reader_v2 with options.
pub fn identity_reader_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &IdentityReaderV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IdentityReaderV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// If
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct If {
    pub Tcond: ::std::option::Option<crate::DataType>,
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub then_branch: ::std::option::Option<::std::string::String>,
    pub else_branch: ::std::option::Option<::std::string::String>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl If {
    /// Creates a new `If`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// if_ with default options.
pub fn if_<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    cond: T0,
    input: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = If::new();
    if__with_args(ctx, cond, input, &__args)
}

/// if_ with options.
pub fn if__with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    cond: T0,
    input: T1,
    __args: &If,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "If")?;

    // Required input arguments
    op.add_input(&cond.to_handle()?)?;
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcond {
        op.set_attr_type("Tcond", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }
    if let ::std::option::Option::Some(value) = &__args.then_branch {
        op.set_attr_string("then_branch", value);
    }
    if let ::std::option::Option::Some(value) = &__args.else_branch {
        op.set_attr_string("else_branch", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Igamma
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Igamma {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Igamma {
    /// Creates a new `Igamma`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// igamma with default options.
pub fn igamma<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    x: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Igamma::new();
    igamma_with_args(ctx, a, x, &__args)
}

/// igamma with options.
pub fn igamma_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    x: T1,
    __args: &Igamma,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Igamma")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IgammaGradA
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IgammaGradA {
    pub T: ::std::option::Option<crate::DataType>,
}

impl IgammaGradA {
    /// Creates a new `IgammaGradA`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// igamma_grad_a with default options.
pub fn igamma_grad_a<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    x: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = IgammaGradA::new();
    igamma_grad_a_with_args(ctx, a, x, &__args)
}

/// igamma_grad_a with options.
pub fn igamma_grad_a_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    x: T1,
    __args: &IgammaGradA,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IgammaGradA")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Igammac
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Igammac {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Igammac {
    /// Creates a new `Igammac`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// igammac with default options.
pub fn igammac<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    x: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Igammac::new();
    igammac_with_args(ctx, a, x, &__args)
}

/// igammac with options.
pub fn igammac_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    x: T1,
    __args: &Igammac,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Igammac")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IgnoreErrorsDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IgnoreErrorsDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub log_warning: ::std::option::Option<bool>,
}

impl IgnoreErrorsDataset {
    /// Creates a new `IgnoreErrorsDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ignore_errors_dataset with default options.
pub fn ignore_errors_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IgnoreErrorsDataset::new();
    ignore_errors_dataset_with_args(ctx, input_dataset, &__args)
}

/// ignore_errors_dataset with options.
pub fn ignore_errors_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &IgnoreErrorsDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IgnoreErrorsDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.log_warning {
        op.set_attr_bool("log_warning", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Imag
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Imag {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl Imag {
    /// Creates a new `Imag`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// imag with default options.
pub fn imag<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Imag::new();
    imag_with_args(ctx, input, &__args)
}

/// imag with options.
pub fn imag_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Imag,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Imag")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ImageProjectiveTransformV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ImageProjectiveTransformV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub interpolation: ::std::option::Option<::std::string::String>,
    pub fill_mode: ::std::option::Option<::std::string::String>,
}

impl ImageProjectiveTransformV2 {
    /// Creates a new `ImageProjectiveTransformV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// image_projective_transform_v2 with default options.
pub fn image_projective_transform_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    transforms: T1,
    output_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ImageProjectiveTransformV2::new();
    image_projective_transform_v2_with_args(ctx, images, transforms, output_shape, &__args)
}

/// image_projective_transform_v2 with options.
pub fn image_projective_transform_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    transforms: T1,
    output_shape: T2,
    __args: &ImageProjectiveTransformV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ImageProjectiveTransformV2")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&transforms.to_handle()?)?;
    op.add_input(&output_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.interpolation {
        op.set_attr_string("interpolation", value);
    }
    if let ::std::option::Option::Some(value) = &__args.fill_mode {
        op.set_attr_string("fill_mode", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ImageProjectiveTransformV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ImageProjectiveTransformV3 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub interpolation: ::std::option::Option<::std::string::String>,
    pub fill_mode: ::std::option::Option<::std::string::String>,
}

impl ImageProjectiveTransformV3 {
    /// Creates a new `ImageProjectiveTransformV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// image_projective_transform_v3 with default options.
pub fn image_projective_transform_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    transforms: T1,
    output_shape: T2,
    fill_value: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = ImageProjectiveTransformV3::new();
    image_projective_transform_v3_with_args(
        ctx,
        images,
        transforms,
        output_shape,
        fill_value,
        &__args,
    )
}

/// image_projective_transform_v3 with options.
pub fn image_projective_transform_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    transforms: T1,
    output_shape: T2,
    fill_value: T3,
    __args: &ImageProjectiveTransformV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ImageProjectiveTransformV3")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&transforms.to_handle()?)?;
    op.add_input(&output_shape.to_handle()?)?;
    op.add_input(&fill_value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.interpolation {
        op.set_attr_string("interpolation", value);
    }
    if let ::std::option::Option::Some(value) = &__args.fill_mode {
        op.set_attr_string("fill_mode", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ImageSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ImageSummary {
    pub max_images: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    bad_color: ::std::option::Option<::std::boxed::Box<dyn crate::AnyTensor>>,
}

impl ImageSummary {
    /// Creates a new `ImageSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// image_summary with default options.
pub fn image_summary<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tag: T0,
    tensor: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ImageSummary::new();
    image_summary_with_args(ctx, tag, tensor, &__args)
}

/// image_summary with options.
pub fn image_summary_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tag: T0,
    tensor: T1,
    __args: &ImageSummary,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ImageSummary")?;

    // Required input arguments
    op.add_input(&tag.to_handle()?)?;
    op.add_input(&tensor.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.max_images {
        op.set_attr_int("max_images", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.bad_color {
        op.set_attr_any_tensor("bad_color", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ImmutableConst
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ImmutableConst {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
    pub memory_region_name: ::std::option::Option<::std::string::String>,
}

impl ImmutableConst {
    /// Creates a new `ImmutableConst`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// immutable_const with default options.
pub fn immutable_const(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = ImmutableConst::new();
    immutable_const_with_args(ctx, &__args)
}

/// immutable_const with options.
pub fn immutable_const_with_args(
    ctx: &crate::eager::Context,
    __args: &ImmutableConst,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ImmutableConst")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.memory_region_name {
        op.set_attr_string("memory_region_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ImportEvent
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ImportEvent {}

impl ImportEvent {
    /// Creates a new `ImportEvent`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// import_event with default options.
pub fn import_event<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    writer: T0,
    event: T1,
) -> Result<()> {
    let __args = ImportEvent::new();
    import_event_with_args(ctx, writer, event, &__args)
}

/// import_event with options.
pub fn import_event_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    writer: T0,
    event: T1,
    __args: &ImportEvent,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ImportEvent")?;

    // Required input arguments
    op.add_input(&writer.to_handle()?)?;
    op.add_input(&event.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// InTopK
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InTopK {
    pub k: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl InTopK {
    /// Creates a new `InTopK`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// in_top_k with default options.
pub fn in_top_k<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    predictions: T0,
    targets: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = InTopK::new();
    in_top_k_with_args(ctx, predictions, targets, &__args)
}

/// in_top_k with options.
pub fn in_top_k_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    predictions: T0,
    targets: T1,
    __args: &InTopK,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InTopK")?;

    // Required input arguments
    op.add_input(&predictions.to_handle()?)?;
    op.add_input(&targets.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.k {
        op.set_attr_int("k", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// InTopKV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InTopKV2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl InTopKV2 {
    /// Creates a new `InTopKV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// in_top_kv2 with default options.
pub fn in_top_kv2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    predictions: T0,
    targets: T1,
    k: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = InTopKV2::new();
    in_top_kv2_with_args(ctx, predictions, targets, k, &__args)
}

/// in_top_kv2 with options.
pub fn in_top_kv2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    predictions: T0,
    targets: T1,
    k: T2,
    __args: &InTopKV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InTopKV2")?;

    // Required input arguments
    op.add_input(&predictions.to_handle()?)?;
    op.add_input(&targets.to_handle()?)?;
    op.add_input(&k.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// InfeedDequeue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InfeedDequeue {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
}

impl InfeedDequeue {
    /// Creates a new `InfeedDequeue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// infeed_dequeue with default options.
pub fn infeed_dequeue(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = InfeedDequeue::new();
    infeed_dequeue_with_args(ctx, &__args)
}

/// infeed_dequeue with options.
pub fn infeed_dequeue_with_args(
    ctx: &crate::eager::Context,
    __args: &InfeedDequeue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InfeedDequeue")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// InfeedDequeueTuple
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InfeedDequeueTuple {
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl InfeedDequeueTuple {
    /// Creates a new `InfeedDequeueTuple`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// infeed_dequeue_tuple with default options.
pub fn infeed_dequeue_tuple(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = InfeedDequeueTuple::new();
    infeed_dequeue_tuple_with_args(ctx, &__args)
}

/// infeed_dequeue_tuple with options.
pub fn infeed_dequeue_tuple_with_args(
    ctx: &crate::eager::Context,
    __args: &InfeedDequeueTuple,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InfeedDequeueTuple")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// InfeedEnqueue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InfeedEnqueue {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
    pub layout: ::std::option::Option<::std::vec::Vec<i64>>,
    pub device_ordinal: ::std::option::Option<i64>,
}

impl InfeedEnqueue {
    /// Creates a new `InfeedEnqueue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// infeed_enqueue with default options.
pub fn infeed_enqueue<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<()> {
    let __args = InfeedEnqueue::new();
    infeed_enqueue_with_args(ctx, input, &__args)
}

/// infeed_enqueue with options.
pub fn infeed_enqueue_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &InfeedEnqueue,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InfeedEnqueue")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.layout {
        op.set_attr_int_list("layout", value);
    }
    if let ::std::option::Option::Some(value) = &__args.device_ordinal {
        op.set_attr_int("device_ordinal", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// InfeedEnqueuePrelinearizedBuffer
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InfeedEnqueuePrelinearizedBuffer {
    pub device_ordinal: ::std::option::Option<i64>,
}

impl InfeedEnqueuePrelinearizedBuffer {
    /// Creates a new `InfeedEnqueuePrelinearizedBuffer`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// infeed_enqueue_prelinearized_buffer with default options.
pub fn infeed_enqueue_prelinearized_buffer<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<()> {
    let __args = InfeedEnqueuePrelinearizedBuffer::new();
    infeed_enqueue_prelinearized_buffer_with_args(ctx, input, &__args)
}

/// infeed_enqueue_prelinearized_buffer with options.
pub fn infeed_enqueue_prelinearized_buffer_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &InfeedEnqueuePrelinearizedBuffer,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InfeedEnqueuePrelinearizedBuffer")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.device_ordinal {
        op.set_attr_int("device_ordinal", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// InfeedEnqueueTuple
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InfeedEnqueueTuple {
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub layouts: ::std::option::Option<::std::vec::Vec<i64>>,
    pub device_ordinal: ::std::option::Option<i64>,
}

impl InfeedEnqueueTuple {
    /// Creates a new `InfeedEnqueueTuple`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// infeed_enqueue_tuple with default options.
pub fn infeed_enqueue_tuple<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<()> {
    let __args = InfeedEnqueueTuple::new();
    infeed_enqueue_tuple_with_args(ctx, inputs, &__args)
}

/// infeed_enqueue_tuple with options.
pub fn infeed_enqueue_tuple_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &InfeedEnqueueTuple,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InfeedEnqueueTuple")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.layouts {
        op.set_attr_int_list("layouts", value);
    }
    if let ::std::option::Option::Some(value) = &__args.device_ordinal {
        op.set_attr_int("device_ordinal", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// InitializeTable
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InitializeTable {
    pub Tkey: ::std::option::Option<crate::DataType>,
    pub Tval: ::std::option::Option<crate::DataType>,
}

impl InitializeTable {
    /// Creates a new `InitializeTable`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// initialize_table with default options.
pub fn initialize_table<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    values: T2,
) -> Result<()> {
    let __args = InitializeTable::new();
    initialize_table_with_args(ctx, table_handle, keys, values, &__args)
}

/// initialize_table with options.
pub fn initialize_table_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    values: T2,
    __args: &InitializeTable,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InitializeTable")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;
    op.add_input(&keys.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tkey {
        op.set_attr_type("Tkey", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tval {
        op.set_attr_type("Tval", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// InitializeTableFromDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InitializeTableFromDataset {}

impl InitializeTableFromDataset {
    /// Creates a new `InitializeTableFromDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// initialize_table_from_dataset with default options.
pub fn initialize_table_from_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    dataset: T1,
) -> Result<()> {
    let __args = InitializeTableFromDataset::new();
    initialize_table_from_dataset_with_args(ctx, table_handle, dataset, &__args)
}

/// initialize_table_from_dataset with options.
pub fn initialize_table_from_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    dataset: T1,
    __args: &InitializeTableFromDataset,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InitializeTableFromDataset")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;
    op.add_input(&dataset.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// InitializeTableFromTextFile
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InitializeTableFromTextFile {
    pub key_index: ::std::option::Option<i64>,
    pub value_index: ::std::option::Option<i64>,
    pub vocab_size: ::std::option::Option<i64>,
    pub delimiter: ::std::option::Option<::std::string::String>,
    pub offset: ::std::option::Option<i64>,
}

impl InitializeTableFromTextFile {
    /// Creates a new `InitializeTableFromTextFile`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// initialize_table_from_text_file with default options.
pub fn initialize_table_from_text_file<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    filename: T1,
) -> Result<()> {
    let __args = InitializeTableFromTextFile::new();
    initialize_table_from_text_file_with_args(ctx, table_handle, filename, &__args)
}

/// initialize_table_from_text_file with options.
pub fn initialize_table_from_text_file_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    filename: T1,
    __args: &InitializeTableFromTextFile,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InitializeTableFromTextFile")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;
    op.add_input(&filename.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.key_index {
        op.set_attr_int("key_index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_index {
        op.set_attr_int("value_index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.vocab_size {
        op.set_attr_int("vocab_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.delimiter {
        op.set_attr_string("delimiter", value);
    }
    if let ::std::option::Option::Some(value) = &__args.offset {
        op.set_attr_int("offset", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// InitializeTableFromTextFileV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InitializeTableFromTextFileV2 {
    pub key_index: ::std::option::Option<i64>,
    pub value_index: ::std::option::Option<i64>,
    pub vocab_size: ::std::option::Option<i64>,
    pub delimiter: ::std::option::Option<::std::string::String>,
    pub offset: ::std::option::Option<i64>,
}

impl InitializeTableFromTextFileV2 {
    /// Creates a new `InitializeTableFromTextFileV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// initialize_table_from_text_file_v2 with default options.
pub fn initialize_table_from_text_file_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    filename: T1,
) -> Result<()> {
    let __args = InitializeTableFromTextFileV2::new();
    initialize_table_from_text_file_v2_with_args(ctx, table_handle, filename, &__args)
}

/// initialize_table_from_text_file_v2 with options.
pub fn initialize_table_from_text_file_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    filename: T1,
    __args: &InitializeTableFromTextFileV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InitializeTableFromTextFileV2")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;
    op.add_input(&filename.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.key_index {
        op.set_attr_int("key_index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_index {
        op.set_attr_int("value_index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.vocab_size {
        op.set_attr_int("vocab_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.delimiter {
        op.set_attr_string("delimiter", value);
    }
    if let ::std::option::Option::Some(value) = &__args.offset {
        op.set_attr_int("offset", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// InitializeTableV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InitializeTableV2 {
    pub Tkey: ::std::option::Option<crate::DataType>,
    pub Tval: ::std::option::Option<crate::DataType>,
}

impl InitializeTableV2 {
    /// Creates a new `InitializeTableV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// initialize_table_v2 with default options.
pub fn initialize_table_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    values: T2,
) -> Result<()> {
    let __args = InitializeTableV2::new();
    initialize_table_v2_with_args(ctx, table_handle, keys, values, &__args)
}

/// initialize_table_v2 with options.
pub fn initialize_table_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    values: T2,
    __args: &InitializeTableV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InitializeTableV2")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;
    op.add_input(&keys.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tkey {
        op.set_attr_type("Tkey", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tval {
        op.set_attr_type("Tval", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// InplaceAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InplaceAdd {
    pub T: ::std::option::Option<crate::DataType>,
}

impl InplaceAdd {
    /// Creates a new `InplaceAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// inplace_add with default options.
pub fn inplace_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    i: T1,
    v: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = InplaceAdd::new();
    inplace_add_with_args(ctx, x, i, v, &__args)
}

/// inplace_add with options.
pub fn inplace_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    i: T1,
    v: T2,
    __args: &InplaceAdd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InplaceAdd")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&i.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// InplaceSub
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InplaceSub {
    pub T: ::std::option::Option<crate::DataType>,
}

impl InplaceSub {
    /// Creates a new `InplaceSub`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// inplace_sub with default options.
pub fn inplace_sub<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    i: T1,
    v: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = InplaceSub::new();
    inplace_sub_with_args(ctx, x, i, v, &__args)
}

/// inplace_sub with options.
pub fn inplace_sub_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    i: T1,
    v: T2,
    __args: &InplaceSub,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InplaceSub")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&i.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// InplaceUpdate
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InplaceUpdate {
    pub T: ::std::option::Option<crate::DataType>,
}

impl InplaceUpdate {
    /// Creates a new `InplaceUpdate`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// inplace_update with default options.
pub fn inplace_update<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    i: T1,
    v: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = InplaceUpdate::new();
    inplace_update_with_args(ctx, x, i, v, &__args)
}

/// inplace_update with options.
pub fn inplace_update_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    i: T1,
    v: T2,
    __args: &InplaceUpdate,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InplaceUpdate")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&i.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// InterleaveDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InterleaveDataset {
    pub f: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl InterleaveDataset {
    /// Creates a new `InterleaveDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// interleave_dataset with default options.
pub fn interleave_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = InterleaveDataset::new();
    interleave_dataset_with_args(
        ctx,
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        &__args,
    )
}

/// interleave_dataset with options.
pub fn interleave_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    __args: &InterleaveDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InterleaveDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;
    op.add_input(&cycle_length.to_handle()?)?;
    op.add_input(&block_length.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Inv
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Inv {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Inv {
    /// Creates a new `Inv`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// inv with default options.
pub fn inv<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Inv::new();
    inv_with_args(ctx, x, &__args)
}

/// inv with options.
pub fn inv_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Inv,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Inv")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// InvGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InvGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl InvGrad {
    /// Creates a new `InvGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// inv_grad with default options.
pub fn inv_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    dy: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = InvGrad::new();
    inv_grad_with_args(ctx, y, dy, &__args)
}

/// inv_grad with options.
pub fn inv_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    dy: T1,
    __args: &InvGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InvGrad")?;

    // Required input arguments
    op.add_input(&y.to_handle()?)?;
    op.add_input(&dy.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Invert
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Invert {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Invert {
    /// Creates a new `Invert`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// invert with default options.
pub fn invert<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Invert::new();
    invert_with_args(ctx, x, &__args)
}

/// invert with options.
pub fn invert_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Invert,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Invert")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// InvertPermutation
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InvertPermutation {
    pub T: ::std::option::Option<crate::DataType>,
}

impl InvertPermutation {
    /// Creates a new `InvertPermutation`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// invert_permutation with default options.
pub fn invert_permutation<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = InvertPermutation::new();
    invert_permutation_with_args(ctx, x, &__args)
}

/// invert_permutation with options.
pub fn invert_permutation_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &InvertPermutation,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "InvertPermutation")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IsBoostedTreesEnsembleInitialized
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsBoostedTreesEnsembleInitialized {}

impl IsBoostedTreesEnsembleInitialized {
    /// Creates a new `IsBoostedTreesEnsembleInitialized`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// is_boosted_trees_ensemble_initialized with default options.
pub fn is_boosted_trees_ensemble_initialized<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IsBoostedTreesEnsembleInitialized::new();
    is_boosted_trees_ensemble_initialized_with_args(ctx, tree_ensemble_handle, &__args)
}

/// is_boosted_trees_ensemble_initialized with options.
pub fn is_boosted_trees_ensemble_initialized_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tree_ensemble_handle: T0,
    __args: &IsBoostedTreesEnsembleInitialized,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IsBoostedTreesEnsembleInitialized")?;

    // Required input arguments
    op.add_input(&tree_ensemble_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IsBoostedTreesQuantileStreamResourceInitialized
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsBoostedTreesQuantileStreamResourceInitialized {}

impl IsBoostedTreesQuantileStreamResourceInitialized {
    /// Creates a new `IsBoostedTreesQuantileStreamResourceInitialized`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// is_boosted_trees_quantile_stream_resource_initialized with default options.
pub fn is_boosted_trees_quantile_stream_resource_initialized<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IsBoostedTreesQuantileStreamResourceInitialized::new();
    is_boosted_trees_quantile_stream_resource_initialized_with_args(
        ctx,
        quantile_stream_resource_handle,
        &__args,
    )
}

/// is_boosted_trees_quantile_stream_resource_initialized with options.
pub fn is_boosted_trees_quantile_stream_resource_initialized_with_args<
    T0: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    quantile_stream_resource_handle: T0,
    __args: &IsBoostedTreesQuantileStreamResourceInitialized,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IsBoostedTreesQuantileStreamResourceInitialized")?;

    // Required input arguments
    op.add_input(&quantile_stream_resource_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IsFinite
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsFinite {
    pub T: ::std::option::Option<crate::DataType>,
}

impl IsFinite {
    /// Creates a new `IsFinite`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// is_finite with default options.
pub fn is_finite<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IsFinite::new();
    is_finite_with_args(ctx, x, &__args)
}

/// is_finite with options.
pub fn is_finite_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &IsFinite,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IsFinite")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IsInf
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsInf {
    pub T: ::std::option::Option<crate::DataType>,
}

impl IsInf {
    /// Creates a new `IsInf`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// is_inf with default options.
pub fn is_inf<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IsInf::new();
    is_inf_with_args(ctx, x, &__args)
}

/// is_inf with options.
pub fn is_inf_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &IsInf,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IsInf")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IsNan
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsNan {
    pub T: ::std::option::Option<crate::DataType>,
}

impl IsNan {
    /// Creates a new `IsNan`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// is_nan with default options.
pub fn is_nan<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IsNan::new();
    is_nan_with_args(ctx, x, &__args)
}

/// is_nan with options.
pub fn is_nan_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &IsNan,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IsNan")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IsVariableInitialized
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsVariableInitialized {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl IsVariableInitialized {
    /// Creates a new `IsVariableInitialized`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// is_variable_initialized with default options.
pub fn is_variable_initialized<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    ref_: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IsVariableInitialized::new();
    is_variable_initialized_with_args(ctx, ref_, &__args)
}

/// is_variable_initialized with options.
pub fn is_variable_initialized_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    ref_: T0,
    __args: &IsVariableInitialized,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IsVariableInitialized")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IsotonicRegression
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsotonicRegression {
    pub T: ::std::option::Option<crate::DataType>,
    pub output_dtype: ::std::option::Option<crate::DataType>,
}

impl IsotonicRegression {
    /// Creates a new `IsotonicRegression`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// isotonic_regression with default options.
pub fn isotonic_regression<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = IsotonicRegression::new();
    isotonic_regression_with_args(ctx, input, &__args)
}

/// isotonic_regression with options.
pub fn isotonic_regression_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &IsotonicRegression,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IsotonicRegression")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_dtype {
        op.set_attr_type("output_dtype", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Iterator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Iterator {
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub container: ::std::option::Option<::std::string::String>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl Iterator {
    /// Creates a new `Iterator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// iterator with default options.
pub fn iterator(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = Iterator::new();
    iterator_with_args(ctx, &__args)
}

/// iterator with options.
pub fn iterator_with_args(
    ctx: &crate::eager::Context,
    __args: &Iterator,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Iterator")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IteratorFromStringHandle
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorFromStringHandle {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl IteratorFromStringHandle {
    /// Creates a new `IteratorFromStringHandle`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// iterator_from_string_handle with default options.
pub fn iterator_from_string_handle<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    string_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IteratorFromStringHandle::new();
    iterator_from_string_handle_with_args(ctx, string_handle, &__args)
}

/// iterator_from_string_handle with options.
pub fn iterator_from_string_handle_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    string_handle: T0,
    __args: &IteratorFromStringHandle,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IteratorFromStringHandle")?;

    // Required input arguments
    op.add_input(&string_handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IteratorFromStringHandleV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorFromStringHandleV2 {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl IteratorFromStringHandleV2 {
    /// Creates a new `IteratorFromStringHandleV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// iterator_from_string_handle_v2 with default options.
pub fn iterator_from_string_handle_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    string_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IteratorFromStringHandleV2::new();
    iterator_from_string_handle_v2_with_args(ctx, string_handle, &__args)
}

/// iterator_from_string_handle_v2 with options.
pub fn iterator_from_string_handle_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    string_handle: T0,
    __args: &IteratorFromStringHandleV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IteratorFromStringHandleV2")?;

    // Required input arguments
    op.add_input(&string_handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IteratorGetDevice
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorGetDevice {}

impl IteratorGetDevice {
    /// Creates a new `IteratorGetDevice`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// iterator_get_device with default options.
pub fn iterator_get_device<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IteratorGetDevice::new();
    iterator_get_device_with_args(ctx, resource, &__args)
}

/// iterator_get_device with options.
pub fn iterator_get_device_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    __args: &IteratorGetDevice,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IteratorGetDevice")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IteratorGetNext
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorGetNext {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl IteratorGetNext {
    /// Creates a new `IteratorGetNext`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// iterator_get_next with default options.
pub fn iterator_get_next<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    iterator: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IteratorGetNext::new();
    iterator_get_next_with_args(ctx, iterator, &__args)
}

/// iterator_get_next with options.
pub fn iterator_get_next_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    iterator: T0,
    __args: &IteratorGetNext,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IteratorGetNext")?;

    // Required input arguments
    op.add_input(&iterator.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IteratorGetNextAsOptional
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorGetNextAsOptional {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl IteratorGetNextAsOptional {
    /// Creates a new `IteratorGetNextAsOptional`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// iterator_get_next_as_optional with default options.
pub fn iterator_get_next_as_optional<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    iterator: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IteratorGetNextAsOptional::new();
    iterator_get_next_as_optional_with_args(ctx, iterator, &__args)
}

/// iterator_get_next_as_optional with options.
pub fn iterator_get_next_as_optional_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    iterator: T0,
    __args: &IteratorGetNextAsOptional,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IteratorGetNextAsOptional")?;

    // Required input arguments
    op.add_input(&iterator.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IteratorGetNextSync
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorGetNextSync {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl IteratorGetNextSync {
    /// Creates a new `IteratorGetNextSync`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// iterator_get_next_sync with default options.
pub fn iterator_get_next_sync<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    iterator: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IteratorGetNextSync::new();
    iterator_get_next_sync_with_args(ctx, iterator, &__args)
}

/// iterator_get_next_sync with options.
pub fn iterator_get_next_sync_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    iterator: T0,
    __args: &IteratorGetNextSync,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IteratorGetNextSync")?;

    // Required input arguments
    op.add_input(&iterator.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IteratorToStringHandle
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorToStringHandle {}

impl IteratorToStringHandle {
    /// Creates a new `IteratorToStringHandle`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// iterator_to_string_handle with default options.
pub fn iterator_to_string_handle<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = IteratorToStringHandle::new();
    iterator_to_string_handle_with_args(ctx, resource_handle, &__args)
}

/// iterator_to_string_handle with options.
pub fn iterator_to_string_handle_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource_handle: T0,
    __args: &IteratorToStringHandle,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IteratorToStringHandle")?;

    // Required input arguments
    op.add_input(&resource_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// IteratorV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorV2 {
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub container: ::std::option::Option<::std::string::String>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl IteratorV2 {
    /// Creates a new `IteratorV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// iterator_v2 with default options.
pub fn iterator_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = IteratorV2::new();
    iterator_v2_with_args(ctx, &__args)
}

/// iterator_v2 with options.
pub fn iterator_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &IteratorV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "IteratorV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// KMC2ChainInitialization
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct KMC2ChainInitialization {}

impl KMC2ChainInitialization {
    /// Creates a new `KMC2ChainInitialization`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// kmc2_chain_initialization with default options.
pub fn kmc2_chain_initialization<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    distances: T0,
    seed: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = KMC2ChainInitialization::new();
    kmc2_chain_initialization_with_args(ctx, distances, seed, &__args)
}

/// kmc2_chain_initialization with options.
pub fn kmc2_chain_initialization_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    distances: T0,
    seed: T1,
    __args: &KMC2ChainInitialization,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "KMC2ChainInitialization")?;

    // Required input arguments
    op.add_input(&distances.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// KmeansPlusPlusInitialization
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct KmeansPlusPlusInitialization {}

impl KmeansPlusPlusInitialization {
    /// Creates a new `KmeansPlusPlusInitialization`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// kmeans_plus_plus_initialization with default options.
pub fn kmeans_plus_plus_initialization<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    points: T0,
    num_to_sample: T1,
    seed: T2,
    num_retries_per_sample: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = KmeansPlusPlusInitialization::new();
    kmeans_plus_plus_initialization_with_args(
        ctx,
        points,
        num_to_sample,
        seed,
        num_retries_per_sample,
        &__args,
    )
}

/// kmeans_plus_plus_initialization with options.
pub fn kmeans_plus_plus_initialization_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    points: T0,
    num_to_sample: T1,
    seed: T2,
    num_retries_per_sample: T3,
    __args: &KmeansPlusPlusInitialization,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "KmeansPlusPlusInitialization")?;

    // Required input arguments
    op.add_input(&points.to_handle()?)?;
    op.add_input(&num_to_sample.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&num_retries_per_sample.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// KthOrderStatistic
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct KthOrderStatistic {
    pub k: ::std::option::Option<i64>,
}

impl KthOrderStatistic {
    /// Creates a new `KthOrderStatistic`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// kth_order_statistic with default options.
pub fn kth_order_statistic<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = KthOrderStatistic::new();
    kth_order_statistic_with_args(ctx, input, &__args)
}

/// kth_order_statistic with options.
pub fn kth_order_statistic_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &KthOrderStatistic,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "KthOrderStatistic")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.k {
        op.set_attr_int("k", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// L2Loss
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct L2Loss {
    pub T: ::std::option::Option<crate::DataType>,
}

impl L2Loss {
    /// Creates a new `L2Loss`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// l2_loss with default options.
pub fn l2_loss<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    t: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = L2Loss::new();
    l2_loss_with_args(ctx, t, &__args)
}

/// l2_loss with options.
pub fn l2_loss_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    t: T0,
    __args: &L2Loss,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "L2Loss")?;

    // Required input arguments
    op.add_input(&t.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LMDBDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LMDBDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl LMDBDataset {
    /// Creates a new `LMDBDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lmdbdataset with default options.
pub fn lmdbdataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    filenames: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = LMDBDataset::new();
    lmdbdataset_with_args(ctx, filenames, &__args)
}

/// lmdbdataset with options.
pub fn lmdbdataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    filenames: T0,
    __args: &LMDBDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LMDBDataset")?;

    // Required input arguments
    op.add_input(&filenames.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LMDBReader
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LMDBReader {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl LMDBReader {
    /// Creates a new `LMDBReader`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lmdbreader with default options.
pub fn lmdbreader(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = LMDBReader::new();
    lmdbreader_with_args(ctx, &__args)
}

/// lmdbreader with options.
pub fn lmdbreader_with_args(
    ctx: &crate::eager::Context,
    __args: &LMDBReader,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LMDBReader")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LRN
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LRN {
    pub depth_radius: ::std::option::Option<i64>,
    pub bias: ::std::option::Option<f32>,
    pub alpha: ::std::option::Option<f32>,
    pub beta: ::std::option::Option<f32>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl LRN {
    /// Creates a new `LRN`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lrn with default options.
pub fn lrn<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = LRN::new();
    lrn_with_args(ctx, input, &__args)
}

/// lrn with options.
pub fn lrn_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &LRN,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LRN")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.depth_radius {
        op.set_attr_int("depth_radius", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.bias {
        op.set_attr_float("bias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.alpha {
        op.set_attr_float("alpha", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.beta {
        op.set_attr_float("beta", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LRNGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LRNGrad {
    pub depth_radius: ::std::option::Option<i64>,
    pub bias: ::std::option::Option<f32>,
    pub alpha: ::std::option::Option<f32>,
    pub beta: ::std::option::Option<f32>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl LRNGrad {
    /// Creates a new `LRNGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lrngrad with default options.
pub fn lrngrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_grads: T0,
    input_image: T1,
    output_image: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = LRNGrad::new();
    lrngrad_with_args(ctx, input_grads, input_image, output_image, &__args)
}

/// lrngrad with options.
pub fn lrngrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_grads: T0,
    input_image: T1,
    output_image: T2,
    __args: &LRNGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LRNGrad")?;

    // Required input arguments
    op.add_input(&input_grads.to_handle()?)?;
    op.add_input(&input_image.to_handle()?)?;
    op.add_input(&output_image.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.depth_radius {
        op.set_attr_int("depth_radius", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.bias {
        op.set_attr_float("bias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.alpha {
        op.set_attr_float("alpha", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.beta {
        op.set_attr_float("beta", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LSTMBlockCell
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LSTMBlockCell {
    pub forget_bias: ::std::option::Option<f32>,
    pub cell_clip: ::std::option::Option<f32>,
    pub use_peephole: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl LSTMBlockCell {
    /// Creates a new `LSTMBlockCell`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lstmblock_cell with default options.
pub fn lstmblock_cell<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    cs_prev: T1,
    h_prev: T2,
    w: T3,
    wci: T4,
    wcf: T5,
    wco: T6,
    b: T7,
) -> Result<[crate::eager::TensorHandle; 7]> {
    let __args = LSTMBlockCell::new();
    lstmblock_cell_with_args(ctx, x, cs_prev, h_prev, w, wci, wcf, wco, b, &__args)
}

/// lstmblock_cell with options.
pub fn lstmblock_cell_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    cs_prev: T1,
    h_prev: T2,
    w: T3,
    wci: T4,
    wcf: T5,
    wco: T6,
    b: T7,
    __args: &LSTMBlockCell,
) -> Result<[crate::eager::TensorHandle; 7]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LSTMBlockCell")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&cs_prev.to_handle()?)?;
    op.add_input(&h_prev.to_handle()?)?;
    op.add_input(&w.to_handle()?)?;
    op.add_input(&wci.to_handle()?)?;
    op.add_input(&wcf.to_handle()?)?;
    op.add_input(&wco.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.forget_bias {
        op.set_attr_float("forget_bias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.cell_clip {
        op.set_attr_float("cell_clip", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_peephole {
        op.set_attr_bool("use_peephole", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 7;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 7];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
                crate::eager::TensorHandle::from_tensor_handle(res[6]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// LSTMBlockCellGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LSTMBlockCellGrad {
    pub use_peephole: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl LSTMBlockCellGrad {
    /// Creates a new `LSTMBlockCellGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lstmblock_cell_grad with default options.
pub fn lstmblock_cell_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
    T12: crate::eager::ToHandle,
    T13: crate::eager::ToHandle,
    T14: crate::eager::ToHandle,
    T15: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    cs_prev: T1,
    h_prev: T2,
    w: T3,
    wci: T4,
    wcf: T5,
    wco: T6,
    b: T7,
    i: T8,
    cs: T9,
    f: T10,
    o: T11,
    ci: T12,
    co: T13,
    cs_grad: T14,
    h_grad: T15,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let __args = LSTMBlockCellGrad::new();
    lstmblock_cell_grad_with_args(
        ctx, x, cs_prev, h_prev, w, wci, wcf, wco, b, i, cs, f, o, ci, co, cs_grad, h_grad, &__args,
    )
}

/// lstmblock_cell_grad with options.
pub fn lstmblock_cell_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
    T12: crate::eager::ToHandle,
    T13: crate::eager::ToHandle,
    T14: crate::eager::ToHandle,
    T15: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    cs_prev: T1,
    h_prev: T2,
    w: T3,
    wci: T4,
    wcf: T5,
    wco: T6,
    b: T7,
    i: T8,
    cs: T9,
    f: T10,
    o: T11,
    ci: T12,
    co: T13,
    cs_grad: T14,
    h_grad: T15,
    __args: &LSTMBlockCellGrad,
) -> Result<[crate::eager::TensorHandle; 5]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LSTMBlockCellGrad")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&cs_prev.to_handle()?)?;
    op.add_input(&h_prev.to_handle()?)?;
    op.add_input(&w.to_handle()?)?;
    op.add_input(&wci.to_handle()?)?;
    op.add_input(&wcf.to_handle()?)?;
    op.add_input(&wco.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;
    op.add_input(&i.to_handle()?)?;
    op.add_input(&cs.to_handle()?)?;
    op.add_input(&f.to_handle()?)?;
    op.add_input(&o.to_handle()?)?;
    op.add_input(&ci.to_handle()?)?;
    op.add_input(&co.to_handle()?)?;
    op.add_input(&cs_grad.to_handle()?)?;
    op.add_input(&h_grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.use_peephole {
        op.set_attr_bool("use_peephole", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 5;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 5];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// LatencyStatsDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LatencyStatsDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl LatencyStatsDataset {
    /// Creates a new `LatencyStatsDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// latency_stats_dataset with default options.
pub fn latency_stats_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    tag: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = LatencyStatsDataset::new();
    latency_stats_dataset_with_args(ctx, input_dataset, tag, &__args)
}

/// latency_stats_dataset with options.
pub fn latency_stats_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    tag: T1,
    __args: &LatencyStatsDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LatencyStatsDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&tag.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LeakyRelu
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LeakyRelu {
    pub alpha: ::std::option::Option<f32>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl LeakyRelu {
    /// Creates a new `LeakyRelu`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// leaky_relu with default options.
pub fn leaky_relu<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = LeakyRelu::new();
    leaky_relu_with_args(ctx, features, &__args)
}

/// leaky_relu with options.
pub fn leaky_relu_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
    __args: &LeakyRelu,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LeakyRelu")?;

    // Required input arguments
    op.add_input(&features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.alpha {
        op.set_attr_float("alpha", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LeakyReluGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LeakyReluGrad {
    pub alpha: ::std::option::Option<f32>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl LeakyReluGrad {
    /// Creates a new `LeakyReluGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// leaky_relu_grad with default options.
pub fn leaky_relu_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    features: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = LeakyReluGrad::new();
    leaky_relu_grad_with_args(ctx, gradients, features, &__args)
}

/// leaky_relu_grad with options.
pub fn leaky_relu_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    features: T1,
    __args: &LeakyReluGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LeakyReluGrad")?;

    // Required input arguments
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.alpha {
        op.set_attr_float("alpha", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LearnedUnigramCandidateSampler
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LearnedUnigramCandidateSampler {
    pub num_true: ::std::option::Option<i64>,
    pub num_sampled: ::std::option::Option<i64>,
    pub unique: ::std::option::Option<bool>,
    pub range_max: ::std::option::Option<i64>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
}

impl LearnedUnigramCandidateSampler {
    /// Creates a new `LearnedUnigramCandidateSampler`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// learned_unigram_candidate_sampler with default options.
pub fn learned_unigram_candidate_sampler<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = LearnedUnigramCandidateSampler::new();
    learned_unigram_candidate_sampler_with_args(ctx, true_classes, &__args)
}

/// learned_unigram_candidate_sampler with options.
pub fn learned_unigram_candidate_sampler_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
    __args: &LearnedUnigramCandidateSampler,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LearnedUnigramCandidateSampler")?;

    // Required input arguments
    op.add_input(&true_classes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_true {
        op.set_attr_int("num_true", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_sampled {
        op.set_attr_int("num_sampled", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.unique {
        op.set_attr_bool("unique", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.range_max {
        op.set_attr_int("range_max", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// LeftShift
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LeftShift {
    pub T: ::std::option::Option<crate::DataType>,
}

impl LeftShift {
    /// Creates a new `LeftShift`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// left_shift with default options.
pub fn left_shift<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = LeftShift::new();
    left_shift_with_args(ctx, x, y, &__args)
}

/// left_shift with options.
pub fn left_shift_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &LeftShift,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LeftShift")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LegacyParallelInterleaveDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LegacyParallelInterleaveDatasetV2 {
    pub f: ::std::option::Option<::std::string::String>,
    pub deterministic: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl LegacyParallelInterleaveDatasetV2 {
    /// Creates a new `LegacyParallelInterleaveDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// legacy_parallel_interleave_dataset_v2 with default options.
pub fn legacy_parallel_interleave_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    buffer_output_elements: T4,
    prefetch_input_elements: T5,
) -> Result<crate::eager::TensorHandle> {
    let __args = LegacyParallelInterleaveDatasetV2::new();
    legacy_parallel_interleave_dataset_v2_with_args(
        ctx,
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        buffer_output_elements,
        prefetch_input_elements,
        &__args,
    )
}

/// legacy_parallel_interleave_dataset_v2 with options.
pub fn legacy_parallel_interleave_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    buffer_output_elements: T4,
    prefetch_input_elements: T5,
    __args: &LegacyParallelInterleaveDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LegacyParallelInterleaveDatasetV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;
    op.add_input(&cycle_length.to_handle()?)?;
    op.add_input(&block_length.to_handle()?)?;
    op.add_input(&buffer_output_elements.to_handle()?)?;
    op.add_input(&prefetch_input_elements.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.deterministic {
        op.set_attr_string("deterministic", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Less
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Less {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Less {
    /// Creates a new `Less`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// less with default options.
pub fn less<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Less::new();
    less_with_args(ctx, x, y, &__args)
}

/// less with options.
pub fn less_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Less,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Less")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LessEqual
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LessEqual {
    pub T: ::std::option::Option<crate::DataType>,
}

impl LessEqual {
    /// Creates a new `LessEqual`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// less_equal with default options.
pub fn less_equal<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = LessEqual::new();
    less_equal_with_args(ctx, x, y, &__args)
}

/// less_equal with options.
pub fn less_equal_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &LessEqual,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LessEqual")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Lgamma
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Lgamma {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Lgamma {
    /// Creates a new `Lgamma`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lgamma with default options.
pub fn lgamma<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Lgamma::new();
    lgamma_with_args(ctx, x, &__args)
}

/// lgamma with options.
pub fn lgamma_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Lgamma,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Lgamma")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LinSpace
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LinSpace {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl LinSpace {
    /// Creates a new `LinSpace`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lin_space with default options.
pub fn lin_space<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    start: T0,
    stop: T1,
    num: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = LinSpace::new();
    lin_space_with_args(ctx, start, stop, num, &__args)
}

/// lin_space with options.
pub fn lin_space_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    start: T0,
    stop: T1,
    num: T2,
    __args: &LinSpace,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LinSpace")?;

    // Required input arguments
    op.add_input(&start.to_handle()?)?;
    op.add_input(&stop.to_handle()?)?;
    op.add_input(&num.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ListDiff
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ListDiff {
    pub T: ::std::option::Option<crate::DataType>,
    pub out_idx: ::std::option::Option<crate::DataType>,
}

impl ListDiff {
    /// Creates a new `ListDiff`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// list_diff with default options.
pub fn list_diff<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = ListDiff::new();
    list_diff_with_args(ctx, x, y, &__args)
}

/// list_diff with options.
pub fn list_diff_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &ListDiff,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ListDiff")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_idx {
        op.set_attr_type("out_idx", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// LoadAndRemapMatrix
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadAndRemapMatrix {
    pub num_rows: ::std::option::Option<i64>,
    pub num_cols: ::std::option::Option<i64>,
    pub max_rows_in_memory: ::std::option::Option<i64>,
}

impl LoadAndRemapMatrix {
    /// Creates a new `LoadAndRemapMatrix`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_and_remap_matrix with default options.
pub fn load_and_remap_matrix<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ckpt_path: T0,
    old_tensor_name: T1,
    row_remapping: T2,
    col_remapping: T3,
    initializing_values: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = LoadAndRemapMatrix::new();
    load_and_remap_matrix_with_args(
        ctx,
        ckpt_path,
        old_tensor_name,
        row_remapping,
        col_remapping,
        initializing_values,
        &__args,
    )
}

/// load_and_remap_matrix with options.
pub fn load_and_remap_matrix_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ckpt_path: T0,
    old_tensor_name: T1,
    row_remapping: T2,
    col_remapping: T3,
    initializing_values: T4,
    __args: &LoadAndRemapMatrix,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadAndRemapMatrix")?;

    // Required input arguments
    op.add_input(&ckpt_path.to_handle()?)?;
    op.add_input(&old_tensor_name.to_handle()?)?;
    op.add_input(&row_remapping.to_handle()?)?;
    op.add_input(&col_remapping.to_handle()?)?;
    op.add_input(&initializing_values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_rows {
        op.set_attr_int("num_rows", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_cols {
        op.set_attr_int("num_cols", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_rows_in_memory {
        op.set_attr_int("max_rows_in_memory", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LoadDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub compression: ::std::option::Option<::std::string::String>,
    pub reader_func: ::std::option::Option<::std::string::String>,
    pub Treader_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl LoadDataset {
    /// Creates a new `LoadDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_dataset with default options.
pub fn load_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    path: T0,
    reader_func_other_args: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = LoadDataset::new();
    load_dataset_with_args(ctx, path, reader_func_other_args, &__args)
}

/// load_dataset with options.
pub fn load_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    path: T0,
    reader_func_other_args: T1,
    __args: &LoadDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadDataset")?;

    // Required input arguments
    op.add_input(&path.to_handle()?)?;
    op.add_input(&reader_func_other_args.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.compression {
        op.set_attr_string("compression", value);
    }
    if let ::std::option::Option::Some(value) = &__args.reader_func {
        op.set_attr_string("reader_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Treader_func_args {
        op.set_attr_type_list("Treader_func_args", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LoadTPUEmbeddingADAMParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingADAMParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingADAMParameters {
    /// Creates a new `LoadTPUEmbeddingADAMParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_adamparameters with default options.
pub fn load_tpuembedding_adamparameters<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    momenta: T1,
    velocities: T2,
) -> Result<()> {
    let __args = LoadTPUEmbeddingADAMParameters::new();
    load_tpuembedding_adamparameters_with_args(ctx, parameters, momenta, velocities, &__args)
}

/// load_tpuembedding_adamparameters with options.
pub fn load_tpuembedding_adamparameters_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    momenta: T1,
    velocities: T2,
    __args: &LoadTPUEmbeddingADAMParameters,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingADAMParameters")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&momenta.to_handle()?)?;
    op.add_input(&velocities.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingADAMParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingADAMParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingADAMParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingADAMParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_adamparameters_grad_accum_debug with default options.
pub fn load_tpuembedding_adamparameters_grad_accum_debug<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    momenta: T1,
    velocities: T2,
    gradient_accumulators: T3,
) -> Result<()> {
    let __args = LoadTPUEmbeddingADAMParametersGradAccumDebug::new();
    load_tpuembedding_adamparameters_grad_accum_debug_with_args(
        ctx,
        parameters,
        momenta,
        velocities,
        gradient_accumulators,
        &__args,
    )
}

/// load_tpuembedding_adamparameters_grad_accum_debug with options.
pub fn load_tpuembedding_adamparameters_grad_accum_debug_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    momenta: T1,
    velocities: T2,
    gradient_accumulators: T3,
    __args: &LoadTPUEmbeddingADAMParametersGradAccumDebug,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingADAMParametersGradAccumDebug")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&momenta.to_handle()?)?;
    op.add_input(&velocities.to_handle()?)?;
    op.add_input(&gradient_accumulators.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingAdadeltaParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingAdadeltaParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingAdadeltaParameters {
    /// Creates a new `LoadTPUEmbeddingAdadeltaParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_adadelta_parameters with default options.
pub fn load_tpuembedding_adadelta_parameters<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    updates: T2,
) -> Result<()> {
    let __args = LoadTPUEmbeddingAdadeltaParameters::new();
    load_tpuembedding_adadelta_parameters_with_args(ctx, parameters, accumulators, updates, &__args)
}

/// load_tpuembedding_adadelta_parameters with options.
pub fn load_tpuembedding_adadelta_parameters_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    updates: T2,
    __args: &LoadTPUEmbeddingAdadeltaParameters,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingAdadeltaParameters")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&accumulators.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingAdadeltaParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingAdadeltaParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingAdadeltaParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingAdadeltaParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_adadelta_parameters_grad_accum_debug with default options.
pub fn load_tpuembedding_adadelta_parameters_grad_accum_debug<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    updates: T2,
    gradient_accumulators: T3,
) -> Result<()> {
    let __args = LoadTPUEmbeddingAdadeltaParametersGradAccumDebug::new();
    load_tpuembedding_adadelta_parameters_grad_accum_debug_with_args(
        ctx,
        parameters,
        accumulators,
        updates,
        gradient_accumulators,
        &__args,
    )
}

/// load_tpuembedding_adadelta_parameters_grad_accum_debug with options.
pub fn load_tpuembedding_adadelta_parameters_grad_accum_debug_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    updates: T2,
    gradient_accumulators: T3,
    __args: &LoadTPUEmbeddingAdadeltaParametersGradAccumDebug,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingAdadeltaParametersGradAccumDebug")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&accumulators.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;
    op.add_input(&gradient_accumulators.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingAdagradParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingAdagradParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingAdagradParameters {
    /// Creates a new `LoadTPUEmbeddingAdagradParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_adagrad_parameters with default options.
pub fn load_tpuembedding_adagrad_parameters<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
) -> Result<()> {
    let __args = LoadTPUEmbeddingAdagradParameters::new();
    load_tpuembedding_adagrad_parameters_with_args(ctx, parameters, accumulators, &__args)
}

/// load_tpuembedding_adagrad_parameters with options.
pub fn load_tpuembedding_adagrad_parameters_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    __args: &LoadTPUEmbeddingAdagradParameters,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingAdagradParameters")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&accumulators.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingAdagradParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingAdagradParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingAdagradParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingAdagradParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_adagrad_parameters_grad_accum_debug with default options.
pub fn load_tpuembedding_adagrad_parameters_grad_accum_debug<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    gradient_accumulators: T2,
) -> Result<()> {
    let __args = LoadTPUEmbeddingAdagradParametersGradAccumDebug::new();
    load_tpuembedding_adagrad_parameters_grad_accum_debug_with_args(
        ctx,
        parameters,
        accumulators,
        gradient_accumulators,
        &__args,
    )
}

/// load_tpuembedding_adagrad_parameters_grad_accum_debug with options.
pub fn load_tpuembedding_adagrad_parameters_grad_accum_debug_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    gradient_accumulators: T2,
    __args: &LoadTPUEmbeddingAdagradParametersGradAccumDebug,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingAdagradParametersGradAccumDebug")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&accumulators.to_handle()?)?;
    op.add_input(&gradient_accumulators.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingCenteredRMSPropParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingCenteredRMSPropParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingCenteredRMSPropParameters {
    /// Creates a new `LoadTPUEmbeddingCenteredRMSPropParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_centered_rmsprop_parameters with default options.
pub fn load_tpuembedding_centered_rmsprop_parameters<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    ms: T1,
    mom: T2,
    mg: T3,
) -> Result<()> {
    let __args = LoadTPUEmbeddingCenteredRMSPropParameters::new();
    load_tpuembedding_centered_rmsprop_parameters_with_args(ctx, parameters, ms, mom, mg, &__args)
}

/// load_tpuembedding_centered_rmsprop_parameters with options.
pub fn load_tpuembedding_centered_rmsprop_parameters_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    ms: T1,
    mom: T2,
    mg: T3,
    __args: &LoadTPUEmbeddingCenteredRMSPropParameters,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingCenteredRMSPropParameters")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&ms.to_handle()?)?;
    op.add_input(&mom.to_handle()?)?;
    op.add_input(&mg.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingFTRLParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingFTRLParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingFTRLParameters {
    /// Creates a new `LoadTPUEmbeddingFTRLParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_ftrlparameters with default options.
pub fn load_tpuembedding_ftrlparameters<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    linears: T2,
) -> Result<()> {
    let __args = LoadTPUEmbeddingFTRLParameters::new();
    load_tpuembedding_ftrlparameters_with_args(ctx, parameters, accumulators, linears, &__args)
}

/// load_tpuembedding_ftrlparameters with options.
pub fn load_tpuembedding_ftrlparameters_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    linears: T2,
    __args: &LoadTPUEmbeddingFTRLParameters,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingFTRLParameters")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&accumulators.to_handle()?)?;
    op.add_input(&linears.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingFTRLParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingFTRLParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingFTRLParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingFTRLParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_ftrlparameters_grad_accum_debug with default options.
pub fn load_tpuembedding_ftrlparameters_grad_accum_debug<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    linears: T2,
    gradient_accumulators: T3,
) -> Result<()> {
    let __args = LoadTPUEmbeddingFTRLParametersGradAccumDebug::new();
    load_tpuembedding_ftrlparameters_grad_accum_debug_with_args(
        ctx,
        parameters,
        accumulators,
        linears,
        gradient_accumulators,
        &__args,
    )
}

/// load_tpuembedding_ftrlparameters_grad_accum_debug with options.
pub fn load_tpuembedding_ftrlparameters_grad_accum_debug_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    linears: T2,
    gradient_accumulators: T3,
    __args: &LoadTPUEmbeddingFTRLParametersGradAccumDebug,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingFTRLParametersGradAccumDebug")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&accumulators.to_handle()?)?;
    op.add_input(&linears.to_handle()?)?;
    op.add_input(&gradient_accumulators.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingFrequencyEstimatorParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingFrequencyEstimatorParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingFrequencyEstimatorParameters {
    /// Creates a new `LoadTPUEmbeddingFrequencyEstimatorParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_frequency_estimator_parameters with default options.
pub fn load_tpuembedding_frequency_estimator_parameters<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    last_hit_step: T1,
) -> Result<()> {
    let __args = LoadTPUEmbeddingFrequencyEstimatorParameters::new();
    load_tpuembedding_frequency_estimator_parameters_with_args(
        ctx,
        parameters,
        last_hit_step,
        &__args,
    )
}

/// load_tpuembedding_frequency_estimator_parameters with options.
pub fn load_tpuembedding_frequency_estimator_parameters_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    last_hit_step: T1,
    __args: &LoadTPUEmbeddingFrequencyEstimatorParameters,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingFrequencyEstimatorParameters")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&last_hit_step.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_frequency_estimator_parameters_grad_accum_debug with default options.
pub fn load_tpuembedding_frequency_estimator_parameters_grad_accum_debug<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    last_hit_step: T1,
    gradient_accumulators: T2,
) -> Result<()> {
    let __args = LoadTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug::new();
    load_tpuembedding_frequency_estimator_parameters_grad_accum_debug_with_args(
        ctx,
        parameters,
        last_hit_step,
        gradient_accumulators,
        &__args,
    )
}

/// load_tpuembedding_frequency_estimator_parameters_grad_accum_debug with options.
pub fn load_tpuembedding_frequency_estimator_parameters_grad_accum_debug_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    last_hit_step: T1,
    gradient_accumulators: T2,
    __args: &LoadTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(
        ctx,
        "LoadTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug",
    )?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&last_hit_step.to_handle()?)?;
    op.add_input(&gradient_accumulators.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingMDLAdagradLightParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingMDLAdagradLightParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingMDLAdagradLightParameters {
    /// Creates a new `LoadTPUEmbeddingMDLAdagradLightParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_mdladagrad_light_parameters with default options.
pub fn load_tpuembedding_mdladagrad_light_parameters<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    weights: T2,
    benefits: T3,
) -> Result<()> {
    let __args = LoadTPUEmbeddingMDLAdagradLightParameters::new();
    load_tpuembedding_mdladagrad_light_parameters_with_args(
        ctx,
        parameters,
        accumulators,
        weights,
        benefits,
        &__args,
    )
}

/// load_tpuembedding_mdladagrad_light_parameters with options.
pub fn load_tpuembedding_mdladagrad_light_parameters_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    weights: T2,
    benefits: T3,
    __args: &LoadTPUEmbeddingMDLAdagradLightParameters,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingMDLAdagradLightParameters")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&accumulators.to_handle()?)?;
    op.add_input(&weights.to_handle()?)?;
    op.add_input(&benefits.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingMomentumParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingMomentumParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingMomentumParameters {
    /// Creates a new `LoadTPUEmbeddingMomentumParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_momentum_parameters with default options.
pub fn load_tpuembedding_momentum_parameters<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    momenta: T1,
) -> Result<()> {
    let __args = LoadTPUEmbeddingMomentumParameters::new();
    load_tpuembedding_momentum_parameters_with_args(ctx, parameters, momenta, &__args)
}

/// load_tpuembedding_momentum_parameters with options.
pub fn load_tpuembedding_momentum_parameters_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    momenta: T1,
    __args: &LoadTPUEmbeddingMomentumParameters,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingMomentumParameters")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&momenta.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingMomentumParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingMomentumParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingMomentumParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingMomentumParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_momentum_parameters_grad_accum_debug with default options.
pub fn load_tpuembedding_momentum_parameters_grad_accum_debug<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    momenta: T1,
    gradient_accumulators: T2,
) -> Result<()> {
    let __args = LoadTPUEmbeddingMomentumParametersGradAccumDebug::new();
    load_tpuembedding_momentum_parameters_grad_accum_debug_with_args(
        ctx,
        parameters,
        momenta,
        gradient_accumulators,
        &__args,
    )
}

/// load_tpuembedding_momentum_parameters_grad_accum_debug with options.
pub fn load_tpuembedding_momentum_parameters_grad_accum_debug_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    momenta: T1,
    gradient_accumulators: T2,
    __args: &LoadTPUEmbeddingMomentumParametersGradAccumDebug,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingMomentumParametersGradAccumDebug")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&momenta.to_handle()?)?;
    op.add_input(&gradient_accumulators.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingProximalAdagradParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingProximalAdagradParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingProximalAdagradParameters {
    /// Creates a new `LoadTPUEmbeddingProximalAdagradParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_proximal_adagrad_parameters with default options.
pub fn load_tpuembedding_proximal_adagrad_parameters<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
) -> Result<()> {
    let __args = LoadTPUEmbeddingProximalAdagradParameters::new();
    load_tpuembedding_proximal_adagrad_parameters_with_args(ctx, parameters, accumulators, &__args)
}

/// load_tpuembedding_proximal_adagrad_parameters with options.
pub fn load_tpuembedding_proximal_adagrad_parameters_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    __args: &LoadTPUEmbeddingProximalAdagradParameters,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingProximalAdagradParameters")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&accumulators.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_proximal_adagrad_parameters_grad_accum_debug with default options.
pub fn load_tpuembedding_proximal_adagrad_parameters_grad_accum_debug<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    gradient_accumulators: T2,
) -> Result<()> {
    let __args = LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug::new();
    load_tpuembedding_proximal_adagrad_parameters_grad_accum_debug_with_args(
        ctx,
        parameters,
        accumulators,
        gradient_accumulators,
        &__args,
    )
}

/// load_tpuembedding_proximal_adagrad_parameters_grad_accum_debug with options.
pub fn load_tpuembedding_proximal_adagrad_parameters_grad_accum_debug_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    accumulators: T1,
    gradient_accumulators: T2,
    __args: &LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(
        ctx,
        "LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug",
    )?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&accumulators.to_handle()?)?;
    op.add_input(&gradient_accumulators.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingProximalYogiParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingProximalYogiParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingProximalYogiParameters {
    /// Creates a new `LoadTPUEmbeddingProximalYogiParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_proximal_yogi_parameters with default options.
pub fn load_tpuembedding_proximal_yogi_parameters<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    v: T1,
    m: T2,
) -> Result<()> {
    let __args = LoadTPUEmbeddingProximalYogiParameters::new();
    load_tpuembedding_proximal_yogi_parameters_with_args(ctx, parameters, v, m, &__args)
}

/// load_tpuembedding_proximal_yogi_parameters with options.
pub fn load_tpuembedding_proximal_yogi_parameters_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    v: T1,
    m: T2,
    __args: &LoadTPUEmbeddingProximalYogiParameters,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingProximalYogiParameters")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingProximalYogiParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingProximalYogiParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingProximalYogiParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingProximalYogiParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_proximal_yogi_parameters_grad_accum_debug with default options.
pub fn load_tpuembedding_proximal_yogi_parameters_grad_accum_debug<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    v: T1,
    m: T2,
    gradient_accumulators: T3,
) -> Result<()> {
    let __args = LoadTPUEmbeddingProximalYogiParametersGradAccumDebug::new();
    load_tpuembedding_proximal_yogi_parameters_grad_accum_debug_with_args(
        ctx,
        parameters,
        v,
        m,
        gradient_accumulators,
        &__args,
    )
}

/// load_tpuembedding_proximal_yogi_parameters_grad_accum_debug with options.
pub fn load_tpuembedding_proximal_yogi_parameters_grad_accum_debug_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    v: T1,
    m: T2,
    gradient_accumulators: T3,
    __args: &LoadTPUEmbeddingProximalYogiParametersGradAccumDebug,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op =
        crate::eager::Op::new(ctx, "LoadTPUEmbeddingProximalYogiParametersGradAccumDebug")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&gradient_accumulators.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingRMSPropParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingRMSPropParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingRMSPropParameters {
    /// Creates a new `LoadTPUEmbeddingRMSPropParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_rmsprop_parameters with default options.
pub fn load_tpuembedding_rmsprop_parameters<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    ms: T1,
    mom: T2,
) -> Result<()> {
    let __args = LoadTPUEmbeddingRMSPropParameters::new();
    load_tpuembedding_rmsprop_parameters_with_args(ctx, parameters, ms, mom, &__args)
}

/// load_tpuembedding_rmsprop_parameters with options.
pub fn load_tpuembedding_rmsprop_parameters_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    ms: T1,
    mom: T2,
    __args: &LoadTPUEmbeddingRMSPropParameters,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingRMSPropParameters")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&ms.to_handle()?)?;
    op.add_input(&mom.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingRMSPropParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingRMSPropParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingRMSPropParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingRMSPropParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_rmsprop_parameters_grad_accum_debug with default options.
pub fn load_tpuembedding_rmsprop_parameters_grad_accum_debug<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    ms: T1,
    mom: T2,
    gradient_accumulators: T3,
) -> Result<()> {
    let __args = LoadTPUEmbeddingRMSPropParametersGradAccumDebug::new();
    load_tpuembedding_rmsprop_parameters_grad_accum_debug_with_args(
        ctx,
        parameters,
        ms,
        mom,
        gradient_accumulators,
        &__args,
    )
}

/// load_tpuembedding_rmsprop_parameters_grad_accum_debug with options.
pub fn load_tpuembedding_rmsprop_parameters_grad_accum_debug_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    ms: T1,
    mom: T2,
    gradient_accumulators: T3,
    __args: &LoadTPUEmbeddingRMSPropParametersGradAccumDebug,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingRMSPropParametersGradAccumDebug")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&ms.to_handle()?)?;
    op.add_input(&mom.to_handle()?)?;
    op.add_input(&gradient_accumulators.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingStochasticGradientDescentParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingStochasticGradientDescentParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingStochasticGradientDescentParameters {
    /// Creates a new `LoadTPUEmbeddingStochasticGradientDescentParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_stochastic_gradient_descent_parameters with default options.
pub fn load_tpuembedding_stochastic_gradient_descent_parameters<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    parameters: T0,
) -> Result<()> {
    let __args = LoadTPUEmbeddingStochasticGradientDescentParameters::new();
    load_tpuembedding_stochastic_gradient_descent_parameters_with_args(ctx, parameters, &__args)
}

/// load_tpuembedding_stochastic_gradient_descent_parameters with options.
pub fn load_tpuembedding_stochastic_gradient_descent_parameters_with_args<
    T0: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    __args: &LoadTPUEmbeddingStochasticGradientDescentParameters,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoadTPUEmbeddingStochasticGradientDescentParameters")?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// load_tpuembedding_stochastic_gradient_descent_parameters_grad_accum_debug with default options.
pub fn load_tpuembedding_stochastic_gradient_descent_parameters_grad_accum_debug<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    gradient_accumulators: T1,
) -> Result<()> {
    let __args = LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug::new();
    load_tpuembedding_stochastic_gradient_descent_parameters_grad_accum_debug_with_args(
        ctx,
        parameters,
        gradient_accumulators,
        &__args,
    )
}

/// load_tpuembedding_stochastic_gradient_descent_parameters_grad_accum_debug with options.
pub fn load_tpuembedding_stochastic_gradient_descent_parameters_grad_accum_debug_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    parameters: T0,
    gradient_accumulators: T1,
    __args: &LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(
        ctx,
        "LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug",
    )?;

    // Required input arguments
    op.add_input(&parameters.to_handle()?)?;
    op.add_input(&gradient_accumulators.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Log
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Log {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Log {
    /// Creates a new `Log`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// log with default options.
pub fn log<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Log::new();
    log_with_args(ctx, x, &__args)
}

/// log with options.
pub fn log_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Log,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Log")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Log1p
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Log1p {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Log1p {
    /// Creates a new `Log1p`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// log1p with default options.
pub fn log1p<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Log1p::new();
    log1p_with_args(ctx, x, &__args)
}

/// log1p with options.
pub fn log1p_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Log1p,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Log1p")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LogMatrixDeterminant
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LogMatrixDeterminant {
    pub T: ::std::option::Option<crate::DataType>,
}

impl LogMatrixDeterminant {
    /// Creates a new `LogMatrixDeterminant`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// log_matrix_determinant with default options.
pub fn log_matrix_determinant<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = LogMatrixDeterminant::new();
    log_matrix_determinant_with_args(ctx, input, &__args)
}

/// log_matrix_determinant with options.
pub fn log_matrix_determinant_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &LogMatrixDeterminant,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LogMatrixDeterminant")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// LogSoftmax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LogSoftmax {
    pub T: ::std::option::Option<crate::DataType>,
}

impl LogSoftmax {
    /// Creates a new `LogSoftmax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// log_softmax with default options.
pub fn log_softmax<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    logits: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = LogSoftmax::new();
    log_softmax_with_args(ctx, logits, &__args)
}

/// log_softmax with options.
pub fn log_softmax_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    logits: T0,
    __args: &LogSoftmax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LogSoftmax")?;

    // Required input arguments
    op.add_input(&logits.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LogUniformCandidateSampler
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LogUniformCandidateSampler {
    pub num_true: ::std::option::Option<i64>,
    pub num_sampled: ::std::option::Option<i64>,
    pub unique: ::std::option::Option<bool>,
    pub range_max: ::std::option::Option<i64>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
}

impl LogUniformCandidateSampler {
    /// Creates a new `LogUniformCandidateSampler`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// log_uniform_candidate_sampler with default options.
pub fn log_uniform_candidate_sampler<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = LogUniformCandidateSampler::new();
    log_uniform_candidate_sampler_with_args(ctx, true_classes, &__args)
}

/// log_uniform_candidate_sampler with options.
pub fn log_uniform_candidate_sampler_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
    __args: &LogUniformCandidateSampler,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LogUniformCandidateSampler")?;

    // Required input arguments
    op.add_input(&true_classes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_true {
        op.set_attr_int("num_true", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_sampled {
        op.set_attr_int("num_sampled", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.unique {
        op.set_attr_bool("unique", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.range_max {
        op.set_attr_int("range_max", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// LogicalAnd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LogicalAnd {}

impl LogicalAnd {
    /// Creates a new `LogicalAnd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// logical_and with default options.
pub fn logical_and<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = LogicalAnd::new();
    logical_and_with_args(ctx, x, y, &__args)
}

/// logical_and with options.
pub fn logical_and_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &LogicalAnd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LogicalAnd")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LogicalNot
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LogicalNot {}

impl LogicalNot {
    /// Creates a new `LogicalNot`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// logical_not with default options.
pub fn logical_not<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = LogicalNot::new();
    logical_not_with_args(ctx, x, &__args)
}

/// logical_not with options.
pub fn logical_not_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &LogicalNot,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LogicalNot")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LogicalOr
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LogicalOr {}

impl LogicalOr {
    /// Creates a new `LogicalOr`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// logical_or with default options.
pub fn logical_or<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = LogicalOr::new();
    logical_or_with_args(ctx, x, y, &__args)
}

/// logical_or with options.
pub fn logical_or_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &LogicalOr,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LogicalOr")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LookupTableExport
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableExport {
    pub Tkeys: ::std::option::Option<crate::DataType>,
    pub Tvalues: ::std::option::Option<crate::DataType>,
}

impl LookupTableExport {
    /// Creates a new `LookupTableExport`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lookup_table_export with default options.
pub fn lookup_table_export<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    table_handle: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = LookupTableExport::new();
    lookup_table_export_with_args(ctx, table_handle, &__args)
}

/// lookup_table_export with options.
pub fn lookup_table_export_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    __args: &LookupTableExport,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LookupTableExport")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tkeys {
        op.set_attr_type("Tkeys", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tvalues {
        op.set_attr_type("Tvalues", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// LookupTableExportV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableExportV2 {
    pub Tkeys: ::std::option::Option<crate::DataType>,
    pub Tvalues: ::std::option::Option<crate::DataType>,
}

impl LookupTableExportV2 {
    /// Creates a new `LookupTableExportV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lookup_table_export_v2 with default options.
pub fn lookup_table_export_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    table_handle: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = LookupTableExportV2::new();
    lookup_table_export_v2_with_args(ctx, table_handle, &__args)
}

/// lookup_table_export_v2 with options.
pub fn lookup_table_export_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    __args: &LookupTableExportV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LookupTableExportV2")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tkeys {
        op.set_attr_type("Tkeys", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tvalues {
        op.set_attr_type("Tvalues", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// LookupTableFind
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableFind {
    pub Tin: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl LookupTableFind {
    /// Creates a new `LookupTableFind`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lookup_table_find with default options.
pub fn lookup_table_find<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    default_value: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = LookupTableFind::new();
    lookup_table_find_with_args(ctx, table_handle, keys, default_value, &__args)
}

/// lookup_table_find with options.
pub fn lookup_table_find_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    default_value: T2,
    __args: &LookupTableFind,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LookupTableFind")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;
    op.add_input(&keys.to_handle()?)?;
    op.add_input(&default_value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type("Tin", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LookupTableFindV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableFindV2 {
    pub Tin: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl LookupTableFindV2 {
    /// Creates a new `LookupTableFindV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lookup_table_find_v2 with default options.
pub fn lookup_table_find_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    default_value: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = LookupTableFindV2::new();
    lookup_table_find_v2_with_args(ctx, table_handle, keys, default_value, &__args)
}

/// lookup_table_find_v2 with options.
pub fn lookup_table_find_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    default_value: T2,
    __args: &LookupTableFindV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LookupTableFindV2")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;
    op.add_input(&keys.to_handle()?)?;
    op.add_input(&default_value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type("Tin", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LookupTableImport
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableImport {
    pub Tin: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl LookupTableImport {
    /// Creates a new `LookupTableImport`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lookup_table_import with default options.
pub fn lookup_table_import<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    values: T2,
) -> Result<()> {
    let __args = LookupTableImport::new();
    lookup_table_import_with_args(ctx, table_handle, keys, values, &__args)
}

/// lookup_table_import with options.
pub fn lookup_table_import_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    values: T2,
    __args: &LookupTableImport,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LookupTableImport")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;
    op.add_input(&keys.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type("Tin", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LookupTableImportV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableImportV2 {
    pub Tin: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl LookupTableImportV2 {
    /// Creates a new `LookupTableImportV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lookup_table_import_v2 with default options.
pub fn lookup_table_import_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    values: T2,
) -> Result<()> {
    let __args = LookupTableImportV2::new();
    lookup_table_import_v2_with_args(ctx, table_handle, keys, values, &__args)
}

/// lookup_table_import_v2 with options.
pub fn lookup_table_import_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    values: T2,
    __args: &LookupTableImportV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LookupTableImportV2")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;
    op.add_input(&keys.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type("Tin", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LookupTableInsert
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableInsert {
    pub Tin: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl LookupTableInsert {
    /// Creates a new `LookupTableInsert`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lookup_table_insert with default options.
pub fn lookup_table_insert<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    values: T2,
) -> Result<()> {
    let __args = LookupTableInsert::new();
    lookup_table_insert_with_args(ctx, table_handle, keys, values, &__args)
}

/// lookup_table_insert with options.
pub fn lookup_table_insert_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    values: T2,
    __args: &LookupTableInsert,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LookupTableInsert")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;
    op.add_input(&keys.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type("Tin", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LookupTableInsertV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableInsertV2 {
    pub Tin: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl LookupTableInsertV2 {
    /// Creates a new `LookupTableInsertV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lookup_table_insert_v2 with default options.
pub fn lookup_table_insert_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    values: T2,
) -> Result<()> {
    let __args = LookupTableInsertV2::new();
    lookup_table_insert_v2_with_args(ctx, table_handle, keys, values, &__args)
}

/// lookup_table_insert_v2 with options.
pub fn lookup_table_insert_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    values: T2,
    __args: &LookupTableInsertV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LookupTableInsertV2")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;
    op.add_input(&keys.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type("Tin", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LookupTableRemoveV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableRemoveV2 {
    pub Tin: ::std::option::Option<crate::DataType>,
}

impl LookupTableRemoveV2 {
    /// Creates a new `LookupTableRemoveV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lookup_table_remove_v2 with default options.
pub fn lookup_table_remove_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
) -> Result<()> {
    let __args = LookupTableRemoveV2::new();
    lookup_table_remove_v2_with_args(ctx, table_handle, keys, &__args)
}

/// lookup_table_remove_v2 with options.
pub fn lookup_table_remove_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    keys: T1,
    __args: &LookupTableRemoveV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LookupTableRemoveV2")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;
    op.add_input(&keys.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type("Tin", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// LookupTableSize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableSize {}

impl LookupTableSize {
    /// Creates a new `LookupTableSize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lookup_table_size with default options.
pub fn lookup_table_size<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    table_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = LookupTableSize::new();
    lookup_table_size_with_args(ctx, table_handle, &__args)
}

/// lookup_table_size with options.
pub fn lookup_table_size_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    __args: &LookupTableSize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LookupTableSize")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LookupTableSizeV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableSizeV2 {}

impl LookupTableSizeV2 {
    /// Creates a new `LookupTableSizeV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lookup_table_size_v2 with default options.
pub fn lookup_table_size_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    table_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = LookupTableSizeV2::new();
    lookup_table_size_v2_with_args(ctx, table_handle, &__args)
}

/// lookup_table_size_v2 with options.
pub fn lookup_table_size_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    table_handle: T0,
    __args: &LookupTableSizeV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LookupTableSizeV2")?;

    // Required input arguments
    op.add_input(&table_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LoopCond
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoopCond {}

impl LoopCond {
    /// Creates a new `LoopCond`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// loop_cond with default options.
pub fn loop_cond<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = LoopCond::new();
    loop_cond_with_args(ctx, input, &__args)
}

/// loop_cond with options.
pub fn loop_cond_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &LoopCond,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LoopCond")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// LowerBound
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LowerBound {
    pub T: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl LowerBound {
    /// Creates a new `LowerBound`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lower_bound with default options.
pub fn lower_bound<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sorted_inputs: T0,
    values: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = LowerBound::new();
    lower_bound_with_args(ctx, sorted_inputs, values, &__args)
}

/// lower_bound with options.
pub fn lower_bound_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sorted_inputs: T0,
    values: T1,
    __args: &LowerBound,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "LowerBound")?;

    // Required input arguments
    op.add_input(&sorted_inputs.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Lu
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Lu {
    pub T: ::std::option::Option<crate::DataType>,
    pub output_idx_type: ::std::option::Option<crate::DataType>,
}

impl Lu {
    /// Creates a new `Lu`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// lu with default options.
pub fn lu<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = Lu::new();
    lu_with_args(ctx, input, &__args)
}

/// lu with options.
pub fn lu_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Lu,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Lu")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_idx_type {
        op.set_attr_type("output_idx_type", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// MakeIterator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MakeIterator {}

impl MakeIterator {
    /// Creates a new `MakeIterator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// make_iterator with default options.
pub fn make_iterator<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    dataset: T0,
    iterator: T1,
) -> Result<()> {
    let __args = MakeIterator::new();
    make_iterator_with_args(ctx, dataset, iterator, &__args)
}

/// make_iterator with options.
pub fn make_iterator_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    dataset: T0,
    iterator: T1,
    __args: &MakeIterator,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MakeIterator")?;

    // Required input arguments
    op.add_input(&dataset.to_handle()?)?;
    op.add_input(&iterator.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// MakeUnique
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MakeUnique {}

impl MakeUnique {
    /// Creates a new `MakeUnique`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// make_unique with default options.
pub fn make_unique<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MakeUnique::new();
    make_unique_with_args(ctx, input, &__args)
}

/// make_unique with options.
pub fn make_unique_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &MakeUnique,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MakeUnique")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MapAndBatchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapAndBatchDataset {
    pub f: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub preserve_cardinality: ::std::option::Option<bool>,
}

impl MapAndBatchDataset {
    /// Creates a new `MapAndBatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// map_and_batch_dataset with default options.
pub fn map_and_batch_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    batch_size: T2,
    num_parallel_calls: T3,
    drop_remainder: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = MapAndBatchDataset::new();
    map_and_batch_dataset_with_args(
        ctx,
        input_dataset,
        other_arguments,
        batch_size,
        num_parallel_calls,
        drop_remainder,
        &__args,
    )
}

/// map_and_batch_dataset with options.
pub fn map_and_batch_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    batch_size: T2,
    num_parallel_calls: T3,
    drop_remainder: T4,
    __args: &MapAndBatchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MapAndBatchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;
    op.add_input(&batch_size.to_handle()?)?;
    op.add_input(&num_parallel_calls.to_handle()?)?;
    op.add_input(&drop_remainder.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.preserve_cardinality {
        op.set_attr_bool("preserve_cardinality", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MapClear
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapClear {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl MapClear {
    /// Creates a new `MapClear`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// map_clear with default options.
pub fn map_clear(ctx: &crate::eager::Context) -> Result<()> {
    let __args = MapClear::new();
    map_clear_with_args(ctx, &__args)
}

/// map_clear with options.
pub fn map_clear_with_args(ctx: &crate::eager::Context, __args: &MapClear) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MapClear")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// MapDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapDataset {
    pub f: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub use_inter_op_parallelism: ::std::option::Option<bool>,
    pub preserve_cardinality: ::std::option::Option<bool>,
}

impl MapDataset {
    /// Creates a new `MapDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// map_dataset with default options.
pub fn map_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MapDataset::new();
    map_dataset_with_args(ctx, input_dataset, other_arguments, &__args)
}

/// map_dataset with options.
pub fn map_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    __args: &MapDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MapDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.use_inter_op_parallelism {
        op.set_attr_bool("use_inter_op_parallelism", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.preserve_cardinality {
        op.set_attr_bool("preserve_cardinality", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MapDefun
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapDefun {
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tcaptured: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub f: ::std::option::Option<::std::string::String>,
    pub max_intra_op_parallelism: ::std::option::Option<i64>,
}

impl MapDefun {
    /// Creates a new `MapDefun`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// map_defun with default options.
pub fn map_defun<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    arguments: T0,
    captured_inputs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MapDefun::new();
    map_defun_with_args(ctx, arguments, captured_inputs, &__args)
}

/// map_defun with options.
pub fn map_defun_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    arguments: T0,
    captured_inputs: T1,
    __args: &MapDefun,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MapDefun")?;

    // Required input arguments
    op.add_input(&arguments.to_handle()?)?;
    op.add_input(&captured_inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcaptured {
        op.set_attr_type_list("Tcaptured", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_intra_op_parallelism {
        op.set_attr_int("max_intra_op_parallelism", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MapIncompleteSize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapIncompleteSize {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl MapIncompleteSize {
    /// Creates a new `MapIncompleteSize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// map_incomplete_size with default options.
pub fn map_incomplete_size(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = MapIncompleteSize::new();
    map_incomplete_size_with_args(ctx, &__args)
}

/// map_incomplete_size with options.
pub fn map_incomplete_size_with_args(
    ctx: &crate::eager::Context,
    __args: &MapIncompleteSize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MapIncompleteSize")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MapPeek
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapPeek {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl MapPeek {
    /// Creates a new `MapPeek`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// map_peek with default options.
pub fn map_peek<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    key: T0,
    indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MapPeek::new();
    map_peek_with_args(ctx, key, indices, &__args)
}

/// map_peek with options.
pub fn map_peek_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    key: T0,
    indices: T1,
    __args: &MapPeek,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MapPeek")?;

    // Required input arguments
    op.add_input(&key.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MapSize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapSize {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl MapSize {
    /// Creates a new `MapSize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// map_size with default options.
pub fn map_size(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = MapSize::new();
    map_size_with_args(ctx, &__args)
}

/// map_size with options.
pub fn map_size_with_args(
    ctx: &crate::eager::Context,
    __args: &MapSize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MapSize")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MapStage
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapStage {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub fake_dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl MapStage {
    /// Creates a new `MapStage`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// map_stage with default options.
pub fn map_stage<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    key: T0,
    indices: T1,
    values: T2,
) -> Result<()> {
    let __args = MapStage::new();
    map_stage_with_args(ctx, key, indices, values, &__args)
}

/// map_stage with options.
pub fn map_stage_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    key: T0,
    indices: T1,
    values: T2,
    __args: &MapStage,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MapStage")?;

    // Required input arguments
    op.add_input(&key.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.fake_dtypes {
        op.set_attr_type_list("fake_dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// MapUnstage
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapUnstage {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl MapUnstage {
    /// Creates a new `MapUnstage`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// map_unstage with default options.
pub fn map_unstage<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    key: T0,
    indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MapUnstage::new();
    map_unstage_with_args(ctx, key, indices, &__args)
}

/// map_unstage with options.
pub fn map_unstage_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    key: T0,
    indices: T1,
    __args: &MapUnstage,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MapUnstage")?;

    // Required input arguments
    op.add_input(&key.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MapUnstageNoKey
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapUnstageNoKey {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl MapUnstageNoKey {
    /// Creates a new `MapUnstageNoKey`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// map_unstage_no_key with default options.
pub fn map_unstage_no_key<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    indices: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = MapUnstageNoKey::new();
    map_unstage_no_key_with_args(ctx, indices, &__args)
}

/// map_unstage_no_key with options.
pub fn map_unstage_no_key_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    indices: T0,
    __args: &MapUnstageNoKey,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MapUnstageNoKey")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// MatMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatMul {
    pub transpose_a: ::std::option::Option<bool>,
    pub transpose_b: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatMul {
    /// Creates a new `MatMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mat_mul with default options.
pub fn mat_mul<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatMul::new();
    mat_mul_with_args(ctx, a, b, &__args)
}

/// mat_mul with options.
pub fn mat_mul_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    __args: &MatMul,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatMul")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.transpose_a {
        op.set_attr_bool("transpose_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_b {
        op.set_attr_bool("transpose_b", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatchingFiles
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatchingFiles {}

impl MatchingFiles {
    /// Creates a new `MatchingFiles`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matching_files with default options.
pub fn matching_files<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    pattern: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatchingFiles::new();
    matching_files_with_args(ctx, pattern, &__args)
}

/// matching_files with options.
pub fn matching_files_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    pattern: T0,
    __args: &MatchingFiles,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatchingFiles")?;

    // Required input arguments
    op.add_input(&pattern.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatchingFilesDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatchingFilesDataset {}

impl MatchingFilesDataset {
    /// Creates a new `MatchingFilesDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matching_files_dataset with default options.
pub fn matching_files_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    patterns: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatchingFilesDataset::new();
    matching_files_dataset_with_args(ctx, patterns, &__args)
}

/// matching_files_dataset with options.
pub fn matching_files_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    patterns: T0,
    __args: &MatchingFilesDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatchingFilesDataset")?;

    // Required input arguments
    op.add_input(&patterns.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixBandPart
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixBandPart {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindex: ::std::option::Option<crate::DataType>,
}

impl MatrixBandPart {
    /// Creates a new `MatrixBandPart`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_band_part with default options.
pub fn matrix_band_part<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    num_lower: T1,
    num_upper: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixBandPart::new();
    matrix_band_part_with_args(ctx, input, num_lower, num_upper, &__args)
}

/// matrix_band_part with options.
pub fn matrix_band_part_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    num_lower: T1,
    num_upper: T2,
    __args: &MatrixBandPart,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixBandPart")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&num_lower.to_handle()?)?;
    op.add_input(&num_upper.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindex {
        op.set_attr_type("Tindex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixDeterminant
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDeterminant {
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixDeterminant {
    /// Creates a new `MatrixDeterminant`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_determinant with default options.
pub fn matrix_determinant<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixDeterminant::new();
    matrix_determinant_with_args(ctx, input, &__args)
}

/// matrix_determinant with options.
pub fn matrix_determinant_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &MatrixDeterminant,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixDeterminant")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixDiag
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDiag {
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixDiag {
    /// Creates a new `MatrixDiag`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_diag with default options.
pub fn matrix_diag<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    diagonal: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixDiag::new();
    matrix_diag_with_args(ctx, diagonal, &__args)
}

/// matrix_diag with options.
pub fn matrix_diag_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    diagonal: T0,
    __args: &MatrixDiag,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixDiag")?;

    // Required input arguments
    op.add_input(&diagonal.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixDiagPart
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDiagPart {
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixDiagPart {
    /// Creates a new `MatrixDiagPart`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_diag_part with default options.
pub fn matrix_diag_part<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixDiagPart::new();
    matrix_diag_part_with_args(ctx, input, &__args)
}

/// matrix_diag_part with options.
pub fn matrix_diag_part_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &MatrixDiagPart,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixDiagPart")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixDiagPartV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDiagPartV2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixDiagPartV2 {
    /// Creates a new `MatrixDiagPartV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_diag_part_v2 with default options.
pub fn matrix_diag_part_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    k: T1,
    padding_value: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixDiagPartV2::new();
    matrix_diag_part_v2_with_args(ctx, input, k, padding_value, &__args)
}

/// matrix_diag_part_v2 with options.
pub fn matrix_diag_part_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    k: T1,
    padding_value: T2,
    __args: &MatrixDiagPartV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixDiagPartV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&k.to_handle()?)?;
    op.add_input(&padding_value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixDiagPartV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDiagPartV3 {
    pub T: ::std::option::Option<crate::DataType>,
    pub align: ::std::option::Option<::std::string::String>,
}

impl MatrixDiagPartV3 {
    /// Creates a new `MatrixDiagPartV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_diag_part_v3 with default options.
pub fn matrix_diag_part_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    k: T1,
    padding_value: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixDiagPartV3::new();
    matrix_diag_part_v3_with_args(ctx, input, k, padding_value, &__args)
}

/// matrix_diag_part_v3 with options.
pub fn matrix_diag_part_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    k: T1,
    padding_value: T2,
    __args: &MatrixDiagPartV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixDiagPartV3")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&k.to_handle()?)?;
    op.add_input(&padding_value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.align {
        op.set_attr_string("align", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixDiagV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDiagV2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixDiagV2 {
    /// Creates a new `MatrixDiagV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_diag_v2 with default options.
pub fn matrix_diag_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    diagonal: T0,
    k: T1,
    num_rows: T2,
    num_cols: T3,
    padding_value: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixDiagV2::new();
    matrix_diag_v2_with_args(ctx, diagonal, k, num_rows, num_cols, padding_value, &__args)
}

/// matrix_diag_v2 with options.
pub fn matrix_diag_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    diagonal: T0,
    k: T1,
    num_rows: T2,
    num_cols: T3,
    padding_value: T4,
    __args: &MatrixDiagV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixDiagV2")?;

    // Required input arguments
    op.add_input(&diagonal.to_handle()?)?;
    op.add_input(&k.to_handle()?)?;
    op.add_input(&num_rows.to_handle()?)?;
    op.add_input(&num_cols.to_handle()?)?;
    op.add_input(&padding_value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixDiagV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDiagV3 {
    pub T: ::std::option::Option<crate::DataType>,
    pub align: ::std::option::Option<::std::string::String>,
}

impl MatrixDiagV3 {
    /// Creates a new `MatrixDiagV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_diag_v3 with default options.
pub fn matrix_diag_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    diagonal: T0,
    k: T1,
    num_rows: T2,
    num_cols: T3,
    padding_value: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixDiagV3::new();
    matrix_diag_v3_with_args(ctx, diagonal, k, num_rows, num_cols, padding_value, &__args)
}

/// matrix_diag_v3 with options.
pub fn matrix_diag_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    diagonal: T0,
    k: T1,
    num_rows: T2,
    num_cols: T3,
    padding_value: T4,
    __args: &MatrixDiagV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixDiagV3")?;

    // Required input arguments
    op.add_input(&diagonal.to_handle()?)?;
    op.add_input(&k.to_handle()?)?;
    op.add_input(&num_rows.to_handle()?)?;
    op.add_input(&num_cols.to_handle()?)?;
    op.add_input(&padding_value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.align {
        op.set_attr_string("align", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixExponential
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixExponential {
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixExponential {
    /// Creates a new `MatrixExponential`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_exponential with default options.
pub fn matrix_exponential<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixExponential::new();
    matrix_exponential_with_args(ctx, input, &__args)
}

/// matrix_exponential with options.
pub fn matrix_exponential_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &MatrixExponential,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixExponential")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixInverse
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixInverse {
    pub adjoint: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixInverse {
    /// Creates a new `MatrixInverse`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_inverse with default options.
pub fn matrix_inverse<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixInverse::new();
    matrix_inverse_with_args(ctx, input, &__args)
}

/// matrix_inverse with options.
pub fn matrix_inverse_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &MatrixInverse,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixInverse")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.adjoint {
        op.set_attr_bool("adjoint", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixLogarithm
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixLogarithm {
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixLogarithm {
    /// Creates a new `MatrixLogarithm`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_logarithm with default options.
pub fn matrix_logarithm<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixLogarithm::new();
    matrix_logarithm_with_args(ctx, input, &__args)
}

/// matrix_logarithm with options.
pub fn matrix_logarithm_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &MatrixLogarithm,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixLogarithm")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixSetDiag
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixSetDiag {
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixSetDiag {
    /// Creates a new `MatrixSetDiag`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_set_diag with default options.
pub fn matrix_set_diag<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    diagonal: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixSetDiag::new();
    matrix_set_diag_with_args(ctx, input, diagonal, &__args)
}

/// matrix_set_diag with options.
pub fn matrix_set_diag_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    diagonal: T1,
    __args: &MatrixSetDiag,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixSetDiag")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&diagonal.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixSetDiagV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixSetDiagV2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixSetDiagV2 {
    /// Creates a new `MatrixSetDiagV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_set_diag_v2 with default options.
pub fn matrix_set_diag_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    diagonal: T1,
    k: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixSetDiagV2::new();
    matrix_set_diag_v2_with_args(ctx, input, diagonal, k, &__args)
}

/// matrix_set_diag_v2 with options.
pub fn matrix_set_diag_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    diagonal: T1,
    k: T2,
    __args: &MatrixSetDiagV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixSetDiagV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&diagonal.to_handle()?)?;
    op.add_input(&k.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixSetDiagV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixSetDiagV3 {
    pub T: ::std::option::Option<crate::DataType>,
    pub align: ::std::option::Option<::std::string::String>,
}

impl MatrixSetDiagV3 {
    /// Creates a new `MatrixSetDiagV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_set_diag_v3 with default options.
pub fn matrix_set_diag_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    diagonal: T1,
    k: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixSetDiagV3::new();
    matrix_set_diag_v3_with_args(ctx, input, diagonal, k, &__args)
}

/// matrix_set_diag_v3 with options.
pub fn matrix_set_diag_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    diagonal: T1,
    k: T2,
    __args: &MatrixSetDiagV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixSetDiagV3")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&diagonal.to_handle()?)?;
    op.add_input(&k.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.align {
        op.set_attr_string("align", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixSolve
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixSolve {
    pub adjoint: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixSolve {
    /// Creates a new `MatrixSolve`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_solve with default options.
pub fn matrix_solve<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixSolve::new();
    matrix_solve_with_args(ctx, matrix, rhs, &__args)
}

/// matrix_solve with options.
pub fn matrix_solve_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
    __args: &MatrixSolve,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixSolve")?;

    // Required input arguments
    op.add_input(&matrix.to_handle()?)?;
    op.add_input(&rhs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.adjoint {
        op.set_attr_bool("adjoint", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixSolveLs
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixSolveLs {
    pub T: ::std::option::Option<crate::DataType>,
    pub fast: ::std::option::Option<bool>,
}

impl MatrixSolveLs {
    /// Creates a new `MatrixSolveLs`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_solve_ls with default options.
pub fn matrix_solve_ls<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
    l2_regularizer: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixSolveLs::new();
    matrix_solve_ls_with_args(ctx, matrix, rhs, l2_regularizer, &__args)
}

/// matrix_solve_ls with options.
pub fn matrix_solve_ls_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
    l2_regularizer: T2,
    __args: &MatrixSolveLs,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixSolveLs")?;

    // Required input arguments
    op.add_input(&matrix.to_handle()?)?;
    op.add_input(&rhs.to_handle()?)?;
    op.add_input(&l2_regularizer.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.fast {
        op.set_attr_bool("fast", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixSquareRoot
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixSquareRoot {
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixSquareRoot {
    /// Creates a new `MatrixSquareRoot`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_square_root with default options.
pub fn matrix_square_root<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixSquareRoot::new();
    matrix_square_root_with_args(ctx, input, &__args)
}

/// matrix_square_root with options.
pub fn matrix_square_root_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &MatrixSquareRoot,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixSquareRoot")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MatrixTriangularSolve
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixTriangularSolve {
    pub lower: ::std::option::Option<bool>,
    pub adjoint: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MatrixTriangularSolve {
    /// Creates a new `MatrixTriangularSolve`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// matrix_triangular_solve with default options.
pub fn matrix_triangular_solve<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MatrixTriangularSolve::new();
    matrix_triangular_solve_with_args(ctx, matrix, rhs, &__args)
}

/// matrix_triangular_solve with options.
pub fn matrix_triangular_solve_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
    __args: &MatrixTriangularSolve,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MatrixTriangularSolve")?;

    // Required input arguments
    op.add_input(&matrix.to_handle()?)?;
    op.add_input(&rhs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.lower {
        op.set_attr_bool("lower", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adjoint {
        op.set_attr_bool("adjoint", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Max
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Max {
    pub keep_dims: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl Max {
    /// Creates a new `Max`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max with default options.
pub fn max<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Max::new();
    max_with_args(ctx, input, reduction_indices, &__args)
}

/// max with options.
pub fn max_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
    __args: &Max,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Max")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&reduction_indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxIntraOpParallelismDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxIntraOpParallelismDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl MaxIntraOpParallelismDataset {
    /// Creates a new `MaxIntraOpParallelismDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_intra_op_parallelism_dataset with default options.
pub fn max_intra_op_parallelism_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    max_intra_op_parallelism: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MaxIntraOpParallelismDataset::new();
    max_intra_op_parallelism_dataset_with_args(
        ctx,
        input_dataset,
        max_intra_op_parallelism,
        &__args,
    )
}

/// max_intra_op_parallelism_dataset with options.
pub fn max_intra_op_parallelism_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    max_intra_op_parallelism: T1,
    __args: &MaxIntraOpParallelismDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxIntraOpParallelismDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&max_intra_op_parallelism.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxPool
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPool {
    pub T: ::std::option::Option<crate::DataType>,
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    pub data_format: ::std::option::Option<::std::string::String>,
}

impl MaxPool {
    /// Creates a new `MaxPool`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_pool with default options.
pub fn max_pool<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MaxPool::new();
    max_pool_with_args(ctx, input, &__args)
}

/// max_pool with options.
pub fn max_pool_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &MaxPool,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxPool")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.explicit_paddings {
        op.set_attr_int_list("explicit_paddings", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxPool3D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPool3D {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MaxPool3D {
    /// Creates a new `MaxPool3D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_pool3_d with default options.
pub fn max_pool3_d<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MaxPool3D::new();
    max_pool3_d_with_args(ctx, input, &__args)
}

/// max_pool3_d with options.
pub fn max_pool3_d_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &MaxPool3D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxPool3D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxPool3DGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPool3DGrad {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
    pub TInput: ::std::option::Option<crate::DataType>,
}

impl MaxPool3DGrad {
    /// Creates a new `MaxPool3DGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_pool3_dgrad with default options.
pub fn max_pool3_dgrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    grad: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MaxPool3DGrad::new();
    max_pool3_dgrad_with_args(ctx, orig_input, orig_output, grad, &__args)
}

/// max_pool3_dgrad with options.
pub fn max_pool3_dgrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    grad: T2,
    __args: &MaxPool3DGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxPool3DGrad")?;

    // Required input arguments
    op.add_input(&orig_input.to_handle()?)?;
    op.add_input(&orig_output.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.TInput {
        op.set_attr_type("TInput", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxPool3DGradGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPool3DGradGrad {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MaxPool3DGradGrad {
    /// Creates a new `MaxPool3DGradGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_pool3_dgrad_grad with default options.
pub fn max_pool3_dgrad_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    grad: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MaxPool3DGradGrad::new();
    max_pool3_dgrad_grad_with_args(ctx, orig_input, orig_output, grad, &__args)
}

/// max_pool3_dgrad_grad with options.
pub fn max_pool3_dgrad_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    grad: T2,
    __args: &MaxPool3DGradGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxPool3DGradGrad")?;

    // Required input arguments
    op.add_input(&orig_input.to_handle()?)?;
    op.add_input(&orig_output.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxPoolGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolGrad {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MaxPoolGrad {
    /// Creates a new `MaxPoolGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_pool_grad with default options.
pub fn max_pool_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    grad: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MaxPoolGrad::new();
    max_pool_grad_with_args(ctx, orig_input, orig_output, grad, &__args)
}

/// max_pool_grad with options.
pub fn max_pool_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    grad: T2,
    __args: &MaxPoolGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxPoolGrad")?;

    // Required input arguments
    op.add_input(&orig_input.to_handle()?)?;
    op.add_input(&orig_output.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.explicit_paddings {
        op.set_attr_int_list("explicit_paddings", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxPoolGradGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolGradGrad {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MaxPoolGradGrad {
    /// Creates a new `MaxPoolGradGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_pool_grad_grad with default options.
pub fn max_pool_grad_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    grad: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MaxPoolGradGrad::new();
    max_pool_grad_grad_with_args(ctx, orig_input, orig_output, grad, &__args)
}

/// max_pool_grad_grad with options.
pub fn max_pool_grad_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    grad: T2,
    __args: &MaxPoolGradGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxPoolGradGrad")?;

    // Required input arguments
    op.add_input(&orig_input.to_handle()?)?;
    op.add_input(&orig_output.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxPoolGradGradV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolGradGradV2 {
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MaxPoolGradGradV2 {
    /// Creates a new `MaxPoolGradGradV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_pool_grad_grad_v2 with default options.
pub fn max_pool_grad_grad_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    grad: T2,
    ksize: T3,
    strides: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = MaxPoolGradGradV2::new();
    max_pool_grad_grad_v2_with_args(ctx, orig_input, orig_output, grad, ksize, strides, &__args)
}

/// max_pool_grad_grad_v2 with options.
pub fn max_pool_grad_grad_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    grad: T2,
    ksize: T3,
    strides: T4,
    __args: &MaxPoolGradGradV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxPoolGradGradV2")?;

    // Required input arguments
    op.add_input(&orig_input.to_handle()?)?;
    op.add_input(&orig_output.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&ksize.to_handle()?)?;
    op.add_input(&strides.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxPoolGradGradWithArgmax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolGradGradWithArgmax {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub include_batch_in_index: ::std::option::Option<bool>,
    pub Targmax: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MaxPoolGradGradWithArgmax {
    /// Creates a new `MaxPoolGradGradWithArgmax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_pool_grad_grad_with_argmax with default options.
pub fn max_pool_grad_grad_with_argmax<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    grad: T1,
    argmax: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MaxPoolGradGradWithArgmax::new();
    max_pool_grad_grad_with_argmax_with_args(ctx, input, grad, argmax, &__args)
}

/// max_pool_grad_grad_with_argmax with options.
pub fn max_pool_grad_grad_with_argmax_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    grad: T1,
    argmax: T2,
    __args: &MaxPoolGradGradWithArgmax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxPoolGradGradWithArgmax")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&argmax.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.include_batch_in_index {
        op.set_attr_bool("include_batch_in_index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targmax {
        op.set_attr_type("Targmax", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxPoolGradV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolGradV2 {
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MaxPoolGradV2 {
    /// Creates a new `MaxPoolGradV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_pool_grad_v2 with default options.
pub fn max_pool_grad_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    grad: T2,
    ksize: T3,
    strides: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = MaxPoolGradV2::new();
    max_pool_grad_v2_with_args(ctx, orig_input, orig_output, grad, ksize, strides, &__args)
}

/// max_pool_grad_v2 with options.
pub fn max_pool_grad_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    orig_input: T0,
    orig_output: T1,
    grad: T2,
    ksize: T3,
    strides: T4,
    __args: &MaxPoolGradV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxPoolGradV2")?;

    // Required input arguments
    op.add_input(&orig_input.to_handle()?)?;
    op.add_input(&orig_output.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&ksize.to_handle()?)?;
    op.add_input(&strides.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxPoolGradWithArgmax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolGradWithArgmax {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub include_batch_in_index: ::std::option::Option<bool>,
    pub Targmax: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MaxPoolGradWithArgmax {
    /// Creates a new `MaxPoolGradWithArgmax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_pool_grad_with_argmax with default options.
pub fn max_pool_grad_with_argmax<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    grad: T1,
    argmax: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MaxPoolGradWithArgmax::new();
    max_pool_grad_with_argmax_with_args(ctx, input, grad, argmax, &__args)
}

/// max_pool_grad_with_argmax with options.
pub fn max_pool_grad_with_argmax_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    grad: T1,
    argmax: T2,
    __args: &MaxPoolGradWithArgmax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxPoolGradWithArgmax")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&argmax.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.include_batch_in_index {
        op.set_attr_bool("include_batch_in_index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targmax {
        op.set_attr_type("Targmax", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxPoolV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
}

impl MaxPoolV2 {
    /// Creates a new `MaxPoolV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_pool_v2 with default options.
pub fn max_pool_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    ksize: T1,
    strides: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MaxPoolV2::new();
    max_pool_v2_with_args(ctx, input, ksize, strides, &__args)
}

/// max_pool_v2 with options.
pub fn max_pool_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    ksize: T1,
    strides: T2,
    __args: &MaxPoolV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxPoolV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&ksize.to_handle()?)?;
    op.add_input(&strides.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MaxPoolWithArgmax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolWithArgmax {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub Targmax: ::std::option::Option<crate::DataType>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub include_batch_in_index: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl MaxPoolWithArgmax {
    /// Creates a new `MaxPoolWithArgmax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// max_pool_with_argmax with default options.
pub fn max_pool_with_argmax<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = MaxPoolWithArgmax::new();
    max_pool_with_argmax_with_args(ctx, input, &__args)
}

/// max_pool_with_argmax with options.
pub fn max_pool_with_argmax_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &MaxPoolWithArgmax,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MaxPoolWithArgmax")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targmax {
        op.set_attr_type("Targmax", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.include_batch_in_index {
        op.set_attr_bool("include_batch_in_index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Maximum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Maximum {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Maximum {
    /// Creates a new `Maximum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// maximum with default options.
pub fn maximum<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Maximum::new();
    maximum_with_args(ctx, x, y, &__args)
}

/// maximum with options.
pub fn maximum_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Maximum,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Maximum")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Mean
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Mean {
    pub keep_dims: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl Mean {
    /// Creates a new `Mean`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mean with default options.
pub fn mean<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Mean::new();
    mean_with_args(ctx, input, reduction_indices, &__args)
}

/// mean with options.
pub fn mean_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
    __args: &Mean,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Mean")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&reduction_indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Merge
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Merge {
    pub T: ::std::option::Option<crate::DataType>,
    pub N: ::std::option::Option<i64>,
}

impl Merge {
    /// Creates a new `Merge`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// merge with default options.
pub fn merge<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = Merge::new();
    merge_with_args(ctx, inputs, &__args)
}

/// merge with options.
pub fn merge_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &Merge,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Merge")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// MergeSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MergeSummary {
    pub N: ::std::option::Option<i64>,
}

impl MergeSummary {
    /// Creates a new `MergeSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// merge_summary with default options.
pub fn merge_summary<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MergeSummary::new();
    merge_summary_with_args(ctx, inputs, &__args)
}

/// merge_summary with options.
pub fn merge_summary_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &MergeSummary,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MergeSummary")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MergeV2Checkpoints
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MergeV2Checkpoints {
    pub delete_old_dirs: ::std::option::Option<bool>,
}

impl MergeV2Checkpoints {
    /// Creates a new `MergeV2Checkpoints`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// merge_v2_checkpoints with default options.
pub fn merge_v2_checkpoints<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    checkpoint_prefixes: T0,
    destination_prefix: T1,
) -> Result<()> {
    let __args = MergeV2Checkpoints::new();
    merge_v2_checkpoints_with_args(ctx, checkpoint_prefixes, destination_prefix, &__args)
}

/// merge_v2_checkpoints with options.
pub fn merge_v2_checkpoints_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    checkpoint_prefixes: T0,
    destination_prefix: T1,
    __args: &MergeV2Checkpoints,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MergeV2Checkpoints")?;

    // Required input arguments
    op.add_input(&checkpoint_prefixes.to_handle()?)?;
    op.add_input(&destination_prefix.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.delete_old_dirs {
        op.set_attr_bool("delete_old_dirs", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Mfcc
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Mfcc {
    pub upper_frequency_limit: ::std::option::Option<f32>,
    pub lower_frequency_limit: ::std::option::Option<f32>,
    pub filterbank_channel_count: ::std::option::Option<i64>,
    pub dct_coefficient_count: ::std::option::Option<i64>,
}

impl Mfcc {
    /// Creates a new `Mfcc`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mfcc with default options.
pub fn mfcc<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    spectrogram: T0,
    sample_rate: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Mfcc::new();
    mfcc_with_args(ctx, spectrogram, sample_rate, &__args)
}

/// mfcc with options.
pub fn mfcc_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    spectrogram: T0,
    sample_rate: T1,
    __args: &Mfcc,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Mfcc")?;

    // Required input arguments
    op.add_input(&spectrogram.to_handle()?)?;
    op.add_input(&sample_rate.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.upper_frequency_limit {
        op.set_attr_float("upper_frequency_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.lower_frequency_limit {
        op.set_attr_float("lower_frequency_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.filterbank_channel_count {
        op.set_attr_int("filterbank_channel_count", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dct_coefficient_count {
        op.set_attr_int("dct_coefficient_count", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Min
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Min {
    pub keep_dims: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl Min {
    /// Creates a new `Min`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// min with default options.
pub fn min<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Min::new();
    min_with_args(ctx, input, reduction_indices, &__args)
}

/// min with options.
pub fn min_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
    __args: &Min,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Min")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&reduction_indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Minimum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Minimum {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Minimum {
    /// Creates a new `Minimum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// minimum with default options.
pub fn minimum<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Minimum::new();
    minimum_with_args(ctx, x, y, &__args)
}

/// minimum with options.
pub fn minimum_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Minimum,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Minimum")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MirrorPad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MirrorPad {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tpaddings: ::std::option::Option<crate::DataType>,
    pub mode: ::std::option::Option<::std::string::String>,
}

impl MirrorPad {
    /// Creates a new `MirrorPad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mirror_pad with default options.
pub fn mirror_pad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MirrorPad::new();
    mirror_pad_with_args(ctx, input, paddings, &__args)
}

/// mirror_pad with options.
pub fn mirror_pad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
    __args: &MirrorPad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MirrorPad")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&paddings.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tpaddings {
        op.set_attr_type("Tpaddings", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.mode {
        op.set_attr_string("mode", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MirrorPadGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MirrorPadGrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tpaddings: ::std::option::Option<crate::DataType>,
    pub mode: ::std::option::Option<::std::string::String>,
}

impl MirrorPadGrad {
    /// Creates a new `MirrorPadGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mirror_pad_grad with default options.
pub fn mirror_pad_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MirrorPadGrad::new();
    mirror_pad_grad_with_args(ctx, input, paddings, &__args)
}

/// mirror_pad_grad with options.
pub fn mirror_pad_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
    __args: &MirrorPadGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MirrorPadGrad")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&paddings.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tpaddings {
        op.set_attr_type("Tpaddings", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.mode {
        op.set_attr_string("mode", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MlirPassthroughOp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MlirPassthroughOp {
    pub mlir_module: ::std::option::Option<::std::string::String>,
    pub Tinputs: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Toutputs: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl MlirPassthroughOp {
    /// Creates a new `MlirPassthroughOp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mlir_passthrough_op with default options.
pub fn mlir_passthrough_op<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MlirPassthroughOp::new();
    mlir_passthrough_op_with_args(ctx, inputs, &__args)
}

/// mlir_passthrough_op with options.
pub fn mlir_passthrough_op_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &MlirPassthroughOp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MlirPassthroughOp")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.mlir_module {
        op.set_attr_string("mlir_module", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tinputs {
        op.set_attr_type_list("Tinputs", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Toutputs {
        op.set_attr_type_list("Toutputs", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Mod
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Mod {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Mod {
    /// Creates a new `Mod`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mod_ with default options.
pub fn mod_<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Mod::new();
    mod__with_args(ctx, x, y, &__args)
}

/// mod_ with options.
pub fn mod__with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Mod,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Mod")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ModelDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ModelDataset {
    pub algorithm: ::std::option::Option<i64>,
    pub cpu_budget: ::std::option::Option<i64>,
    pub ram_budget: ::std::option::Option<i64>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ModelDataset {
    /// Creates a new `ModelDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// model_dataset with default options.
pub fn model_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ModelDataset::new();
    model_dataset_with_args(ctx, input_dataset, &__args)
}

/// model_dataset with options.
pub fn model_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &ModelDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ModelDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.algorithm {
        op.set_attr_int("algorithm", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.cpu_budget {
        op.set_attr_int("cpu_budget", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ram_budget {
        op.set_attr_int("ram_budget", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Mul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Mul {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Mul {
    /// Creates a new `Mul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mul with default options.
pub fn mul<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Mul::new();
    mul_with_args(ctx, x, y, &__args)
}

/// mul with options.
pub fn mul_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Mul,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Mul")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MulNoNan
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MulNoNan {
    pub T: ::std::option::Option<crate::DataType>,
}

impl MulNoNan {
    /// Creates a new `MulNoNan`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mul_no_nan with default options.
pub fn mul_no_nan<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MulNoNan::new();
    mul_no_nan_with_args(ctx, x, y, &__args)
}

/// mul_no_nan with options.
pub fn mul_no_nan_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &MulNoNan,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MulNoNan")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MultiDeviceIterator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MultiDeviceIterator {
    pub devices: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub container: ::std::option::Option<::std::string::String>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl MultiDeviceIterator {
    /// Creates a new `MultiDeviceIterator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// multi_device_iterator with default options.
pub fn multi_device_iterator(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = MultiDeviceIterator::new();
    multi_device_iterator_with_args(ctx, &__args)
}

/// multi_device_iterator with options.
pub fn multi_device_iterator_with_args(
    ctx: &crate::eager::Context,
    __args: &MultiDeviceIterator,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MultiDeviceIterator")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.devices {
        op.set_attr_string_list("devices", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MultiDeviceIteratorFromStringHandle
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MultiDeviceIteratorFromStringHandle {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl MultiDeviceIteratorFromStringHandle {
    /// Creates a new `MultiDeviceIteratorFromStringHandle`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// multi_device_iterator_from_string_handle with default options.
pub fn multi_device_iterator_from_string_handle<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    string_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MultiDeviceIteratorFromStringHandle::new();
    multi_device_iterator_from_string_handle_with_args(ctx, string_handle, &__args)
}

/// multi_device_iterator_from_string_handle with options.
pub fn multi_device_iterator_from_string_handle_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    string_handle: T0,
    __args: &MultiDeviceIteratorFromStringHandle,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MultiDeviceIteratorFromStringHandle")?;

    // Required input arguments
    op.add_input(&string_handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MultiDeviceIteratorGetNextFromShard
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MultiDeviceIteratorGetNextFromShard {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl MultiDeviceIteratorGetNextFromShard {
    /// Creates a new `MultiDeviceIteratorGetNextFromShard`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// multi_device_iterator_get_next_from_shard with default options.
pub fn multi_device_iterator_get_next_from_shard<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    multi_device_iterator: T0,
    shard_num: T1,
    incarnation_id: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MultiDeviceIteratorGetNextFromShard::new();
    multi_device_iterator_get_next_from_shard_with_args(
        ctx,
        multi_device_iterator,
        shard_num,
        incarnation_id,
        &__args,
    )
}

/// multi_device_iterator_get_next_from_shard with options.
pub fn multi_device_iterator_get_next_from_shard_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    multi_device_iterator: T0,
    shard_num: T1,
    incarnation_id: T2,
    __args: &MultiDeviceIteratorGetNextFromShard,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MultiDeviceIteratorGetNextFromShard")?;

    // Required input arguments
    op.add_input(&multi_device_iterator.to_handle()?)?;
    op.add_input(&shard_num.to_handle()?)?;
    op.add_input(&incarnation_id.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MultiDeviceIteratorInit
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MultiDeviceIteratorInit {}

impl MultiDeviceIteratorInit {
    /// Creates a new `MultiDeviceIteratorInit`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// multi_device_iterator_init with default options.
pub fn multi_device_iterator_init<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    dataset: T0,
    multi_device_iterator: T1,
    max_buffer_size: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = MultiDeviceIteratorInit::new();
    multi_device_iterator_init_with_args(
        ctx,
        dataset,
        multi_device_iterator,
        max_buffer_size,
        &__args,
    )
}

/// multi_device_iterator_init with options.
pub fn multi_device_iterator_init_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    dataset: T0,
    multi_device_iterator: T1,
    max_buffer_size: T2,
    __args: &MultiDeviceIteratorInit,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MultiDeviceIteratorInit")?;

    // Required input arguments
    op.add_input(&dataset.to_handle()?)?;
    op.add_input(&multi_device_iterator.to_handle()?)?;
    op.add_input(&max_buffer_size.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MultiDeviceIteratorToStringHandle
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MultiDeviceIteratorToStringHandle {}

impl MultiDeviceIteratorToStringHandle {
    /// Creates a new `MultiDeviceIteratorToStringHandle`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// multi_device_iterator_to_string_handle with default options.
pub fn multi_device_iterator_to_string_handle<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    multi_device_iterator: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MultiDeviceIteratorToStringHandle::new();
    multi_device_iterator_to_string_handle_with_args(ctx, multi_device_iterator, &__args)
}

/// multi_device_iterator_to_string_handle with options.
pub fn multi_device_iterator_to_string_handle_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    multi_device_iterator: T0,
    __args: &MultiDeviceIteratorToStringHandle,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MultiDeviceIteratorToStringHandle")?;

    // Required input arguments
    op.add_input(&multi_device_iterator.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Multinomial
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Multinomial {
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub output_dtype: ::std::option::Option<crate::DataType>,
}

impl Multinomial {
    /// Creates a new `Multinomial`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// multinomial with default options.
pub fn multinomial<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    logits: T0,
    num_samples: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Multinomial::new();
    multinomial_with_args(ctx, logits, num_samples, &__args)
}

/// multinomial with options.
pub fn multinomial_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    logits: T0,
    num_samples: T1,
    __args: &Multinomial,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Multinomial")?;

    // Required input arguments
    op.add_input(&logits.to_handle()?)?;
    op.add_input(&num_samples.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_dtype {
        op.set_attr_type("output_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MutableDenseHashTable
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutableDenseHashTable {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub use_node_name_sharing: ::std::option::Option<bool>,
    pub key_dtype: ::std::option::Option<crate::DataType>,
    pub value_dtype: ::std::option::Option<crate::DataType>,
    pub value_shape: ::std::option::Option<crate::Shape>,
    pub initial_num_buckets: ::std::option::Option<i64>,
    pub max_load_factor: ::std::option::Option<f32>,
}

impl MutableDenseHashTable {
    /// Creates a new `MutableDenseHashTable`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mutable_dense_hash_table with default options.
pub fn mutable_dense_hash_table<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    empty_key: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MutableDenseHashTable::new();
    mutable_dense_hash_table_with_args(ctx, empty_key, &__args)
}

/// mutable_dense_hash_table with options.
pub fn mutable_dense_hash_table_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    empty_key: T0,
    __args: &MutableDenseHashTable,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MutableDenseHashTable")?;

    // Required input arguments
    op.add_input(&empty_key.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_node_name_sharing {
        op.set_attr_bool("use_node_name_sharing", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_dtype {
        op.set_attr_type("value_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_shape {
        op.set_attr_shape("value_shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.initial_num_buckets {
        op.set_attr_int("initial_num_buckets", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_load_factor {
        op.set_attr_float("max_load_factor", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MutableDenseHashTableV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutableDenseHashTableV2 {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub use_node_name_sharing: ::std::option::Option<bool>,
    pub key_dtype: ::std::option::Option<crate::DataType>,
    pub value_dtype: ::std::option::Option<crate::DataType>,
    pub value_shape: ::std::option::Option<crate::Shape>,
    pub initial_num_buckets: ::std::option::Option<i64>,
    pub max_load_factor: ::std::option::Option<f32>,
}

impl MutableDenseHashTableV2 {
    /// Creates a new `MutableDenseHashTableV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mutable_dense_hash_table_v2 with default options.
pub fn mutable_dense_hash_table_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    empty_key: T0,
    deleted_key: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = MutableDenseHashTableV2::new();
    mutable_dense_hash_table_v2_with_args(ctx, empty_key, deleted_key, &__args)
}

/// mutable_dense_hash_table_v2 with options.
pub fn mutable_dense_hash_table_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    empty_key: T0,
    deleted_key: T1,
    __args: &MutableDenseHashTableV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MutableDenseHashTableV2")?;

    // Required input arguments
    op.add_input(&empty_key.to_handle()?)?;
    op.add_input(&deleted_key.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_node_name_sharing {
        op.set_attr_bool("use_node_name_sharing", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_dtype {
        op.set_attr_type("value_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_shape {
        op.set_attr_shape("value_shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.initial_num_buckets {
        op.set_attr_int("initial_num_buckets", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_load_factor {
        op.set_attr_float("max_load_factor", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MutableHashTable
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutableHashTable {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub use_node_name_sharing: ::std::option::Option<bool>,
    pub key_dtype: ::std::option::Option<crate::DataType>,
    pub value_dtype: ::std::option::Option<crate::DataType>,
}

impl MutableHashTable {
    /// Creates a new `MutableHashTable`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mutable_hash_table with default options.
pub fn mutable_hash_table(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = MutableHashTable::new();
    mutable_hash_table_with_args(ctx, &__args)
}

/// mutable_hash_table with options.
pub fn mutable_hash_table_with_args(
    ctx: &crate::eager::Context,
    __args: &MutableHashTable,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MutableHashTable")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_node_name_sharing {
        op.set_attr_bool("use_node_name_sharing", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_dtype {
        op.set_attr_type("value_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MutableHashTableOfTensors
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutableHashTableOfTensors {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub use_node_name_sharing: ::std::option::Option<bool>,
    pub key_dtype: ::std::option::Option<crate::DataType>,
    pub value_dtype: ::std::option::Option<crate::DataType>,
    pub value_shape: ::std::option::Option<crate::Shape>,
}

impl MutableHashTableOfTensors {
    /// Creates a new `MutableHashTableOfTensors`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mutable_hash_table_of_tensors with default options.
pub fn mutable_hash_table_of_tensors(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = MutableHashTableOfTensors::new();
    mutable_hash_table_of_tensors_with_args(ctx, &__args)
}

/// mutable_hash_table_of_tensors with options.
pub fn mutable_hash_table_of_tensors_with_args(
    ctx: &crate::eager::Context,
    __args: &MutableHashTableOfTensors,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MutableHashTableOfTensors")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_node_name_sharing {
        op.set_attr_bool("use_node_name_sharing", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_dtype {
        op.set_attr_type("value_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_shape {
        op.set_attr_shape("value_shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MutableHashTableOfTensorsV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutableHashTableOfTensorsV2 {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub use_node_name_sharing: ::std::option::Option<bool>,
    pub key_dtype: ::std::option::Option<crate::DataType>,
    pub value_dtype: ::std::option::Option<crate::DataType>,
    pub value_shape: ::std::option::Option<crate::Shape>,
}

impl MutableHashTableOfTensorsV2 {
    /// Creates a new `MutableHashTableOfTensorsV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mutable_hash_table_of_tensors_v2 with default options.
pub fn mutable_hash_table_of_tensors_v2(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = MutableHashTableOfTensorsV2::new();
    mutable_hash_table_of_tensors_v2_with_args(ctx, &__args)
}

/// mutable_hash_table_of_tensors_v2 with options.
pub fn mutable_hash_table_of_tensors_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &MutableHashTableOfTensorsV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MutableHashTableOfTensorsV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_node_name_sharing {
        op.set_attr_bool("use_node_name_sharing", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_dtype {
        op.set_attr_type("value_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_shape {
        op.set_attr_shape("value_shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MutableHashTableV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutableHashTableV2 {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub use_node_name_sharing: ::std::option::Option<bool>,
    pub key_dtype: ::std::option::Option<crate::DataType>,
    pub value_dtype: ::std::option::Option<crate::DataType>,
}

impl MutableHashTableV2 {
    /// Creates a new `MutableHashTableV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mutable_hash_table_v2 with default options.
pub fn mutable_hash_table_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = MutableHashTableV2::new();
    mutable_hash_table_v2_with_args(ctx, &__args)
}

/// mutable_hash_table_v2 with options.
pub fn mutable_hash_table_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &MutableHashTableV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MutableHashTableV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_node_name_sharing {
        op.set_attr_bool("use_node_name_sharing", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_dtype {
        op.set_attr_type("value_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MutexLock
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutexLock {}

impl MutexLock {
    /// Creates a new `MutexLock`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mutex_lock with default options.
pub fn mutex_lock<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    mutex: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = MutexLock::new();
    mutex_lock_with_args(ctx, mutex, &__args)
}

/// mutex_lock with options.
pub fn mutex_lock_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    mutex: T0,
    __args: &MutexLock,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MutexLock")?;

    // Required input arguments
    op.add_input(&mutex.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// MutexV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutexV2 {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl MutexV2 {
    /// Creates a new `MutexV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// mutex_v2 with default options.
pub fn mutex_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = MutexV2::new();
    mutex_v2_with_args(ctx, &__args)
}

/// mutex_v2 with options.
pub fn mutex_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &MutexV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "MutexV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NcclAllReduce
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NcclAllReduce {
    pub reduction: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
    pub num_devices: ::std::option::Option<i64>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl NcclAllReduce {
    /// Creates a new `NcclAllReduce`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// nccl_all_reduce with default options.
pub fn nccl_all_reduce<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = NcclAllReduce::new();
    nccl_all_reduce_with_args(ctx, input, &__args)
}

/// nccl_all_reduce with options.
pub fn nccl_all_reduce_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &NcclAllReduce,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NcclAllReduce")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.reduction {
        op.set_attr_string("reduction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_devices {
        op.set_attr_int("num_devices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NcclBroadcast
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NcclBroadcast {
    pub T: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
}

impl NcclBroadcast {
    /// Creates a new `NcclBroadcast`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// nccl_broadcast with default options.
pub fn nccl_broadcast<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = NcclBroadcast::new();
    nccl_broadcast_with_args(ctx, input, &__args)
}

/// nccl_broadcast with options.
pub fn nccl_broadcast_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &NcclBroadcast,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NcclBroadcast")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NcclReduce
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NcclReduce {
    pub reduction: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
    pub num_devices: ::std::option::Option<i64>,
}

impl NcclReduce {
    /// Creates a new `NcclReduce`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// nccl_reduce with default options.
pub fn nccl_reduce<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = NcclReduce::new();
    nccl_reduce_with_args(ctx, input, &__args)
}

/// nccl_reduce with options.
pub fn nccl_reduce_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &NcclReduce,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NcclReduce")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.reduction {
        op.set_attr_string("reduction", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_devices {
        op.set_attr_int("num_devices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Ndtri
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Ndtri {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Ndtri {
    /// Creates a new `Ndtri`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ndtri with default options.
pub fn ndtri<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Ndtri::new();
    ndtri_with_args(ctx, x, &__args)
}

/// ndtri with options.
pub fn ndtri_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Ndtri,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Ndtri")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NearestNeighbors
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NearestNeighbors {}

impl NearestNeighbors {
    /// Creates a new `NearestNeighbors`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// nearest_neighbors with default options.
pub fn nearest_neighbors<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    points: T0,
    centers: T1,
    k: T2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = NearestNeighbors::new();
    nearest_neighbors_with_args(ctx, points, centers, k, &__args)
}

/// nearest_neighbors with options.
pub fn nearest_neighbors_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    points: T0,
    centers: T1,
    k: T2,
    __args: &NearestNeighbors,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NearestNeighbors")?;

    // Required input arguments
    op.add_input(&points.to_handle()?)?;
    op.add_input(&centers.to_handle()?)?;
    op.add_input(&k.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Neg
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Neg {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Neg {
    /// Creates a new `Neg`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// neg with default options.
pub fn neg<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Neg::new();
    neg_with_args(ctx, x, &__args)
}

/// neg with options.
pub fn neg_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Neg,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Neg")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NegTrain
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NegTrain {
    pub vocab_count: ::std::option::Option<::std::vec::Vec<i64>>,
    pub num_negative_samples: ::std::option::Option<i64>,
}

impl NegTrain {
    /// Creates a new `NegTrain`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// neg_train with default options.
pub fn neg_train<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    w_in: T0,
    w_out: T1,
    examples: T2,
    labels: T3,
    lr: T4,
) -> Result<()> {
    let __args = NegTrain::new();
    neg_train_with_args(ctx, w_in, w_out, examples, labels, lr, &__args)
}

/// neg_train with options.
pub fn neg_train_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    w_in: T0,
    w_out: T1,
    examples: T2,
    labels: T3,
    lr: T4,
    __args: &NegTrain,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NegTrain")?;

    // Required input arguments
    op.add_input(&w_in.to_handle()?)?;
    op.add_input(&w_out.to_handle()?)?;
    op.add_input(&examples.to_handle()?)?;
    op.add_input(&labels.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.vocab_count {
        op.set_attr_int_list("vocab_count", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_negative_samples {
        op.set_attr_int("num_negative_samples", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// NextAfter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NextAfter {
    pub T: ::std::option::Option<crate::DataType>,
}

impl NextAfter {
    /// Creates a new `NextAfter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// next_after with default options.
pub fn next_after<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x1: T0,
    x2: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = NextAfter::new();
    next_after_with_args(ctx, x1, x2, &__args)
}

/// next_after with options.
pub fn next_after_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x1: T0,
    x2: T1,
    __args: &NextAfter,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NextAfter")?;

    // Required input arguments
    op.add_input(&x1.to_handle()?)?;
    op.add_input(&x2.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NextIteration
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NextIteration {
    pub T: ::std::option::Option<crate::DataType>,
}

impl NextIteration {
    /// Creates a new `NextIteration`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// next_iteration with default options.
pub fn next_iteration<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = NextIteration::new();
    next_iteration_with_args(ctx, data, &__args)
}

/// next_iteration with options.
pub fn next_iteration_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    __args: &NextIteration,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NextIteration")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NoOp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NoOp {}

impl NoOp {
    /// Creates a new `NoOp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// no_op with default options.
pub fn no_op(ctx: &crate::eager::Context) -> Result<()> {
    let __args = NoOp::new();
    no_op_with_args(ctx, &__args)
}

/// no_op with options.
pub fn no_op_with_args(ctx: &crate::eager::Context, __args: &NoOp) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NoOp")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// NonDeterministicInts
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonDeterministicInts {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape_dtype: ::std::option::Option<crate::DataType>,
}

impl NonDeterministicInts {
    /// Creates a new `NonDeterministicInts`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// non_deterministic_ints with default options.
pub fn non_deterministic_ints<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = NonDeterministicInts::new();
    non_deterministic_ints_with_args(ctx, shape, &__args)
}

/// non_deterministic_ints with options.
pub fn non_deterministic_ints_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    __args: &NonDeterministicInts,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NonDeterministicInts")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_dtype {
        op.set_attr_type("shape_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NonMaxSuppression
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonMaxSuppression {
    pub iou_threshold: ::std::option::Option<f32>,
}

impl NonMaxSuppression {
    /// Creates a new `NonMaxSuppression`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// non_max_suppression with default options.
pub fn non_max_suppression<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    boxes: T0,
    scores: T1,
    max_output_size: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = NonMaxSuppression::new();
    non_max_suppression_with_args(ctx, boxes, scores, max_output_size, &__args)
}

/// non_max_suppression with options.
pub fn non_max_suppression_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    boxes: T0,
    scores: T1,
    max_output_size: T2,
    __args: &NonMaxSuppression,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NonMaxSuppression")?;

    // Required input arguments
    op.add_input(&boxes.to_handle()?)?;
    op.add_input(&scores.to_handle()?)?;
    op.add_input(&max_output_size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.iou_threshold {
        op.set_attr_float("iou_threshold", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NonMaxSuppressionV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonMaxSuppressionV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub T_threshold: ::std::option::Option<crate::DataType>,
}

impl NonMaxSuppressionV2 {
    /// Creates a new `NonMaxSuppressionV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// non_max_suppression_v2 with default options.
pub fn non_max_suppression_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    boxes: T0,
    scores: T1,
    max_output_size: T2,
    iou_threshold: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = NonMaxSuppressionV2::new();
    non_max_suppression_v2_with_args(ctx, boxes, scores, max_output_size, iou_threshold, &__args)
}

/// non_max_suppression_v2 with options.
pub fn non_max_suppression_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    boxes: T0,
    scores: T1,
    max_output_size: T2,
    iou_threshold: T3,
    __args: &NonMaxSuppressionV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NonMaxSuppressionV2")?;

    // Required input arguments
    op.add_input(&boxes.to_handle()?)?;
    op.add_input(&scores.to_handle()?)?;
    op.add_input(&max_output_size.to_handle()?)?;
    op.add_input(&iou_threshold.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T_threshold {
        op.set_attr_type("T_threshold", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NonMaxSuppressionV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonMaxSuppressionV3 {
    pub T: ::std::option::Option<crate::DataType>,
    pub T_threshold: ::std::option::Option<crate::DataType>,
}

impl NonMaxSuppressionV3 {
    /// Creates a new `NonMaxSuppressionV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// non_max_suppression_v3 with default options.
pub fn non_max_suppression_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    boxes: T0,
    scores: T1,
    max_output_size: T2,
    iou_threshold: T3,
    score_threshold: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = NonMaxSuppressionV3::new();
    non_max_suppression_v3_with_args(
        ctx,
        boxes,
        scores,
        max_output_size,
        iou_threshold,
        score_threshold,
        &__args,
    )
}

/// non_max_suppression_v3 with options.
pub fn non_max_suppression_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    boxes: T0,
    scores: T1,
    max_output_size: T2,
    iou_threshold: T3,
    score_threshold: T4,
    __args: &NonMaxSuppressionV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NonMaxSuppressionV3")?;

    // Required input arguments
    op.add_input(&boxes.to_handle()?)?;
    op.add_input(&scores.to_handle()?)?;
    op.add_input(&max_output_size.to_handle()?)?;
    op.add_input(&iou_threshold.to_handle()?)?;
    op.add_input(&score_threshold.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T_threshold {
        op.set_attr_type("T_threshold", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NonMaxSuppressionV4
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonMaxSuppressionV4 {
    pub T: ::std::option::Option<crate::DataType>,
    pub T_threshold: ::std::option::Option<crate::DataType>,
    pub pad_to_max_output_size: ::std::option::Option<bool>,
}

impl NonMaxSuppressionV4 {
    /// Creates a new `NonMaxSuppressionV4`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// non_max_suppression_v4 with default options.
pub fn non_max_suppression_v4<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    boxes: T0,
    scores: T1,
    max_output_size: T2,
    iou_threshold: T3,
    score_threshold: T4,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = NonMaxSuppressionV4::new();
    non_max_suppression_v4_with_args(
        ctx,
        boxes,
        scores,
        max_output_size,
        iou_threshold,
        score_threshold,
        &__args,
    )
}

/// non_max_suppression_v4 with options.
pub fn non_max_suppression_v4_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    boxes: T0,
    scores: T1,
    max_output_size: T2,
    iou_threshold: T3,
    score_threshold: T4,
    __args: &NonMaxSuppressionV4,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NonMaxSuppressionV4")?;

    // Required input arguments
    op.add_input(&boxes.to_handle()?)?;
    op.add_input(&scores.to_handle()?)?;
    op.add_input(&max_output_size.to_handle()?)?;
    op.add_input(&iou_threshold.to_handle()?)?;
    op.add_input(&score_threshold.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T_threshold {
        op.set_attr_type("T_threshold", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.pad_to_max_output_size {
        op.set_attr_bool("pad_to_max_output_size", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// NonMaxSuppressionV5
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonMaxSuppressionV5 {
    pub T: ::std::option::Option<crate::DataType>,
    pub pad_to_max_output_size: ::std::option::Option<bool>,
}

impl NonMaxSuppressionV5 {
    /// Creates a new `NonMaxSuppressionV5`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// non_max_suppression_v5 with default options.
pub fn non_max_suppression_v5<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    boxes: T0,
    scores: T1,
    max_output_size: T2,
    iou_threshold: T3,
    score_threshold: T4,
    soft_nms_sigma: T5,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = NonMaxSuppressionV5::new();
    non_max_suppression_v5_with_args(
        ctx,
        boxes,
        scores,
        max_output_size,
        iou_threshold,
        score_threshold,
        soft_nms_sigma,
        &__args,
    )
}

/// non_max_suppression_v5 with options.
pub fn non_max_suppression_v5_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    boxes: T0,
    scores: T1,
    max_output_size: T2,
    iou_threshold: T3,
    score_threshold: T4,
    soft_nms_sigma: T5,
    __args: &NonMaxSuppressionV5,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NonMaxSuppressionV5")?;

    // Required input arguments
    op.add_input(&boxes.to_handle()?)?;
    op.add_input(&scores.to_handle()?)?;
    op.add_input(&max_output_size.to_handle()?)?;
    op.add_input(&iou_threshold.to_handle()?)?;
    op.add_input(&score_threshold.to_handle()?)?;
    op.add_input(&soft_nms_sigma.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.pad_to_max_output_size {
        op.set_attr_bool("pad_to_max_output_size", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// NonMaxSuppressionWithOverlaps
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonMaxSuppressionWithOverlaps {}

impl NonMaxSuppressionWithOverlaps {
    /// Creates a new `NonMaxSuppressionWithOverlaps`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// non_max_suppression_with_overlaps with default options.
pub fn non_max_suppression_with_overlaps<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    overlaps: T0,
    scores: T1,
    max_output_size: T2,
    overlap_threshold: T3,
    score_threshold: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = NonMaxSuppressionWithOverlaps::new();
    non_max_suppression_with_overlaps_with_args(
        ctx,
        overlaps,
        scores,
        max_output_size,
        overlap_threshold,
        score_threshold,
        &__args,
    )
}

/// non_max_suppression_with_overlaps with options.
pub fn non_max_suppression_with_overlaps_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    overlaps: T0,
    scores: T1,
    max_output_size: T2,
    overlap_threshold: T3,
    score_threshold: T4,
    __args: &NonMaxSuppressionWithOverlaps,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NonMaxSuppressionWithOverlaps")?;

    // Required input arguments
    op.add_input(&overlaps.to_handle()?)?;
    op.add_input(&scores.to_handle()?)?;
    op.add_input(&max_output_size.to_handle()?)?;
    op.add_input(&overlap_threshold.to_handle()?)?;
    op.add_input(&score_threshold.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NonSerializableDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonSerializableDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl NonSerializableDataset {
    /// Creates a new `NonSerializableDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// non_serializable_dataset with default options.
pub fn non_serializable_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = NonSerializableDataset::new();
    non_serializable_dataset_with_args(ctx, input_dataset, &__args)
}

/// non_serializable_dataset with options.
pub fn non_serializable_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &NonSerializableDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NonSerializableDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NotEqual
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NotEqual {
    pub T: ::std::option::Option<crate::DataType>,
    pub incompatible_shape_error: ::std::option::Option<bool>,
}

impl NotEqual {
    /// Creates a new `NotEqual`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// not_equal with default options.
pub fn not_equal<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = NotEqual::new();
    not_equal_with_args(ctx, x, y, &__args)
}

/// not_equal with options.
pub fn not_equal_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &NotEqual,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NotEqual")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.incompatible_shape_error {
        op.set_attr_bool("incompatible_shape_error", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// NthElement
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NthElement {
    pub reverse: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl NthElement {
    /// Creates a new `NthElement`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// nth_element with default options.
pub fn nth_element<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    n: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = NthElement::new();
    nth_element_with_args(ctx, input, n, &__args)
}

/// nth_element with options.
pub fn nth_element_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    n: T1,
    __args: &NthElement,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "NthElement")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&n.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.reverse {
        op.set_attr_bool("reverse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OneHot
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OneHot {
    pub axis: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub TI: ::std::option::Option<crate::DataType>,
}

impl OneHot {
    /// Creates a new `OneHot`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// one_hot with default options.
pub fn one_hot<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    depth: T1,
    on_value: T2,
    off_value: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = OneHot::new();
    one_hot_with_args(ctx, indices, depth, on_value, off_value, &__args)
}

/// one_hot with options.
pub fn one_hot_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    depth: T1,
    on_value: T2,
    off_value: T3,
    __args: &OneHot,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OneHot")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&depth.to_handle()?)?;
    op.add_input(&on_value.to_handle()?)?;
    op.add_input(&off_value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.axis {
        op.set_attr_int("axis", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.TI {
        op.set_attr_type("TI", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OneShotIterator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OneShotIterator {
    pub dataset_factory: ::std::option::Option<::std::string::String>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl OneShotIterator {
    /// Creates a new `OneShotIterator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// one_shot_iterator with default options.
pub fn one_shot_iterator(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = OneShotIterator::new();
    one_shot_iterator_with_args(ctx, &__args)
}

/// one_shot_iterator with options.
pub fn one_shot_iterator_with_args(
    ctx: &crate::eager::Context,
    __args: &OneShotIterator,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OneShotIterator")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dataset_factory {
        op.set_attr_string("dataset_factory", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OnesLike
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OnesLike {
    pub T: ::std::option::Option<crate::DataType>,
}

impl OnesLike {
    /// Creates a new `OnesLike`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ones_like with default options.
pub fn ones_like<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = OnesLike::new();
    ones_like_with_args(ctx, x, &__args)
}

/// ones_like with options.
pub fn ones_like_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &OnesLike,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OnesLike")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OptimizeDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OptimizeDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub optimization_configs: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}

impl OptimizeDataset {
    /// Creates a new `OptimizeDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// optimize_dataset with default options.
pub fn optimize_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    optimizations: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = OptimizeDataset::new();
    optimize_dataset_with_args(ctx, input_dataset, optimizations, &__args)
}

/// optimize_dataset with options.
pub fn optimize_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    optimizations: T1,
    __args: &OptimizeDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OptimizeDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&optimizations.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.optimization_configs {
        op.set_attr_string_list("optimization_configs", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OptimizeDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OptimizeDatasetV2 {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub optimization_configs: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}

impl OptimizeDatasetV2 {
    /// Creates a new `OptimizeDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// optimize_dataset_v2 with default options.
pub fn optimize_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    optimizations_enabled: T1,
    optimizations_disabled: T2,
    optimizations_default: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = OptimizeDatasetV2::new();
    optimize_dataset_v2_with_args(
        ctx,
        input_dataset,
        optimizations_enabled,
        optimizations_disabled,
        optimizations_default,
        &__args,
    )
}

/// optimize_dataset_v2 with options.
pub fn optimize_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    optimizations_enabled: T1,
    optimizations_disabled: T2,
    optimizations_default: T3,
    __args: &OptimizeDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OptimizeDatasetV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&optimizations_enabled.to_handle()?)?;
    op.add_input(&optimizations_disabled.to_handle()?)?;
    op.add_input(&optimizations_default.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.optimization_configs {
        op.set_attr_string_list("optimization_configs", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OptionalFromValue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OptionalFromValue {
    pub Toutput_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl OptionalFromValue {
    /// Creates a new `OptionalFromValue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// optional_from_value with default options.
pub fn optional_from_value<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    components: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = OptionalFromValue::new();
    optional_from_value_with_args(ctx, components, &__args)
}

/// optional_from_value with options.
pub fn optional_from_value_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    components: T0,
    __args: &OptionalFromValue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OptionalFromValue")?;

    // Required input arguments
    op.add_input(&components.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Toutput_types {
        op.set_attr_type_list("Toutput_types", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OptionalGetValue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OptionalGetValue {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl OptionalGetValue {
    /// Creates a new `OptionalGetValue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// optional_get_value with default options.
pub fn optional_get_value<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    optional: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = OptionalGetValue::new();
    optional_get_value_with_args(ctx, optional, &__args)
}

/// optional_get_value with options.
pub fn optional_get_value_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    optional: T0,
    __args: &OptionalGetValue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OptionalGetValue")?;

    // Required input arguments
    op.add_input(&optional.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OptionalHasValue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OptionalHasValue {}

impl OptionalHasValue {
    /// Creates a new `OptionalHasValue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// optional_has_value with default options.
pub fn optional_has_value<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    optional: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = OptionalHasValue::new();
    optional_has_value_with_args(ctx, optional, &__args)
}

/// optional_has_value with options.
pub fn optional_has_value_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    optional: T0,
    __args: &OptionalHasValue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OptionalHasValue")?;

    // Required input arguments
    op.add_input(&optional.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OptionalNone
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OptionalNone {}

impl OptionalNone {
    /// Creates a new `OptionalNone`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// optional_none with default options.
pub fn optional_none(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = OptionalNone::new();
    optional_none_with_args(ctx, &__args)
}

/// optional_none with options.
pub fn optional_none_with_args(
    ctx: &crate::eager::Context,
    __args: &OptionalNone,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OptionalNone")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OptionsDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OptionsDataset {
    pub serialized_options: ::std::option::Option<::std::string::String>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl OptionsDataset {
    /// Creates a new `OptionsDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// options_dataset with default options.
pub fn options_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = OptionsDataset::new();
    options_dataset_with_args(ctx, input_dataset, &__args)
}

/// options_dataset with options.
pub fn options_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &OptionsDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OptionsDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.serialized_options {
        op.set_attr_string("serialized_options", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OrderedMapClear
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapClear {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl OrderedMapClear {
    /// Creates a new `OrderedMapClear`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ordered_map_clear with default options.
pub fn ordered_map_clear(ctx: &crate::eager::Context) -> Result<()> {
    let __args = OrderedMapClear::new();
    ordered_map_clear_with_args(ctx, &__args)
}

/// ordered_map_clear with options.
pub fn ordered_map_clear_with_args(
    ctx: &crate::eager::Context,
    __args: &OrderedMapClear,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OrderedMapClear")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// OrderedMapIncompleteSize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapIncompleteSize {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl OrderedMapIncompleteSize {
    /// Creates a new `OrderedMapIncompleteSize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ordered_map_incomplete_size with default options.
pub fn ordered_map_incomplete_size(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = OrderedMapIncompleteSize::new();
    ordered_map_incomplete_size_with_args(ctx, &__args)
}

/// ordered_map_incomplete_size with options.
pub fn ordered_map_incomplete_size_with_args(
    ctx: &crate::eager::Context,
    __args: &OrderedMapIncompleteSize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OrderedMapIncompleteSize")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OrderedMapPeek
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapPeek {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl OrderedMapPeek {
    /// Creates a new `OrderedMapPeek`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ordered_map_peek with default options.
pub fn ordered_map_peek<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    key: T0,
    indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = OrderedMapPeek::new();
    ordered_map_peek_with_args(ctx, key, indices, &__args)
}

/// ordered_map_peek with options.
pub fn ordered_map_peek_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    key: T0,
    indices: T1,
    __args: &OrderedMapPeek,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OrderedMapPeek")?;

    // Required input arguments
    op.add_input(&key.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OrderedMapSize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapSize {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl OrderedMapSize {
    /// Creates a new `OrderedMapSize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ordered_map_size with default options.
pub fn ordered_map_size(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = OrderedMapSize::new();
    ordered_map_size_with_args(ctx, &__args)
}

/// ordered_map_size with options.
pub fn ordered_map_size_with_args(
    ctx: &crate::eager::Context,
    __args: &OrderedMapSize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OrderedMapSize")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OrderedMapStage
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapStage {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub fake_dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl OrderedMapStage {
    /// Creates a new `OrderedMapStage`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ordered_map_stage with default options.
pub fn ordered_map_stage<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    key: T0,
    indices: T1,
    values: T2,
) -> Result<()> {
    let __args = OrderedMapStage::new();
    ordered_map_stage_with_args(ctx, key, indices, values, &__args)
}

/// ordered_map_stage with options.
pub fn ordered_map_stage_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    key: T0,
    indices: T1,
    values: T2,
    __args: &OrderedMapStage,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OrderedMapStage")?;

    // Required input arguments
    op.add_input(&key.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.fake_dtypes {
        op.set_attr_type_list("fake_dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// OrderedMapUnstage
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapUnstage {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl OrderedMapUnstage {
    /// Creates a new `OrderedMapUnstage`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ordered_map_unstage with default options.
pub fn ordered_map_unstage<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    key: T0,
    indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = OrderedMapUnstage::new();
    ordered_map_unstage_with_args(ctx, key, indices, &__args)
}

/// ordered_map_unstage with options.
pub fn ordered_map_unstage_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    key: T0,
    indices: T1,
    __args: &OrderedMapUnstage,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OrderedMapUnstage")?;

    // Required input arguments
    op.add_input(&key.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OrderedMapUnstageNoKey
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapUnstageNoKey {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl OrderedMapUnstageNoKey {
    /// Creates a new `OrderedMapUnstageNoKey`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ordered_map_unstage_no_key with default options.
pub fn ordered_map_unstage_no_key<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    indices: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = OrderedMapUnstageNoKey::new();
    ordered_map_unstage_no_key_with_args(ctx, indices, &__args)
}

/// ordered_map_unstage_no_key with options.
pub fn ordered_map_unstage_no_key_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    indices: T0,
    __args: &OrderedMapUnstageNoKey,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OrderedMapUnstageNoKey")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// OutfeedDequeue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OutfeedDequeue {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
    pub device_ordinal: ::std::option::Option<i64>,
}

impl OutfeedDequeue {
    /// Creates a new `OutfeedDequeue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// outfeed_dequeue with default options.
pub fn outfeed_dequeue(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = OutfeedDequeue::new();
    outfeed_dequeue_with_args(ctx, &__args)
}

/// outfeed_dequeue with options.
pub fn outfeed_dequeue_with_args(
    ctx: &crate::eager::Context,
    __args: &OutfeedDequeue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OutfeedDequeue")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.device_ordinal {
        op.set_attr_int("device_ordinal", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OutfeedDequeueTuple
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OutfeedDequeueTuple {
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub device_ordinal: ::std::option::Option<i64>,
}

impl OutfeedDequeueTuple {
    /// Creates a new `OutfeedDequeueTuple`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// outfeed_dequeue_tuple with default options.
pub fn outfeed_dequeue_tuple(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = OutfeedDequeueTuple::new();
    outfeed_dequeue_tuple_with_args(ctx, &__args)
}

/// outfeed_dequeue_tuple with options.
pub fn outfeed_dequeue_tuple_with_args(
    ctx: &crate::eager::Context,
    __args: &OutfeedDequeueTuple,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OutfeedDequeueTuple")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.device_ordinal {
        op.set_attr_int("device_ordinal", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OutfeedDequeueTupleV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OutfeedDequeueTupleV2 {
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl OutfeedDequeueTupleV2 {
    /// Creates a new `OutfeedDequeueTupleV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// outfeed_dequeue_tuple_v2 with default options.
pub fn outfeed_dequeue_tuple_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    device_ordinal: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = OutfeedDequeueTupleV2::new();
    outfeed_dequeue_tuple_v2_with_args(ctx, device_ordinal, &__args)
}

/// outfeed_dequeue_tuple_v2 with options.
pub fn outfeed_dequeue_tuple_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    device_ordinal: T0,
    __args: &OutfeedDequeueTupleV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OutfeedDequeueTupleV2")?;

    // Required input arguments
    op.add_input(&device_ordinal.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OutfeedDequeueV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OutfeedDequeueV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
}

impl OutfeedDequeueV2 {
    /// Creates a new `OutfeedDequeueV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// outfeed_dequeue_v2 with default options.
pub fn outfeed_dequeue_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    device_ordinal: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = OutfeedDequeueV2::new();
    outfeed_dequeue_v2_with_args(ctx, device_ordinal, &__args)
}

/// outfeed_dequeue_v2 with options.
pub fn outfeed_dequeue_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    device_ordinal: T0,
    __args: &OutfeedDequeueV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OutfeedDequeueV2")?;

    // Required input arguments
    op.add_input(&device_ordinal.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// OutfeedEnqueue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OutfeedEnqueue {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl OutfeedEnqueue {
    /// Creates a new `OutfeedEnqueue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// outfeed_enqueue with default options.
pub fn outfeed_enqueue<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<()> {
    let __args = OutfeedEnqueue::new();
    outfeed_enqueue_with_args(ctx, input, &__args)
}

/// outfeed_enqueue with options.
pub fn outfeed_enqueue_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &OutfeedEnqueue,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OutfeedEnqueue")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// OutfeedEnqueueTuple
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OutfeedEnqueueTuple {
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl OutfeedEnqueueTuple {
    /// Creates a new `OutfeedEnqueueTuple`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// outfeed_enqueue_tuple with default options.
pub fn outfeed_enqueue_tuple<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<()> {
    let __args = OutfeedEnqueueTuple::new();
    outfeed_enqueue_tuple_with_args(ctx, inputs, &__args)
}

/// outfeed_enqueue_tuple with options.
pub fn outfeed_enqueue_tuple_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &OutfeedEnqueueTuple,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "OutfeedEnqueueTuple")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Pack
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Pack {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub axis: ::std::option::Option<i64>,
}

impl Pack {
    /// Creates a new `Pack`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// pack with default options.
pub fn pack<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    values: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Pack::new();
    pack_with_args(ctx, values, &__args)
}

/// pack with options.
pub fn pack_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    values: T0,
    __args: &Pack,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Pack")?;

    // Required input arguments
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.axis {
        op.set_attr_int("axis", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Pad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Pad {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tpaddings: ::std::option::Option<crate::DataType>,
}

impl Pad {
    /// Creates a new `Pad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// pad with default options.
pub fn pad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Pad::new();
    pad_with_args(ctx, input, paddings, &__args)
}

/// pad with options.
pub fn pad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
    __args: &Pad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Pad")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&paddings.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tpaddings {
        op.set_attr_type("Tpaddings", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PadV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PadV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tpaddings: ::std::option::Option<crate::DataType>,
}

impl PadV2 {
    /// Creates a new `PadV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// pad_v2 with default options.
pub fn pad_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
    constant_values: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = PadV2::new();
    pad_v2_with_args(ctx, input, paddings, constant_values, &__args)
}

/// pad_v2 with options.
pub fn pad_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
    constant_values: T2,
    __args: &PadV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PadV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&paddings.to_handle()?)?;
    op.add_input(&constant_values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tpaddings {
        op.set_attr_type("Tpaddings", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PaddedBatchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PaddedBatchDataset {
    pub Toutput_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub N: ::std::option::Option<i64>,
}

impl PaddedBatchDataset {
    /// Creates a new `PaddedBatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// padded_batch_dataset with default options.
pub fn padded_batch_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    padded_shapes: T2,
    padding_values: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = PaddedBatchDataset::new();
    padded_batch_dataset_with_args(
        ctx,
        input_dataset,
        batch_size,
        padded_shapes,
        padding_values,
        &__args,
    )
}

/// padded_batch_dataset with options.
pub fn padded_batch_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    padded_shapes: T2,
    padding_values: T3,
    __args: &PaddedBatchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PaddedBatchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&batch_size.to_handle()?)?;
    op.add_input(&padded_shapes.to_handle()?)?;
    op.add_input(&padding_values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Toutput_types {
        op.set_attr_type_list("Toutput_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PaddedBatchDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PaddedBatchDatasetV2 {
    pub parallel_copy: ::std::option::Option<bool>,
    pub Toutput_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub N: ::std::option::Option<i64>,
}

impl PaddedBatchDatasetV2 {
    /// Creates a new `PaddedBatchDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// padded_batch_dataset_v2 with default options.
pub fn padded_batch_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    padded_shapes: T2,
    padding_values: T3,
    drop_remainder: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = PaddedBatchDatasetV2::new();
    padded_batch_dataset_v2_with_args(
        ctx,
        input_dataset,
        batch_size,
        padded_shapes,
        padding_values,
        drop_remainder,
        &__args,
    )
}

/// padded_batch_dataset_v2 with options.
pub fn padded_batch_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    padded_shapes: T2,
    padding_values: T3,
    drop_remainder: T4,
    __args: &PaddedBatchDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PaddedBatchDatasetV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&batch_size.to_handle()?)?;
    op.add_input(&padded_shapes.to_handle()?)?;
    op.add_input(&padding_values.to_handle()?)?;
    op.add_input(&drop_remainder.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.parallel_copy {
        op.set_attr_bool("parallel_copy", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Toutput_types {
        op.set_attr_type_list("Toutput_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PaddingFIFOQueue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PaddingFIFOQueue {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub capacity: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl PaddingFIFOQueue {
    /// Creates a new `PaddingFIFOQueue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// padding_fifoqueue with default options.
pub fn padding_fifoqueue(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = PaddingFIFOQueue::new();
    padding_fifoqueue_with_args(ctx, &__args)
}

/// padding_fifoqueue with options.
pub fn padding_fifoqueue_with_args(
    ctx: &crate::eager::Context,
    __args: &PaddingFIFOQueue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PaddingFIFOQueue")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PaddingFIFOQueueV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PaddingFIFOQueueV2 {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub capacity: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl PaddingFIFOQueueV2 {
    /// Creates a new `PaddingFIFOQueueV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// padding_fifoqueue_v2 with default options.
pub fn padding_fifoqueue_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = PaddingFIFOQueueV2::new();
    padding_fifoqueue_v2_with_args(ctx, &__args)
}

/// padding_fifoqueue_v2 with options.
pub fn padding_fifoqueue_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &PaddingFIFOQueueV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PaddingFIFOQueueV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParallelBatchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelBatchDataset {
    pub parallel_copy: ::std::option::Option<bool>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub deterministic: ::std::option::Option<::std::string::String>,
}

impl ParallelBatchDataset {
    /// Creates a new `ParallelBatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parallel_batch_dataset with default options.
pub fn parallel_batch_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    num_parallel_calls: T2,
    drop_remainder: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParallelBatchDataset::new();
    parallel_batch_dataset_with_args(
        ctx,
        input_dataset,
        batch_size,
        num_parallel_calls,
        drop_remainder,
        &__args,
    )
}

/// parallel_batch_dataset with options.
pub fn parallel_batch_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_size: T1,
    num_parallel_calls: T2,
    drop_remainder: T3,
    __args: &ParallelBatchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParallelBatchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&batch_size.to_handle()?)?;
    op.add_input(&num_parallel_calls.to_handle()?)?;
    op.add_input(&drop_remainder.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.parallel_copy {
        op.set_attr_bool("parallel_copy", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.deterministic {
        op.set_attr_string("deterministic", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParallelConcat
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelConcat {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
}

impl ParallelConcat {
    /// Creates a new `ParallelConcat`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parallel_concat with default options.
pub fn parallel_concat<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    values: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParallelConcat::new();
    parallel_concat_with_args(ctx, values, &__args)
}

/// parallel_concat with options.
pub fn parallel_concat_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    values: T0,
    __args: &ParallelConcat,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParallelConcat")?;

    // Required input arguments
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParallelDynamicStitch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelDynamicStitch {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl ParallelDynamicStitch {
    /// Creates a new `ParallelDynamicStitch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parallel_dynamic_stitch with default options.
pub fn parallel_dynamic_stitch<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    indices: T0,
    data: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParallelDynamicStitch::new();
    parallel_dynamic_stitch_with_args(ctx, indices, data, &__args)
}

/// parallel_dynamic_stitch with options.
pub fn parallel_dynamic_stitch_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    indices: T0,
    data: T1,
    __args: &ParallelDynamicStitch,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParallelDynamicStitch")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParallelInterleaveDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelInterleaveDataset {
    pub f: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ParallelInterleaveDataset {
    /// Creates a new `ParallelInterleaveDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parallel_interleave_dataset with default options.
pub fn parallel_interleave_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    sloppy: T4,
    buffer_output_elements: T5,
    prefetch_input_elements: T6,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParallelInterleaveDataset::new();
    parallel_interleave_dataset_with_args(
        ctx,
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        sloppy,
        buffer_output_elements,
        prefetch_input_elements,
        &__args,
    )
}

/// parallel_interleave_dataset with options.
pub fn parallel_interleave_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    sloppy: T4,
    buffer_output_elements: T5,
    prefetch_input_elements: T6,
    __args: &ParallelInterleaveDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParallelInterleaveDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;
    op.add_input(&cycle_length.to_handle()?)?;
    op.add_input(&block_length.to_handle()?)?;
    op.add_input(&sloppy.to_handle()?)?;
    op.add_input(&buffer_output_elements.to_handle()?)?;
    op.add_input(&prefetch_input_elements.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParallelInterleaveDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelInterleaveDatasetV2 {
    pub f: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub sloppy: ::std::option::Option<bool>,
}

impl ParallelInterleaveDatasetV2 {
    /// Creates a new `ParallelInterleaveDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parallel_interleave_dataset_v2 with default options.
pub fn parallel_interleave_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    num_parallel_calls: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParallelInterleaveDatasetV2::new();
    parallel_interleave_dataset_v2_with_args(
        ctx,
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        num_parallel_calls,
        &__args,
    )
}

/// parallel_interleave_dataset_v2 with options.
pub fn parallel_interleave_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    num_parallel_calls: T4,
    __args: &ParallelInterleaveDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParallelInterleaveDatasetV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;
    op.add_input(&cycle_length.to_handle()?)?;
    op.add_input(&block_length.to_handle()?)?;
    op.add_input(&num_parallel_calls.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.sloppy {
        op.set_attr_bool("sloppy", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParallelInterleaveDatasetV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelInterleaveDatasetV3 {
    pub f: ::std::option::Option<::std::string::String>,
    pub deterministic: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ParallelInterleaveDatasetV3 {
    /// Creates a new `ParallelInterleaveDatasetV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parallel_interleave_dataset_v3 with default options.
pub fn parallel_interleave_dataset_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    num_parallel_calls: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParallelInterleaveDatasetV3::new();
    parallel_interleave_dataset_v3_with_args(
        ctx,
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        num_parallel_calls,
        &__args,
    )
}

/// parallel_interleave_dataset_v3 with options.
pub fn parallel_interleave_dataset_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    num_parallel_calls: T4,
    __args: &ParallelInterleaveDatasetV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParallelInterleaveDatasetV3")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;
    op.add_input(&cycle_length.to_handle()?)?;
    op.add_input(&block_length.to_handle()?)?;
    op.add_input(&num_parallel_calls.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.deterministic {
        op.set_attr_string("deterministic", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParallelInterleaveDatasetV4
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelInterleaveDatasetV4 {
    pub f: ::std::option::Option<::std::string::String>,
    pub deterministic: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ParallelInterleaveDatasetV4 {
    /// Creates a new `ParallelInterleaveDatasetV4`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parallel_interleave_dataset_v4 with default options.
pub fn parallel_interleave_dataset_v4<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    buffer_output_elements: T4,
    prefetch_input_elements: T5,
    num_parallel_calls: T6,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParallelInterleaveDatasetV4::new();
    parallel_interleave_dataset_v4_with_args(
        ctx,
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        buffer_output_elements,
        prefetch_input_elements,
        num_parallel_calls,
        &__args,
    )
}

/// parallel_interleave_dataset_v4 with options.
pub fn parallel_interleave_dataset_v4_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    cycle_length: T2,
    block_length: T3,
    buffer_output_elements: T4,
    prefetch_input_elements: T5,
    num_parallel_calls: T6,
    __args: &ParallelInterleaveDatasetV4,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParallelInterleaveDatasetV4")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;
    op.add_input(&cycle_length.to_handle()?)?;
    op.add_input(&block_length.to_handle()?)?;
    op.add_input(&buffer_output_elements.to_handle()?)?;
    op.add_input(&prefetch_input_elements.to_handle()?)?;
    op.add_input(&num_parallel_calls.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.deterministic {
        op.set_attr_string("deterministic", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParallelMapDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelMapDataset {
    pub f: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub use_inter_op_parallelism: ::std::option::Option<bool>,
    pub sloppy: ::std::option::Option<bool>,
    pub preserve_cardinality: ::std::option::Option<bool>,
}

impl ParallelMapDataset {
    /// Creates a new `ParallelMapDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parallel_map_dataset with default options.
pub fn parallel_map_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    num_parallel_calls: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParallelMapDataset::new();
    parallel_map_dataset_with_args(
        ctx,
        input_dataset,
        other_arguments,
        num_parallel_calls,
        &__args,
    )
}

/// parallel_map_dataset with options.
pub fn parallel_map_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    num_parallel_calls: T2,
    __args: &ParallelMapDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParallelMapDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;
    op.add_input(&num_parallel_calls.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.use_inter_op_parallelism {
        op.set_attr_bool("use_inter_op_parallelism", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.sloppy {
        op.set_attr_bool("sloppy", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.preserve_cardinality {
        op.set_attr_bool("preserve_cardinality", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParallelMapDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelMapDatasetV2 {
    pub f: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub use_inter_op_parallelism: ::std::option::Option<bool>,
    pub deterministic: ::std::option::Option<::std::string::String>,
    pub preserve_cardinality: ::std::option::Option<bool>,
}

impl ParallelMapDatasetV2 {
    /// Creates a new `ParallelMapDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parallel_map_dataset_v2 with default options.
pub fn parallel_map_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    num_parallel_calls: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParallelMapDatasetV2::new();
    parallel_map_dataset_v2_with_args(
        ctx,
        input_dataset,
        other_arguments,
        num_parallel_calls,
        &__args,
    )
}

/// parallel_map_dataset_v2 with options.
pub fn parallel_map_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    num_parallel_calls: T2,
    __args: &ParallelMapDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParallelMapDatasetV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;
    op.add_input(&num_parallel_calls.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.use_inter_op_parallelism {
        op.set_attr_bool("use_inter_op_parallelism", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.deterministic {
        op.set_attr_string("deterministic", value);
    }
    if let ::std::option::Option::Some(value) = &__args.preserve_cardinality {
        op.set_attr_bool("preserve_cardinality", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParameterizedTruncatedNormal
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParameterizedTruncatedNormal {
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub dtype: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl ParameterizedTruncatedNormal {
    /// Creates a new `ParameterizedTruncatedNormal`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parameterized_truncated_normal with default options.
pub fn parameterized_truncated_normal<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    means: T1,
    stdevs: T2,
    minvals: T3,
    maxvals: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParameterizedTruncatedNormal::new();
    parameterized_truncated_normal_with_args(ctx, shape, means, stdevs, minvals, maxvals, &__args)
}

/// parameterized_truncated_normal with options.
pub fn parameterized_truncated_normal_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    means: T1,
    stdevs: T2,
    minvals: T3,
    maxvals: T4,
    __args: &ParameterizedTruncatedNormal,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParameterizedTruncatedNormal")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&means.to_handle()?)?;
    op.add_input(&stdevs.to_handle()?)?;
    op.add_input(&minvals.to_handle()?)?;
    op.add_input(&maxvals.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParseExample
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseExample {
    pub Nsparse: ::std::option::Option<i64>,
    pub Ndense: ::std::option::Option<i64>,
    pub sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tdense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ParseExample {
    /// Creates a new `ParseExample`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parse_example with default options.
pub fn parse_example<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    serialized: T0,
    names: T1,
    sparse_keys: T2,
    dense_keys: T3,
    dense_defaults: T4,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = ParseExample::new();
    parse_example_with_args(
        ctx,
        serialized,
        names,
        sparse_keys,
        dense_keys,
        dense_defaults,
        &__args,
    )
}

/// parse_example with options.
pub fn parse_example_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    serialized: T0,
    names: T1,
    sparse_keys: T2,
    dense_keys: T3,
    dense_defaults: T4,
    __args: &ParseExample,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParseExample")?;

    // Required input arguments
    op.add_input(&serialized.to_handle()?)?;
    op.add_input(&names.to_handle()?)?;
    op.add_input(&sparse_keys.to_handle()?)?;
    op.add_input(&dense_keys.to_handle()?)?;
    op.add_input(&dense_defaults.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Nsparse {
        op.set_attr_int("Nsparse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Ndense {
        op.set_attr_int("Ndense", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.sparse_types {
        op.set_attr_type_list("sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tdense {
        op.set_attr_type_list("Tdense", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_shapes {
        op.set_attr_shape_list("dense_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// ParseExampleDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseExampleDataset {
    pub sparse_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub dense_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tdense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub sloppy: ::std::option::Option<bool>,
    pub ragged_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub ragged_value_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub ragged_split_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl ParseExampleDataset {
    /// Creates a new `ParseExampleDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parse_example_dataset with default options.
pub fn parse_example_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_parallel_calls: T1,
    dense_defaults: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParseExampleDataset::new();
    parse_example_dataset_with_args(
        ctx,
        input_dataset,
        num_parallel_calls,
        dense_defaults,
        &__args,
    )
}

/// parse_example_dataset with options.
pub fn parse_example_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_parallel_calls: T1,
    dense_defaults: T2,
    __args: &ParseExampleDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParseExampleDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&num_parallel_calls.to_handle()?)?;
    op.add_input(&dense_defaults.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.sparse_keys {
        op.set_attr_string_list("sparse_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_keys {
        op.set_attr_string_list("dense_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.sparse_types {
        op.set_attr_type_list("sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tdense {
        op.set_attr_type_list("Tdense", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_shapes {
        op.set_attr_shape_list("dense_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.sloppy {
        op.set_attr_bool("sloppy", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ragged_keys {
        op.set_attr_string_list("ragged_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.ragged_value_types {
        op.set_attr_type_list("ragged_value_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.ragged_split_types {
        op.set_attr_type_list("ragged_split_types", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParseExampleDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseExampleDatasetV2 {
    pub sparse_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub dense_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tdense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub deterministic: ::std::option::Option<::std::string::String>,
    pub ragged_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub ragged_value_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub ragged_split_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl ParseExampleDatasetV2 {
    /// Creates a new `ParseExampleDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parse_example_dataset_v2 with default options.
pub fn parse_example_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_parallel_calls: T1,
    dense_defaults: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParseExampleDatasetV2::new();
    parse_example_dataset_v2_with_args(
        ctx,
        input_dataset,
        num_parallel_calls,
        dense_defaults,
        &__args,
    )
}

/// parse_example_dataset_v2 with options.
pub fn parse_example_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_parallel_calls: T1,
    dense_defaults: T2,
    __args: &ParseExampleDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParseExampleDatasetV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&num_parallel_calls.to_handle()?)?;
    op.add_input(&dense_defaults.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.sparse_keys {
        op.set_attr_string_list("sparse_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_keys {
        op.set_attr_string_list("dense_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.sparse_types {
        op.set_attr_type_list("sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tdense {
        op.set_attr_type_list("Tdense", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_shapes {
        op.set_attr_shape_list("dense_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.deterministic {
        op.set_attr_string("deterministic", value);
    }
    if let ::std::option::Option::Some(value) = &__args.ragged_keys {
        op.set_attr_string_list("ragged_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.ragged_value_types {
        op.set_attr_type_list("ragged_value_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.ragged_split_types {
        op.set_attr_type_list("ragged_split_types", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ParseExampleV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseExampleV2 {
    pub Tdense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub num_sparse: ::std::option::Option<i64>,
    pub sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub ragged_value_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub ragged_split_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ParseExampleV2 {
    /// Creates a new `ParseExampleV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parse_example_v2 with default options.
pub fn parse_example_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    serialized: T0,
    names: T1,
    sparse_keys: T2,
    dense_keys: T3,
    ragged_keys: T4,
    dense_defaults: T5,
) -> Result<[crate::eager::TensorHandle; 6]> {
    let __args = ParseExampleV2::new();
    parse_example_v2_with_args(
        ctx,
        serialized,
        names,
        sparse_keys,
        dense_keys,
        ragged_keys,
        dense_defaults,
        &__args,
    )
}

/// parse_example_v2 with options.
pub fn parse_example_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    serialized: T0,
    names: T1,
    sparse_keys: T2,
    dense_keys: T3,
    ragged_keys: T4,
    dense_defaults: T5,
    __args: &ParseExampleV2,
) -> Result<[crate::eager::TensorHandle; 6]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParseExampleV2")?;

    // Required input arguments
    op.add_input(&serialized.to_handle()?)?;
    op.add_input(&names.to_handle()?)?;
    op.add_input(&sparse_keys.to_handle()?)?;
    op.add_input(&dense_keys.to_handle()?)?;
    op.add_input(&ragged_keys.to_handle()?)?;
    op.add_input(&dense_defaults.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tdense {
        op.set_attr_type_list("Tdense", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_sparse {
        op.set_attr_int("num_sparse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.sparse_types {
        op.set_attr_type_list("sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.ragged_value_types {
        op.set_attr_type_list("ragged_value_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.ragged_split_types {
        op.set_attr_type_list("ragged_split_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_shapes {
        op.set_attr_shape_list("dense_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 6;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 6];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// ParseSequenceExample
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseSequenceExample {
    pub feature_list_dense_missing_assumed_empty:
        ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub context_sparse_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub context_dense_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub feature_list_sparse_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub feature_list_dense_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub Ncontext_sparse: ::std::option::Option<i64>,
    pub Ncontext_dense: ::std::option::Option<i64>,
    pub Nfeature_list_sparse: ::std::option::Option<i64>,
    pub Nfeature_list_dense: ::std::option::Option<i64>,
    pub context_sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tcontext_dense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub feature_list_dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub context_dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub feature_list_sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub feature_list_dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ParseSequenceExample {
    /// Creates a new `ParseSequenceExample`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parse_sequence_example with default options.
pub fn parse_sequence_example<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    serialized: T0,
    debug_name: T1,
    context_dense_defaults: T2,
) -> Result<[crate::eager::TensorHandle; 9]> {
    let __args = ParseSequenceExample::new();
    parse_sequence_example_with_args(ctx, serialized, debug_name, context_dense_defaults, &__args)
}

/// parse_sequence_example with options.
pub fn parse_sequence_example_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    serialized: T0,
    debug_name: T1,
    context_dense_defaults: T2,
    __args: &ParseSequenceExample,
) -> Result<[crate::eager::TensorHandle; 9]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParseSequenceExample")?;

    // Required input arguments
    op.add_input(&serialized.to_handle()?)?;
    op.add_input(&debug_name.to_handle()?)?;
    op.add_input(&context_dense_defaults.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.feature_list_dense_missing_assumed_empty {
        op.set_attr_string_list("feature_list_dense_missing_assumed_empty", value);
    }
    if let ::std::option::Option::Some(value) = &__args.context_sparse_keys {
        op.set_attr_string_list("context_sparse_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.context_dense_keys {
        op.set_attr_string_list("context_dense_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_sparse_keys {
        op.set_attr_string_list("feature_list_sparse_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_dense_keys {
        op.set_attr_string_list("feature_list_dense_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Ncontext_sparse {
        op.set_attr_int("Ncontext_sparse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Ncontext_dense {
        op.set_attr_int("Ncontext_dense", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Nfeature_list_sparse {
        op.set_attr_int("Nfeature_list_sparse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Nfeature_list_dense {
        op.set_attr_int("Nfeature_list_dense", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.context_sparse_types {
        op.set_attr_type_list("context_sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcontext_dense {
        op.set_attr_type_list("Tcontext_dense", value);
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_dense_types {
        op.set_attr_type_list("feature_list_dense_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.context_dense_shapes {
        op.set_attr_shape_list("context_dense_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_sparse_types {
        op.set_attr_type_list("feature_list_sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_dense_shapes {
        op.set_attr_shape_list("feature_list_dense_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 9;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 9];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
                crate::eager::TensorHandle::from_tensor_handle(res[6]),
                crate::eager::TensorHandle::from_tensor_handle(res[7]),
                crate::eager::TensorHandle::from_tensor_handle(res[8]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// ParseSequenceExampleV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseSequenceExampleV2 {
    pub Ncontext_sparse: ::std::option::Option<i64>,
    pub Tcontext_dense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub context_sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub context_ragged_value_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub context_ragged_split_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub context_dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub Nfeature_list_sparse: ::std::option::Option<i64>,
    pub Nfeature_list_dense: ::std::option::Option<i64>,
    pub feature_list_dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub feature_list_sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub feature_list_ragged_value_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub feature_list_ragged_split_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub feature_list_dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ParseSequenceExampleV2 {
    /// Creates a new `ParseSequenceExampleV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parse_sequence_example_v2 with default options.
pub fn parse_sequence_example_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    serialized: T0,
    debug_name: T1,
    context_sparse_keys: T2,
    context_dense_keys: T3,
    context_ragged_keys: T4,
    feature_list_sparse_keys: T5,
    feature_list_dense_keys: T6,
    feature_list_ragged_keys: T7,
    feature_list_dense_missing_assumed_empty: T8,
    context_dense_defaults: T9,
) -> Result<[crate::eager::TensorHandle; 14]> {
    let __args = ParseSequenceExampleV2::new();
    parse_sequence_example_v2_with_args(
        ctx,
        serialized,
        debug_name,
        context_sparse_keys,
        context_dense_keys,
        context_ragged_keys,
        feature_list_sparse_keys,
        feature_list_dense_keys,
        feature_list_ragged_keys,
        feature_list_dense_missing_assumed_empty,
        context_dense_defaults,
        &__args,
    )
}

/// parse_sequence_example_v2 with options.
pub fn parse_sequence_example_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    serialized: T0,
    debug_name: T1,
    context_sparse_keys: T2,
    context_dense_keys: T3,
    context_ragged_keys: T4,
    feature_list_sparse_keys: T5,
    feature_list_dense_keys: T6,
    feature_list_ragged_keys: T7,
    feature_list_dense_missing_assumed_empty: T8,
    context_dense_defaults: T9,
    __args: &ParseSequenceExampleV2,
) -> Result<[crate::eager::TensorHandle; 14]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParseSequenceExampleV2")?;

    // Required input arguments
    op.add_input(&serialized.to_handle()?)?;
    op.add_input(&debug_name.to_handle()?)?;
    op.add_input(&context_sparse_keys.to_handle()?)?;
    op.add_input(&context_dense_keys.to_handle()?)?;
    op.add_input(&context_ragged_keys.to_handle()?)?;
    op.add_input(&feature_list_sparse_keys.to_handle()?)?;
    op.add_input(&feature_list_dense_keys.to_handle()?)?;
    op.add_input(&feature_list_ragged_keys.to_handle()?)?;
    op.add_input(&feature_list_dense_missing_assumed_empty.to_handle()?)?;
    op.add_input(&context_dense_defaults.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Ncontext_sparse {
        op.set_attr_int("Ncontext_sparse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcontext_dense {
        op.set_attr_type_list("Tcontext_dense", value);
    }
    if let ::std::option::Option::Some(value) = &__args.context_sparse_types {
        op.set_attr_type_list("context_sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.context_ragged_value_types {
        op.set_attr_type_list("context_ragged_value_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.context_ragged_split_types {
        op.set_attr_type_list("context_ragged_split_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.context_dense_shapes {
        op.set_attr_shape_list("context_dense_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.Nfeature_list_sparse {
        op.set_attr_int("Nfeature_list_sparse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Nfeature_list_dense {
        op.set_attr_int("Nfeature_list_dense", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_dense_types {
        op.set_attr_type_list("feature_list_dense_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_sparse_types {
        op.set_attr_type_list("feature_list_sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_ragged_value_types {
        op.set_attr_type_list("feature_list_ragged_value_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_ragged_split_types {
        op.set_attr_type_list("feature_list_ragged_split_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_dense_shapes {
        op.set_attr_shape_list("feature_list_dense_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 14;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 14];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
                crate::eager::TensorHandle::from_tensor_handle(res[6]),
                crate::eager::TensorHandle::from_tensor_handle(res[7]),
                crate::eager::TensorHandle::from_tensor_handle(res[8]),
                crate::eager::TensorHandle::from_tensor_handle(res[9]),
                crate::eager::TensorHandle::from_tensor_handle(res[10]),
                crate::eager::TensorHandle::from_tensor_handle(res[11]),
                crate::eager::TensorHandle::from_tensor_handle(res[12]),
                crate::eager::TensorHandle::from_tensor_handle(res[13]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// ParseSingleExample
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseSingleExample {
    pub num_sparse: ::std::option::Option<i64>,
    pub sparse_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub dense_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tdense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ParseSingleExample {
    /// Creates a new `ParseSingleExample`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parse_single_example with default options.
pub fn parse_single_example<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    serialized: T0,
    dense_defaults: T1,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = ParseSingleExample::new();
    parse_single_example_with_args(ctx, serialized, dense_defaults, &__args)
}

/// parse_single_example with options.
pub fn parse_single_example_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    serialized: T0,
    dense_defaults: T1,
    __args: &ParseSingleExample,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParseSingleExample")?;

    // Required input arguments
    op.add_input(&serialized.to_handle()?)?;
    op.add_input(&dense_defaults.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_sparse {
        op.set_attr_int("num_sparse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.sparse_keys {
        op.set_attr_string_list("sparse_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_keys {
        op.set_attr_string_list("dense_keys", value);
    }
    if let ::std::option::Option::Some(value) = &__args.sparse_types {
        op.set_attr_type_list("sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tdense {
        op.set_attr_type_list("Tdense", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_shapes {
        op.set_attr_shape_list("dense_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// ParseSingleSequenceExample
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseSingleSequenceExample {
    pub Ncontext_sparse: ::std::option::Option<i64>,
    pub Ncontext_dense: ::std::option::Option<i64>,
    pub Nfeature_list_sparse: ::std::option::Option<i64>,
    pub Nfeature_list_dense: ::std::option::Option<i64>,
    pub context_sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tcontext_dense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub feature_list_dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub context_dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub feature_list_sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub feature_list_dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ParseSingleSequenceExample {
    /// Creates a new `ParseSingleSequenceExample`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parse_single_sequence_example with default options.
pub fn parse_single_sequence_example<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    serialized: T0,
    feature_list_dense_missing_assumed_empty: T1,
    context_sparse_keys: T2,
    context_dense_keys: T3,
    feature_list_sparse_keys: T4,
    feature_list_dense_keys: T5,
    context_dense_defaults: T6,
    debug_name: T7,
) -> Result<[crate::eager::TensorHandle; 8]> {
    let __args = ParseSingleSequenceExample::new();
    parse_single_sequence_example_with_args(
        ctx,
        serialized,
        feature_list_dense_missing_assumed_empty,
        context_sparse_keys,
        context_dense_keys,
        feature_list_sparse_keys,
        feature_list_dense_keys,
        context_dense_defaults,
        debug_name,
        &__args,
    )
}

/// parse_single_sequence_example with options.
pub fn parse_single_sequence_example_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    serialized: T0,
    feature_list_dense_missing_assumed_empty: T1,
    context_sparse_keys: T2,
    context_dense_keys: T3,
    feature_list_sparse_keys: T4,
    feature_list_dense_keys: T5,
    context_dense_defaults: T6,
    debug_name: T7,
    __args: &ParseSingleSequenceExample,
) -> Result<[crate::eager::TensorHandle; 8]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParseSingleSequenceExample")?;

    // Required input arguments
    op.add_input(&serialized.to_handle()?)?;
    op.add_input(&feature_list_dense_missing_assumed_empty.to_handle()?)?;
    op.add_input(&context_sparse_keys.to_handle()?)?;
    op.add_input(&context_dense_keys.to_handle()?)?;
    op.add_input(&feature_list_sparse_keys.to_handle()?)?;
    op.add_input(&feature_list_dense_keys.to_handle()?)?;
    op.add_input(&context_dense_defaults.to_handle()?)?;
    op.add_input(&debug_name.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Ncontext_sparse {
        op.set_attr_int("Ncontext_sparse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Ncontext_dense {
        op.set_attr_int("Ncontext_dense", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Nfeature_list_sparse {
        op.set_attr_int("Nfeature_list_sparse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Nfeature_list_dense {
        op.set_attr_int("Nfeature_list_dense", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.context_sparse_types {
        op.set_attr_type_list("context_sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcontext_dense {
        op.set_attr_type_list("Tcontext_dense", value);
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_dense_types {
        op.set_attr_type_list("feature_list_dense_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.context_dense_shapes {
        op.set_attr_shape_list("context_dense_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_sparse_types {
        op.set_attr_type_list("feature_list_sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.feature_list_dense_shapes {
        op.set_attr_shape_list("feature_list_dense_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 8;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 8];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
                crate::eager::TensorHandle::from_tensor_handle(res[6]),
                crate::eager::TensorHandle::from_tensor_handle(res[7]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// ParseTensor
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseTensor {
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl ParseTensor {
    /// Creates a new `ParseTensor`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// parse_tensor with default options.
pub fn parse_tensor<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    serialized: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ParseTensor::new();
    parse_tensor_with_args(ctx, serialized, &__args)
}

/// parse_tensor with options.
pub fn parse_tensor_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    serialized: T0,
    __args: &ParseTensor,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ParseTensor")?;

    // Required input arguments
    op.add_input(&serialized.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PartitionedCall
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PartitionedCall {
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub f: ::std::option::Option<::std::string::String>,
    pub config: ::std::option::Option<::std::string::String>,
    pub config_proto: ::std::option::Option<::std::string::String>,
    pub executor_type: ::std::option::Option<::std::string::String>,
}

impl PartitionedCall {
    /// Creates a new `PartitionedCall`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// partitioned_call with default options.
pub fn partitioned_call<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    args: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = PartitionedCall::new();
    partitioned_call_with_args(ctx, args, &__args)
}

/// partitioned_call with options.
pub fn partitioned_call_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    args: T0,
    __args: &PartitionedCall,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PartitionedCall")?;

    // Required input arguments
    op.add_input(&args.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }
    if let ::std::option::Option::Some(value) = &__args.config_proto {
        op.set_attr_string("config_proto", value);
    }
    if let ::std::option::Option::Some(value) = &__args.executor_type {
        op.set_attr_string("executor_type", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Placeholder
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Placeholder {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
}

impl Placeholder {
    /// Creates a new `Placeholder`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// placeholder with default options.
pub fn placeholder(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = Placeholder::new();
    placeholder_with_args(ctx, &__args)
}

/// placeholder with options.
pub fn placeholder_with_args(
    ctx: &crate::eager::Context,
    __args: &Placeholder,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Placeholder")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PlaceholderV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PlaceholderV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
}

impl PlaceholderV2 {
    /// Creates a new `PlaceholderV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// placeholder_v2 with default options.
pub fn placeholder_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = PlaceholderV2::new();
    placeholder_v2_with_args(ctx, &__args)
}

/// placeholder_v2 with options.
pub fn placeholder_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &PlaceholderV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PlaceholderV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PlaceholderWithDefault
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PlaceholderWithDefault {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
}

impl PlaceholderWithDefault {
    /// Creates a new `PlaceholderWithDefault`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// placeholder_with_default with default options.
pub fn placeholder_with_default<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = PlaceholderWithDefault::new();
    placeholder_with_default_with_args(ctx, input, &__args)
}

/// placeholder_with_default with options.
pub fn placeholder_with_default_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &PlaceholderWithDefault,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PlaceholderWithDefault")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Polygamma
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Polygamma {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Polygamma {
    /// Creates a new `Polygamma`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// polygamma with default options.
pub fn polygamma<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    x: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Polygamma::new();
    polygamma_with_args(ctx, a, x, &__args)
}

/// polygamma with options.
pub fn polygamma_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    x: T1,
    __args: &Polygamma,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Polygamma")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PopulationCount
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PopulationCount {
    pub T: ::std::option::Option<crate::DataType>,
}

impl PopulationCount {
    /// Creates a new `PopulationCount`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// population_count with default options.
pub fn population_count<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = PopulationCount::new();
    population_count_with_args(ctx, x, &__args)
}

/// population_count with options.
pub fn population_count_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &PopulationCount,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PopulationCount")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Pow
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Pow {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Pow {
    /// Creates a new `Pow`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// pow with default options.
pub fn pow<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Pow::new();
    pow_with_args(ctx, x, y, &__args)
}

/// pow with options.
pub fn pow_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Pow,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Pow")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PrefetchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PrefetchDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub slack_period: ::std::option::Option<i64>,
    pub legacy_autotune: ::std::option::Option<bool>,
    pub buffer_size_min: ::std::option::Option<i64>,
}

impl PrefetchDataset {
    /// Creates a new `PrefetchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// prefetch_dataset with default options.
pub fn prefetch_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    buffer_size: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = PrefetchDataset::new();
    prefetch_dataset_with_args(ctx, input_dataset, buffer_size, &__args)
}

/// prefetch_dataset with options.
pub fn prefetch_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    buffer_size: T1,
    __args: &PrefetchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PrefetchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.slack_period {
        op.set_attr_int("slack_period", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.legacy_autotune {
        op.set_attr_bool("legacy_autotune", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.buffer_size_min {
        op.set_attr_int("buffer_size_min", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Prelinearize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Prelinearize {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
    pub layout: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl Prelinearize {
    /// Creates a new `Prelinearize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// prelinearize with default options.
pub fn prelinearize<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Prelinearize::new();
    prelinearize_with_args(ctx, input, &__args)
}

/// prelinearize with options.
pub fn prelinearize_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Prelinearize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Prelinearize")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.layout {
        op.set_attr_int_list("layout", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PrelinearizeTuple
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PrelinearizeTuple {
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub layouts: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl PrelinearizeTuple {
    /// Creates a new `PrelinearizeTuple`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// prelinearize_tuple with default options.
pub fn prelinearize_tuple<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = PrelinearizeTuple::new();
    prelinearize_tuple_with_args(ctx, inputs, &__args)
}

/// prelinearize_tuple with options.
pub fn prelinearize_tuple_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &PrelinearizeTuple,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PrelinearizeTuple")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.layouts {
        op.set_attr_int_list("layouts", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PreventGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PreventGradient {
    pub T: ::std::option::Option<crate::DataType>,
    pub message: ::std::option::Option<::std::string::String>,
}

impl PreventGradient {
    /// Creates a new `PreventGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// prevent_gradient with default options.
pub fn prevent_gradient<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = PreventGradient::new();
    prevent_gradient_with_args(ctx, input, &__args)
}

/// prevent_gradient with options.
pub fn prevent_gradient_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &PreventGradient,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PreventGradient")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.message {
        op.set_attr_string("message", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Print
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Print {
    pub T: ::std::option::Option<crate::DataType>,
    pub U: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub message: ::std::option::Option<::std::string::String>,
    pub first_n: ::std::option::Option<i64>,
    pub summarize: ::std::option::Option<i64>,
}

impl Print {
    /// Creates a new `Print`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// print with default options.
pub fn print<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    data: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Print::new();
    print_with_args(ctx, input, data, &__args)
}

/// print with options.
pub fn print_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    data: T1,
    __args: &Print,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Print")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.U {
        op.set_attr_type_list("U", value);
    }
    if let ::std::option::Option::Some(value) = &__args.message {
        op.set_attr_string("message", value);
    }
    if let ::std::option::Option::Some(value) = &__args.first_n {
        op.set_attr_int("first_n", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.summarize {
        op.set_attr_int("summarize", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PrintV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PrintV2 {
    pub output_stream: ::std::option::Option<::std::string::String>,
    pub end: ::std::option::Option<::std::string::String>,
}

impl PrintV2 {
    /// Creates a new `PrintV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// print_v2 with default options.
pub fn print_v2<T0: crate::eager::ToHandle>(ctx: &crate::eager::Context, input: T0) -> Result<()> {
    let __args = PrintV2::new();
    print_v2_with_args(ctx, input, &__args)
}

/// print_v2 with options.
pub fn print_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &PrintV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PrintV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_stream {
        op.set_attr_string("output_stream", value);
    }
    if let ::std::option::Option::Some(value) = &__args.end {
        op.set_attr_string("end", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// PriorityQueue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PriorityQueue {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub capacity: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl PriorityQueue {
    /// Creates a new `PriorityQueue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// priority_queue with default options.
pub fn priority_queue(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = PriorityQueue::new();
    priority_queue_with_args(ctx, &__args)
}

/// priority_queue with options.
pub fn priority_queue_with_args(
    ctx: &crate::eager::Context,
    __args: &PriorityQueue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PriorityQueue")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PriorityQueueV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PriorityQueueV2 {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub capacity: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl PriorityQueueV2 {
    /// Creates a new `PriorityQueueV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// priority_queue_v2 with default options.
pub fn priority_queue_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = PriorityQueueV2::new();
    priority_queue_v2_with_args(ctx, &__args)
}

/// priority_queue_v2 with options.
pub fn priority_queue_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &PriorityQueueV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PriorityQueueV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PrivateThreadPoolDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PrivateThreadPoolDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl PrivateThreadPoolDataset {
    /// Creates a new `PrivateThreadPoolDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// private_thread_pool_dataset with default options.
pub fn private_thread_pool_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_threads: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = PrivateThreadPoolDataset::new();
    private_thread_pool_dataset_with_args(ctx, input_dataset, num_threads, &__args)
}

/// private_thread_pool_dataset with options.
pub fn private_thread_pool_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_threads: T1,
    __args: &PrivateThreadPoolDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PrivateThreadPoolDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&num_threads.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Prod
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Prod {
    pub keep_dims: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl Prod {
    /// Creates a new `Prod`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// prod with default options.
pub fn prod<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Prod::new();
    prod_with_args(ctx, input, reduction_indices, &__args)
}

/// prod with options.
pub fn prod_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
    __args: &Prod,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Prod")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&reduction_indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PyFunc
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PyFunc {
    pub token: ::std::option::Option<::std::string::String>,
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl PyFunc {
    /// Creates a new `PyFunc`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// py_func with default options.
pub fn py_func<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = PyFunc::new();
    py_func_with_args(ctx, input, &__args)
}

/// py_func with options.
pub fn py_func_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &PyFunc,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PyFunc")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.token {
        op.set_attr_string("token", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// PyFuncStateless
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PyFuncStateless {
    pub token: ::std::option::Option<::std::string::String>,
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl PyFuncStateless {
    /// Creates a new `PyFuncStateless`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// py_func_stateless with default options.
pub fn py_func_stateless<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = PyFuncStateless::new();
    py_func_stateless_with_args(ctx, input, &__args)
}

/// py_func_stateless with options.
pub fn py_func_stateless_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &PyFuncStateless,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "PyFuncStateless")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.token {
        op.set_attr_string("token", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Qr
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Qr {
    pub full_matrices: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl Qr {
    /// Creates a new `Qr`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// qr with default options.
pub fn qr<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = Qr::new();
    qr_with_args(ctx, input, &__args)
}

/// qr with options.
pub fn qr_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Qr,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Qr")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.full_matrices {
        op.set_attr_bool("full_matrices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizeAndDequantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizeAndDequantize {
    pub signed_input: ::std::option::Option<bool>,
    pub num_bits: ::std::option::Option<i64>,
    pub range_given: ::std::option::Option<bool>,
    pub input_min: ::std::option::Option<f32>,
    pub input_max: ::std::option::Option<f32>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl QuantizeAndDequantize {
    /// Creates a new `QuantizeAndDequantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantize_and_dequantize with default options.
pub fn quantize_and_dequantize<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = QuantizeAndDequantize::new();
    quantize_and_dequantize_with_args(ctx, input, &__args)
}

/// quantize_and_dequantize with options.
pub fn quantize_and_dequantize_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &QuantizeAndDequantize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizeAndDequantize")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.signed_input {
        op.set_attr_bool("signed_input", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_bits {
        op.set_attr_int("num_bits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.range_given {
        op.set_attr_bool("range_given", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_min {
        op.set_attr_float("input_min", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_max {
        op.set_attr_float("input_max", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizeAndDequantizeV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizeAndDequantizeV2 {
    pub signed_input: ::std::option::Option<bool>,
    pub num_bits: ::std::option::Option<i64>,
    pub range_given: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub round_mode: ::std::option::Option<::std::string::String>,
    pub narrow_range: ::std::option::Option<bool>,
    pub axis: ::std::option::Option<i64>,
}

impl QuantizeAndDequantizeV2 {
    /// Creates a new `QuantizeAndDequantizeV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantize_and_dequantize_v2 with default options.
pub fn quantize_and_dequantize_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = QuantizeAndDequantizeV2::new();
    quantize_and_dequantize_v2_with_args(ctx, input, input_min, input_max, &__args)
}

/// quantize_and_dequantize_v2 with options.
pub fn quantize_and_dequantize_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
    __args: &QuantizeAndDequantizeV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizeAndDequantizeV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_min.to_handle()?)?;
    op.add_input(&input_max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.signed_input {
        op.set_attr_bool("signed_input", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_bits {
        op.set_attr_int("num_bits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.range_given {
        op.set_attr_bool("range_given", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.round_mode {
        op.set_attr_string("round_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.narrow_range {
        op.set_attr_bool("narrow_range", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.axis {
        op.set_attr_int("axis", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizeAndDequantizeV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizeAndDequantizeV3 {
    pub signed_input: ::std::option::Option<bool>,
    pub range_given: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub narrow_range: ::std::option::Option<bool>,
    pub axis: ::std::option::Option<i64>,
}

impl QuantizeAndDequantizeV3 {
    /// Creates a new `QuantizeAndDequantizeV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantize_and_dequantize_v3 with default options.
pub fn quantize_and_dequantize_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
    num_bits: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = QuantizeAndDequantizeV3::new();
    quantize_and_dequantize_v3_with_args(ctx, input, input_min, input_max, num_bits, &__args)
}

/// quantize_and_dequantize_v3 with options.
pub fn quantize_and_dequantize_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
    num_bits: T3,
    __args: &QuantizeAndDequantizeV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizeAndDequantizeV3")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_min.to_handle()?)?;
    op.add_input(&input_max.to_handle()?)?;
    op.add_input(&num_bits.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.signed_input {
        op.set_attr_bool("signed_input", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.range_given {
        op.set_attr_bool("range_given", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.narrow_range {
        op.set_attr_bool("narrow_range", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.axis {
        op.set_attr_int("axis", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizeAndDequantizeV4
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizeAndDequantizeV4 {
    pub signed_input: ::std::option::Option<bool>,
    pub num_bits: ::std::option::Option<i64>,
    pub range_given: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub round_mode: ::std::option::Option<::std::string::String>,
    pub narrow_range: ::std::option::Option<bool>,
    pub axis: ::std::option::Option<i64>,
}

impl QuantizeAndDequantizeV4 {
    /// Creates a new `QuantizeAndDequantizeV4`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantize_and_dequantize_v4 with default options.
pub fn quantize_and_dequantize_v4<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = QuantizeAndDequantizeV4::new();
    quantize_and_dequantize_v4_with_args(ctx, input, input_min, input_max, &__args)
}

/// quantize_and_dequantize_v4 with options.
pub fn quantize_and_dequantize_v4_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
    __args: &QuantizeAndDequantizeV4,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizeAndDequantizeV4")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_min.to_handle()?)?;
    op.add_input(&input_max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.signed_input {
        op.set_attr_bool("signed_input", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_bits {
        op.set_attr_int("num_bits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.range_given {
        op.set_attr_bool("range_given", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.round_mode {
        op.set_attr_string("round_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.narrow_range {
        op.set_attr_bool("narrow_range", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.axis {
        op.set_attr_int("axis", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizeAndDequantizeV4Grad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizeAndDequantizeV4Grad {
    pub T: ::std::option::Option<crate::DataType>,
    pub axis: ::std::option::Option<i64>,
}

impl QuantizeAndDequantizeV4Grad {
    /// Creates a new `QuantizeAndDequantizeV4Grad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantize_and_dequantize_v4_grad with default options.
pub fn quantize_and_dequantize_v4_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    gradients: T0,
    input: T1,
    input_min: T2,
    input_max: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizeAndDequantizeV4Grad::new();
    quantize_and_dequantize_v4_grad_with_args(ctx, gradients, input, input_min, input_max, &__args)
}

/// quantize_and_dequantize_v4_grad with options.
pub fn quantize_and_dequantize_v4_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    gradients: T0,
    input: T1,
    input_min: T2,
    input_max: T3,
    __args: &QuantizeAndDequantizeV4Grad,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizeAndDequantizeV4Grad")?;

    // Required input arguments
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_min.to_handle()?)?;
    op.add_input(&input_max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.axis {
        op.set_attr_int("axis", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizeDownAndShrinkRange
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizeDownAndShrinkRange {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl QuantizeDownAndShrinkRange {
    /// Creates a new `QuantizeDownAndShrinkRange`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantize_down_and_shrink_range with default options.
pub fn quantize_down_and_shrink_range<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizeDownAndShrinkRange::new();
    quantize_down_and_shrink_range_with_args(ctx, input, input_min, input_max, &__args)
}

/// quantize_down_and_shrink_range with options.
pub fn quantize_down_and_shrink_range_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
    __args: &QuantizeDownAndShrinkRange,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizeDownAndShrinkRange")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_min.to_handle()?)?;
    op.add_input(&input_max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizeV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizeV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub mode: ::std::option::Option<::std::string::String>,
    pub round_mode: ::std::option::Option<::std::string::String>,
    pub narrow_range: ::std::option::Option<bool>,
    pub axis: ::std::option::Option<i64>,
    pub ensure_minimum_range: ::std::option::Option<f32>,
}

impl QuantizeV2 {
    /// Creates a new `QuantizeV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantize_v2 with default options.
pub fn quantize_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    min_range: T1,
    max_range: T2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizeV2::new();
    quantize_v2_with_args(ctx, input, min_range, max_range, &__args)
}

/// quantize_v2 with options.
pub fn quantize_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    min_range: T1,
    max_range: T2,
    __args: &QuantizeV2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizeV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&min_range.to_handle()?)?;
    op.add_input(&max_range.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.mode {
        op.set_attr_string("mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.round_mode {
        op.set_attr_string("round_mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.narrow_range {
        op.set_attr_bool("narrow_range", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.axis {
        op.set_attr_int("axis", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ensure_minimum_range {
        op.set_attr_float("ensure_minimum_range", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedAdd {
    pub T1: ::std::option::Option<crate::DataType>,
    pub T2: ::std::option::Option<crate::DataType>,
    pub Toutput: ::std::option::Option<crate::DataType>,
}

impl QuantizedAdd {
    /// Creates a new `QuantizedAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_add with default options.
pub fn quantized_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    min_x: T2,
    max_x: T3,
    min_y: T4,
    max_y: T5,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedAdd::new();
    quantized_add_with_args(ctx, x, y, min_x, max_x, min_y, max_y, &__args)
}

/// quantized_add with options.
pub fn quantized_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    min_x: T2,
    max_x: T3,
    min_y: T4,
    max_y: T5,
    __args: &QuantizedAdd,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedAdd")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;
    op.add_input(&min_x.to_handle()?)?;
    op.add_input(&max_x.to_handle()?)?;
    op.add_input(&min_y.to_handle()?)?;
    op.add_input(&max_y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T1 {
        op.set_attr_type("T1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T2 {
        op.set_attr_type("T2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Toutput {
        op.set_attr_type("Toutput", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedAvgPool
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedAvgPool {
    pub T: ::std::option::Option<crate::DataType>,
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
}

impl QuantizedAvgPool {
    /// Creates a new `QuantizedAvgPool`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_avg_pool with default options.
pub fn quantized_avg_pool<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    min_input: T1,
    max_input: T2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedAvgPool::new();
    quantized_avg_pool_with_args(ctx, input, min_input, max_input, &__args)
}

/// quantized_avg_pool with options.
pub fn quantized_avg_pool_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    min_input: T1,
    max_input: T2,
    __args: &QuantizedAvgPool,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedAvgPool")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedBatchNormWithGlobalNormalization
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedBatchNormWithGlobalNormalization {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub variance_epsilon: ::std::option::Option<f32>,
    pub scale_after_normalization: ::std::option::Option<bool>,
}

impl QuantizedBatchNormWithGlobalNormalization {
    /// Creates a new `QuantizedBatchNormWithGlobalNormalization`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_batch_norm_with_global_normalization with default options.
pub fn quantized_batch_norm_with_global_normalization<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
    T12: crate::eager::ToHandle,
    T13: crate::eager::ToHandle,
    T14: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    t: T0,
    t_min: T1,
    t_max: T2,
    m: T3,
    m_min: T4,
    m_max: T5,
    v: T6,
    v_min: T7,
    v_max: T8,
    beta: T9,
    beta_min: T10,
    beta_max: T11,
    gamma: T12,
    gamma_min: T13,
    gamma_max: T14,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedBatchNormWithGlobalNormalization::new();
    quantized_batch_norm_with_global_normalization_with_args(
        ctx, t, t_min, t_max, m, m_min, m_max, v, v_min, v_max, beta, beta_min, beta_max, gamma,
        gamma_min, gamma_max, &__args,
    )
}

/// quantized_batch_norm_with_global_normalization with options.
pub fn quantized_batch_norm_with_global_normalization_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
    T12: crate::eager::ToHandle,
    T13: crate::eager::ToHandle,
    T14: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    t: T0,
    t_min: T1,
    t_max: T2,
    m: T3,
    m_min: T4,
    m_max: T5,
    v: T6,
    v_min: T7,
    v_max: T8,
    beta: T9,
    beta_min: T10,
    beta_max: T11,
    gamma: T12,
    gamma_min: T13,
    gamma_max: T14,
    __args: &QuantizedBatchNormWithGlobalNormalization,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedBatchNormWithGlobalNormalization")?;

    // Required input arguments
    op.add_input(&t.to_handle()?)?;
    op.add_input(&t_min.to_handle()?)?;
    op.add_input(&t_max.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&m_min.to_handle()?)?;
    op.add_input(&m_max.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;
    op.add_input(&v_min.to_handle()?)?;
    op.add_input(&v_max.to_handle()?)?;
    op.add_input(&beta.to_handle()?)?;
    op.add_input(&beta_min.to_handle()?)?;
    op.add_input(&beta_max.to_handle()?)?;
    op.add_input(&gamma.to_handle()?)?;
    op.add_input(&gamma_min.to_handle()?)?;
    op.add_input(&gamma_max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.variance_epsilon {
        op.set_attr_float("variance_epsilon", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.scale_after_normalization {
        op.set_attr_bool("scale_after_normalization", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedBiasAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedBiasAdd {
    pub T1: ::std::option::Option<crate::DataType>,
    pub T2: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl QuantizedBiasAdd {
    /// Creates a new `QuantizedBiasAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_bias_add with default options.
pub fn quantized_bias_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    bias: T1,
    min_input: T2,
    max_input: T3,
    min_bias: T4,
    max_bias: T5,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedBiasAdd::new();
    quantized_bias_add_with_args(
        ctx, input, bias, min_input, max_input, min_bias, max_bias, &__args,
    )
}

/// quantized_bias_add with options.
pub fn quantized_bias_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    bias: T1,
    min_input: T2,
    max_input: T3,
    min_bias: T4,
    max_bias: T5,
    __args: &QuantizedBiasAdd,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedBiasAdd")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_bias.to_handle()?)?;
    op.add_input(&max_bias.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T1 {
        op.set_attr_type("T1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T2 {
        op.set_attr_type("T2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConcat
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConcat {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl QuantizedConcat {
    /// Creates a new `QuantizedConcat`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_concat with default options.
pub fn quantized_concat<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    concat_dim: T0,
    values: T1,
    input_mins: T2,
    input_maxes: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConcat::new();
    quantized_concat_with_args(ctx, concat_dim, values, input_mins, input_maxes, &__args)
}

/// quantized_concat with options.
pub fn quantized_concat_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    concat_dim: T0,
    values: T1,
    input_mins: T2,
    input_maxes: T3,
    __args: &QuantizedConcat,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedConcat")?;

    // Required input arguments
    op.add_input(&concat_dim.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&input_mins.to_handle()?)?;
    op.add_input(&input_maxes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConv2D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2D {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedConv2D {
    /// Creates a new `QuantizedConv2D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_conv2_d with default options.
pub fn quantized_conv2_d<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    min_input: T2,
    max_input: T3,
    min_filter: T4,
    max_filter: T5,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConv2D::new();
    quantized_conv2_d_with_args(
        ctx, input, filter, min_input, max_input, min_filter, max_filter, &__args,
    )
}

/// quantized_conv2_d with options.
pub fn quantized_conv2_d_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    min_input: T2,
    max_input: T3,
    min_filter: T4,
    max_filter: T5,
    __args: &QuantizedConv2D,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedConv2D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConv2DAndRelu
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DAndRelu {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedConv2DAndRelu {
    /// Creates a new `QuantizedConv2DAndRelu`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_conv2_dand_relu with default options.
pub fn quantized_conv2_dand_relu<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    min_input: T2,
    max_input: T3,
    min_filter: T4,
    max_filter: T5,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConv2DAndRelu::new();
    quantized_conv2_dand_relu_with_args(
        ctx, input, filter, min_input, max_input, min_filter, max_filter, &__args,
    )
}

/// quantized_conv2_dand_relu with options.
pub fn quantized_conv2_dand_relu_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    min_input: T2,
    max_input: T3,
    min_filter: T4,
    max_filter: T5,
    __args: &QuantizedConv2DAndRelu,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedConv2DAndRelu")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_list {
        op.set_attr_int_list("padding_list", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConv2DAndReluAndRequantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DAndReluAndRequantize {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedConv2DAndReluAndRequantize {
    /// Creates a new `QuantizedConv2DAndReluAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_conv2_dand_relu_and_requantize with default options.
pub fn quantized_conv2_dand_relu_and_requantize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    min_input: T2,
    max_input: T3,
    min_filter: T4,
    max_filter: T5,
    min_freezed_output: T6,
    max_freezed_output: T7,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConv2DAndReluAndRequantize::new();
    quantized_conv2_dand_relu_and_requantize_with_args(
        ctx,
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        &__args,
    )
}

/// quantized_conv2_dand_relu_and_requantize with options.
pub fn quantized_conv2_dand_relu_and_requantize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    min_input: T2,
    max_input: T3,
    min_filter: T4,
    max_filter: T5,
    min_freezed_output: T6,
    max_freezed_output: T7,
    __args: &QuantizedConv2DAndReluAndRequantize,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedConv2DAndReluAndRequantize")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;
    op.add_input(&min_freezed_output.to_handle()?)?;
    op.add_input(&max_freezed_output.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_list {
        op.set_attr_int_list("padding_list", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConv2DAndRequantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DAndRequantize {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedConv2DAndRequantize {
    /// Creates a new `QuantizedConv2DAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_conv2_dand_requantize with default options.
pub fn quantized_conv2_dand_requantize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    min_input: T2,
    max_input: T3,
    min_filter: T4,
    max_filter: T5,
    min_freezed_output: T6,
    max_freezed_output: T7,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConv2DAndRequantize::new();
    quantized_conv2_dand_requantize_with_args(
        ctx,
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        &__args,
    )
}

/// quantized_conv2_dand_requantize with options.
pub fn quantized_conv2_dand_requantize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    min_input: T2,
    max_input: T3,
    min_filter: T4,
    max_filter: T5,
    min_freezed_output: T6,
    max_freezed_output: T7,
    __args: &QuantizedConv2DAndRequantize,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedConv2DAndRequantize")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;
    op.add_input(&min_freezed_output.to_handle()?)?;
    op.add_input(&max_freezed_output.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_list {
        op.set_attr_int_list("padding_list", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConv2DPerChannel
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DPerChannel {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedConv2DPerChannel {
    /// Creates a new `QuantizedConv2DPerChannel`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_conv2_dper_channel with default options.
pub fn quantized_conv2_dper_channel<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    min_input: T2,
    max_input: T3,
    min_filter: T4,
    max_filter: T5,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConv2DPerChannel::new();
    quantized_conv2_dper_channel_with_args(
        ctx, input, filter, min_input, max_input, min_filter, max_filter, &__args,
    )
}

/// quantized_conv2_dper_channel with options.
pub fn quantized_conv2_dper_channel_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    min_input: T2,
    max_input: T3,
    min_filter: T4,
    max_filter: T5,
    __args: &QuantizedConv2DPerChannel,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedConv2DPerChannel")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConv2DWithBias
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBias {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedConv2DWithBias {
    /// Creates a new `QuantizedConv2DWithBias`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_conv2_dwith_bias with default options.
pub fn quantized_conv2_dwith_bias<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConv2DWithBias::new();
    quantized_conv2_dwith_bias_with_args(
        ctx, input, filter, bias, min_input, max_input, min_filter, max_filter, &__args,
    )
}

/// quantized_conv2_dwith_bias with options.
pub fn quantized_conv2_dwith_bias_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    __args: &QuantizedConv2DWithBias,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedConv2DWithBias")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_list {
        op.set_attr_int_list("padding_list", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConv2DWithBiasAndRelu
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBiasAndRelu {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedConv2DWithBiasAndRelu {
    /// Creates a new `QuantizedConv2DWithBiasAndRelu`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_conv2_dwith_bias_and_relu with default options.
pub fn quantized_conv2_dwith_bias_and_relu<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConv2DWithBiasAndRelu::new();
    quantized_conv2_dwith_bias_and_relu_with_args(
        ctx, input, filter, bias, min_input, max_input, min_filter, max_filter, &__args,
    )
}

/// quantized_conv2_dwith_bias_and_relu with options.
pub fn quantized_conv2_dwith_bias_and_relu_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    __args: &QuantizedConv2DWithBiasAndRelu,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedConv2DWithBiasAndRelu")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_list {
        op.set_attr_int_list("padding_list", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConv2DWithBiasAndReluAndRequantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBiasAndReluAndRequantize {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub Tbias: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedConv2DWithBiasAndReluAndRequantize {
    /// Creates a new `QuantizedConv2DWithBiasAndReluAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_conv2_dwith_bias_and_relu_and_requantize with default options.
pub fn quantized_conv2_dwith_bias_and_relu_and_requantize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConv2DWithBiasAndReluAndRequantize::new();
    quantized_conv2_dwith_bias_and_relu_and_requantize_with_args(
        ctx,
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        &__args,
    )
}

/// quantized_conv2_dwith_bias_and_relu_and_requantize with options.
pub fn quantized_conv2_dwith_bias_and_relu_and_requantize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
    __args: &QuantizedConv2DWithBiasAndReluAndRequantize,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedConv2DWithBiasAndReluAndRequantize")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;
    op.add_input(&min_freezed_output.to_handle()?)?;
    op.add_input(&max_freezed_output.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tbias {
        op.set_attr_type("Tbias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_list {
        op.set_attr_int_list("padding_list", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConv2DWithBiasAndRequantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBiasAndRequantize {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub Tbias: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedConv2DWithBiasAndRequantize {
    /// Creates a new `QuantizedConv2DWithBiasAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_conv2_dwith_bias_and_requantize with default options.
pub fn quantized_conv2_dwith_bias_and_requantize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConv2DWithBiasAndRequantize::new();
    quantized_conv2_dwith_bias_and_requantize_with_args(
        ctx,
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        &__args,
    )
}

/// quantized_conv2_dwith_bias_and_requantize with options.
pub fn quantized_conv2_dwith_bias_and_requantize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
    __args: &QuantizedConv2DWithBiasAndRequantize,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedConv2DWithBiasAndRequantize")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;
    op.add_input(&min_freezed_output.to_handle()?)?;
    op.add_input(&max_freezed_output.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tbias {
        op.set_attr_type("Tbias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_list {
        op.set_attr_int_list("padding_list", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConv2DWithBiasSignedSumAndReluAndRequantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBiasSignedSumAndReluAndRequantize {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub Tbias: ::std::option::Option<crate::DataType>,
    pub Tsummand: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedConv2DWithBiasSignedSumAndReluAndRequantize {
    /// Creates a new `QuantizedConv2DWithBiasSignedSumAndReluAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_conv2_dwith_bias_signed_sum_and_relu_and_requantize with default options.
pub fn quantized_conv2_dwith_bias_signed_sum_and_relu_and_requantize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
    summand: T9,
    min_summand: T10,
    max_summand: T11,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConv2DWithBiasSignedSumAndReluAndRequantize::new();
    quantized_conv2_dwith_bias_signed_sum_and_relu_and_requantize_with_args(
        ctx,
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        summand,
        min_summand,
        max_summand,
        &__args,
    )
}

/// quantized_conv2_dwith_bias_signed_sum_and_relu_and_requantize with options.
pub fn quantized_conv2_dwith_bias_signed_sum_and_relu_and_requantize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
    summand: T9,
    min_summand: T10,
    max_summand: T11,
    __args: &QuantizedConv2DWithBiasSignedSumAndReluAndRequantize,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op =
        crate::eager::Op::new(ctx, "QuantizedConv2DWithBiasSignedSumAndReluAndRequantize")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;
    op.add_input(&min_freezed_output.to_handle()?)?;
    op.add_input(&max_freezed_output.to_handle()?)?;
    op.add_input(&summand.to_handle()?)?;
    op.add_input(&min_summand.to_handle()?)?;
    op.add_input(&max_summand.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tbias {
        op.set_attr_type("Tbias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsummand {
        op.set_attr_type("Tsummand", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_list {
        op.set_attr_int_list("padding_list", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConv2DWithBiasSumAndRelu
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBiasSumAndRelu {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedConv2DWithBiasSumAndRelu {
    /// Creates a new `QuantizedConv2DWithBiasSumAndRelu`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_conv2_dwith_bias_sum_and_relu with default options.
pub fn quantized_conv2_dwith_bias_sum_and_relu<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    summand: T7,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConv2DWithBiasSumAndRelu::new();
    quantized_conv2_dwith_bias_sum_and_relu_with_args(
        ctx, input, filter, bias, min_input, max_input, min_filter, max_filter, summand, &__args,
    )
}

/// quantized_conv2_dwith_bias_sum_and_relu with options.
pub fn quantized_conv2_dwith_bias_sum_and_relu_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    summand: T7,
    __args: &QuantizedConv2DWithBiasSumAndRelu,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedConv2DWithBiasSumAndRelu")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;
    op.add_input(&summand.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_list {
        op.set_attr_int_list("padding_list", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedConv2DWithBiasSumAndReluAndRequantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBiasSumAndReluAndRequantize {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub Tbias: ::std::option::Option<crate::DataType>,
    pub Tsummand: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedConv2DWithBiasSumAndReluAndRequantize {
    /// Creates a new `QuantizedConv2DWithBiasSumAndReluAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_conv2_dwith_bias_sum_and_relu_and_requantize with default options.
pub fn quantized_conv2_dwith_bias_sum_and_relu_and_requantize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
    summand: T9,
    min_summand: T10,
    max_summand: T11,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedConv2DWithBiasSumAndReluAndRequantize::new();
    quantized_conv2_dwith_bias_sum_and_relu_and_requantize_with_args(
        ctx,
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        summand,
        min_summand,
        max_summand,
        &__args,
    )
}

/// quantized_conv2_dwith_bias_sum_and_relu_and_requantize with options.
pub fn quantized_conv2_dwith_bias_sum_and_relu_and_requantize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
    T11: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
    summand: T9,
    min_summand: T10,
    max_summand: T11,
    __args: &QuantizedConv2DWithBiasSumAndReluAndRequantize,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedConv2DWithBiasSumAndReluAndRequantize")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;
    op.add_input(&min_freezed_output.to_handle()?)?;
    op.add_input(&max_freezed_output.to_handle()?)?;
    op.add_input(&summand.to_handle()?)?;
    op.add_input(&min_summand.to_handle()?)?;
    op.add_input(&max_summand.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tbias {
        op.set_attr_type("Tbias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsummand {
        op.set_attr_type("Tsummand", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_list {
        op.set_attr_int_list("padding_list", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedDepthwiseConv2D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedDepthwiseConv2D {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedDepthwiseConv2D {
    /// Creates a new `QuantizedDepthwiseConv2D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_depthwise_conv2_d with default options.
pub fn quantized_depthwise_conv2_d<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    min_input: T2,
    max_input: T3,
    min_filter: T4,
    max_filter: T5,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedDepthwiseConv2D::new();
    quantized_depthwise_conv2_d_with_args(
        ctx, input, filter, min_input, max_input, min_filter, max_filter, &__args,
    )
}

/// quantized_depthwise_conv2_d with options.
pub fn quantized_depthwise_conv2_d_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    min_input: T2,
    max_input: T3,
    min_filter: T4,
    max_filter: T5,
    __args: &QuantizedDepthwiseConv2D,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedDepthwiseConv2D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedDepthwiseConv2DWithBias
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedDepthwiseConv2DWithBias {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedDepthwiseConv2DWithBias {
    /// Creates a new `QuantizedDepthwiseConv2DWithBias`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_depthwise_conv2_dwith_bias with default options.
pub fn quantized_depthwise_conv2_dwith_bias<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedDepthwiseConv2DWithBias::new();
    quantized_depthwise_conv2_dwith_bias_with_args(
        ctx, input, filter, bias, min_input, max_input, min_filter, max_filter, &__args,
    )
}

/// quantized_depthwise_conv2_dwith_bias with options.
pub fn quantized_depthwise_conv2_dwith_bias_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    __args: &QuantizedDepthwiseConv2DWithBias,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedDepthwiseConv2DWithBias")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedDepthwiseConv2DWithBiasAndRelu
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedDepthwiseConv2DWithBiasAndRelu {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedDepthwiseConv2DWithBiasAndRelu {
    /// Creates a new `QuantizedDepthwiseConv2DWithBiasAndRelu`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_depthwise_conv2_dwith_bias_and_relu with default options.
pub fn quantized_depthwise_conv2_dwith_bias_and_relu<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedDepthwiseConv2DWithBiasAndRelu::new();
    quantized_depthwise_conv2_dwith_bias_and_relu_with_args(
        ctx, input, filter, bias, min_input, max_input, min_filter, max_filter, &__args,
    )
}

/// quantized_depthwise_conv2_dwith_bias_and_relu with options.
pub fn quantized_depthwise_conv2_dwith_bias_and_relu_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    __args: &QuantizedDepthwiseConv2DWithBiasAndRelu,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedDepthwiseConv2DWithBiasAndRelu")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_list {
        op.set_attr_int_list("padding_list", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub Tfilter: ::std::option::Option<crate::DataType>,
    pub Tbias: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize {
    /// Creates a new `QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_depthwise_conv2_dwith_bias_and_relu_and_requantize with default options.
pub fn quantized_depthwise_conv2_dwith_bias_and_relu_and_requantize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize::new();
    quantized_depthwise_conv2_dwith_bias_and_relu_and_requantize_with_args(
        ctx,
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        &__args,
    )
}

/// quantized_depthwise_conv2_dwith_bias_and_relu_and_requantize with options.
pub fn quantized_depthwise_conv2_dwith_bias_and_relu_and_requantize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    bias: T2,
    min_input: T3,
    max_input: T4,
    min_filter: T5,
    max_filter: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
    __args: &QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op =
        crate::eager::Op::new(ctx, "QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;
    op.add_input(&min_filter.to_handle()?)?;
    op.add_input(&max_filter.to_handle()?)?;
    op.add_input(&min_freezed_output.to_handle()?)?;
    op.add_input(&max_freezed_output.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tfilter {
        op.set_attr_type("Tfilter", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tbias {
        op.set_attr_type("Tbias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_list {
        op.set_attr_int_list("padding_list", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedInstanceNorm
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedInstanceNorm {
    pub T: ::std::option::Option<crate::DataType>,
    pub output_range_given: ::std::option::Option<bool>,
    pub given_y_min: ::std::option::Option<f32>,
    pub given_y_max: ::std::option::Option<f32>,
    pub variance_epsilon: ::std::option::Option<f32>,
    pub min_separation: ::std::option::Option<f32>,
}

impl QuantizedInstanceNorm {
    /// Creates a new `QuantizedInstanceNorm`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_instance_norm with default options.
pub fn quantized_instance_norm<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    x_min: T1,
    x_max: T2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedInstanceNorm::new();
    quantized_instance_norm_with_args(ctx, x, x_min, x_max, &__args)
}

/// quantized_instance_norm with options.
pub fn quantized_instance_norm_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    x_min: T1,
    x_max: T2,
    __args: &QuantizedInstanceNorm,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedInstanceNorm")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&x_min.to_handle()?)?;
    op.add_input(&x_max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_range_given {
        op.set_attr_bool("output_range_given", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.given_y_min {
        op.set_attr_float("given_y_min", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.given_y_max {
        op.set_attr_float("given_y_max", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.variance_epsilon {
        op.set_attr_float("variance_epsilon", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.min_separation {
        op.set_attr_float("min_separation", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedMatMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMatMul {
    pub T1: ::std::option::Option<crate::DataType>,
    pub T2: ::std::option::Option<crate::DataType>,
    pub Toutput: ::std::option::Option<crate::DataType>,
    pub transpose_a: ::std::option::Option<bool>,
    pub transpose_b: ::std::option::Option<bool>,
    pub Tactivation: ::std::option::Option<crate::DataType>,
}

impl QuantizedMatMul {
    /// Creates a new `QuantizedMatMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_mat_mul with default options.
pub fn quantized_mat_mul<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    min_a: T2,
    max_a: T3,
    min_b: T4,
    max_b: T5,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedMatMul::new();
    quantized_mat_mul_with_args(ctx, a, b, min_a, max_a, min_b, max_b, &__args)
}

/// quantized_mat_mul with options.
pub fn quantized_mat_mul_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    min_a: T2,
    max_a: T3,
    min_b: T4,
    max_b: T5,
    __args: &QuantizedMatMul,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedMatMul")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;
    op.add_input(&min_a.to_handle()?)?;
    op.add_input(&max_a.to_handle()?)?;
    op.add_input(&min_b.to_handle()?)?;
    op.add_input(&max_b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T1 {
        op.set_attr_type("T1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T2 {
        op.set_attr_type("T2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Toutput {
        op.set_attr_type("Toutput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_a {
        op.set_attr_bool("transpose_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_b {
        op.set_attr_bool("transpose_b", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tactivation {
        op.set_attr_type("Tactivation", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedMatMulWithBias
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMatMulWithBias {
    pub T1: ::std::option::Option<crate::DataType>,
    pub T2: ::std::option::Option<crate::DataType>,
    pub Tbias: ::std::option::Option<crate::DataType>,
    pub Toutput: ::std::option::Option<crate::DataType>,
    pub transpose_a: ::std::option::Option<bool>,
    pub transpose_b: ::std::option::Option<bool>,
    pub input_quant_mode: ::std::option::Option<::std::string::String>,
}

impl QuantizedMatMulWithBias {
    /// Creates a new `QuantizedMatMulWithBias`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_mat_mul_with_bias with default options.
pub fn quantized_mat_mul_with_bias<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    bias: T2,
    min_a: T3,
    max_a: T4,
    min_b: T5,
    max_b: T6,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedMatMulWithBias::new();
    quantized_mat_mul_with_bias_with_args(ctx, a, b, bias, min_a, max_a, min_b, max_b, &__args)
}

/// quantized_mat_mul_with_bias with options.
pub fn quantized_mat_mul_with_bias_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    bias: T2,
    min_a: T3,
    max_a: T4,
    min_b: T5,
    max_b: T6,
    __args: &QuantizedMatMulWithBias,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedMatMulWithBias")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_a.to_handle()?)?;
    op.add_input(&max_a.to_handle()?)?;
    op.add_input(&min_b.to_handle()?)?;
    op.add_input(&max_b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T1 {
        op.set_attr_type("T1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T2 {
        op.set_attr_type("T2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tbias {
        op.set_attr_type("Tbias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Toutput {
        op.set_attr_type("Toutput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_a {
        op.set_attr_bool("transpose_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_b {
        op.set_attr_bool("transpose_b", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_quant_mode {
        op.set_attr_string("input_quant_mode", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedMatMulWithBiasAndDequantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMatMulWithBiasAndDequantize {
    pub T1: ::std::option::Option<crate::DataType>,
    pub T2: ::std::option::Option<crate::DataType>,
    pub Tbias: ::std::option::Option<crate::DataType>,
    pub Toutput: ::std::option::Option<crate::DataType>,
    pub transpose_a: ::std::option::Option<bool>,
    pub transpose_b: ::std::option::Option<bool>,
    pub input_quant_mode: ::std::option::Option<::std::string::String>,
}

impl QuantizedMatMulWithBiasAndDequantize {
    /// Creates a new `QuantizedMatMulWithBiasAndDequantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_mat_mul_with_bias_and_dequantize with default options.
pub fn quantized_mat_mul_with_bias_and_dequantize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    bias: T2,
    min_a: T3,
    max_a: T4,
    min_b: T5,
    max_b: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
) -> Result<crate::eager::TensorHandle> {
    let __args = QuantizedMatMulWithBiasAndDequantize::new();
    quantized_mat_mul_with_bias_and_dequantize_with_args(
        ctx,
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        min_freezed_output,
        max_freezed_output,
        &__args,
    )
}

/// quantized_mat_mul_with_bias_and_dequantize with options.
pub fn quantized_mat_mul_with_bias_and_dequantize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    bias: T2,
    min_a: T3,
    max_a: T4,
    min_b: T5,
    max_b: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
    __args: &QuantizedMatMulWithBiasAndDequantize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedMatMulWithBiasAndDequantize")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_a.to_handle()?)?;
    op.add_input(&max_a.to_handle()?)?;
    op.add_input(&min_b.to_handle()?)?;
    op.add_input(&max_b.to_handle()?)?;
    op.add_input(&min_freezed_output.to_handle()?)?;
    op.add_input(&max_freezed_output.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T1 {
        op.set_attr_type("T1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T2 {
        op.set_attr_type("T2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tbias {
        op.set_attr_type("Tbias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Toutput {
        op.set_attr_type("Toutput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_a {
        op.set_attr_bool("transpose_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_b {
        op.set_attr_bool("transpose_b", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_quant_mode {
        op.set_attr_string("input_quant_mode", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedMatMulWithBiasAndRelu
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMatMulWithBiasAndRelu {
    pub T1: ::std::option::Option<crate::DataType>,
    pub T2: ::std::option::Option<crate::DataType>,
    pub Toutput: ::std::option::Option<crate::DataType>,
    pub transpose_a: ::std::option::Option<bool>,
    pub transpose_b: ::std::option::Option<bool>,
    pub input_quant_mode: ::std::option::Option<::std::string::String>,
}

impl QuantizedMatMulWithBiasAndRelu {
    /// Creates a new `QuantizedMatMulWithBiasAndRelu`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_mat_mul_with_bias_and_relu with default options.
pub fn quantized_mat_mul_with_bias_and_relu<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    bias: T2,
    min_a: T3,
    max_a: T4,
    min_b: T5,
    max_b: T6,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedMatMulWithBiasAndRelu::new();
    quantized_mat_mul_with_bias_and_relu_with_args(
        ctx, a, b, bias, min_a, max_a, min_b, max_b, &__args,
    )
}

/// quantized_mat_mul_with_bias_and_relu with options.
pub fn quantized_mat_mul_with_bias_and_relu_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    bias: T2,
    min_a: T3,
    max_a: T4,
    min_b: T5,
    max_b: T6,
    __args: &QuantizedMatMulWithBiasAndRelu,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedMatMulWithBiasAndRelu")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_a.to_handle()?)?;
    op.add_input(&max_a.to_handle()?)?;
    op.add_input(&min_b.to_handle()?)?;
    op.add_input(&max_b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T1 {
        op.set_attr_type("T1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T2 {
        op.set_attr_type("T2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Toutput {
        op.set_attr_type("Toutput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_a {
        op.set_attr_bool("transpose_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_b {
        op.set_attr_bool("transpose_b", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_quant_mode {
        op.set_attr_string("input_quant_mode", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedMatMulWithBiasAndReluAndRequantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMatMulWithBiasAndReluAndRequantize {
    pub T1: ::std::option::Option<crate::DataType>,
    pub T2: ::std::option::Option<crate::DataType>,
    pub Tbias: ::std::option::Option<crate::DataType>,
    pub Toutput: ::std::option::Option<crate::DataType>,
    pub transpose_a: ::std::option::Option<bool>,
    pub transpose_b: ::std::option::Option<bool>,
    pub input_quant_mode: ::std::option::Option<::std::string::String>,
}

impl QuantizedMatMulWithBiasAndReluAndRequantize {
    /// Creates a new `QuantizedMatMulWithBiasAndReluAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_mat_mul_with_bias_and_relu_and_requantize with default options.
pub fn quantized_mat_mul_with_bias_and_relu_and_requantize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    bias: T2,
    min_a: T3,
    max_a: T4,
    min_b: T5,
    max_b: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedMatMulWithBiasAndReluAndRequantize::new();
    quantized_mat_mul_with_bias_and_relu_and_requantize_with_args(
        ctx,
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        min_freezed_output,
        max_freezed_output,
        &__args,
    )
}

/// quantized_mat_mul_with_bias_and_relu_and_requantize with options.
pub fn quantized_mat_mul_with_bias_and_relu_and_requantize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    bias: T2,
    min_a: T3,
    max_a: T4,
    min_b: T5,
    max_b: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
    __args: &QuantizedMatMulWithBiasAndReluAndRequantize,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedMatMulWithBiasAndReluAndRequantize")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_a.to_handle()?)?;
    op.add_input(&max_a.to_handle()?)?;
    op.add_input(&min_b.to_handle()?)?;
    op.add_input(&max_b.to_handle()?)?;
    op.add_input(&min_freezed_output.to_handle()?)?;
    op.add_input(&max_freezed_output.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T1 {
        op.set_attr_type("T1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T2 {
        op.set_attr_type("T2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tbias {
        op.set_attr_type("Tbias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Toutput {
        op.set_attr_type("Toutput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_a {
        op.set_attr_bool("transpose_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_b {
        op.set_attr_bool("transpose_b", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_quant_mode {
        op.set_attr_string("input_quant_mode", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedMatMulWithBiasAndRequantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMatMulWithBiasAndRequantize {
    pub T1: ::std::option::Option<crate::DataType>,
    pub T2: ::std::option::Option<crate::DataType>,
    pub Tbias: ::std::option::Option<crate::DataType>,
    pub Toutput: ::std::option::Option<crate::DataType>,
    pub transpose_a: ::std::option::Option<bool>,
    pub transpose_b: ::std::option::Option<bool>,
    pub input_quant_mode: ::std::option::Option<::std::string::String>,
}

impl QuantizedMatMulWithBiasAndRequantize {
    /// Creates a new `QuantizedMatMulWithBiasAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_mat_mul_with_bias_and_requantize with default options.
pub fn quantized_mat_mul_with_bias_and_requantize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    bias: T2,
    min_a: T3,
    max_a: T4,
    min_b: T5,
    max_b: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedMatMulWithBiasAndRequantize::new();
    quantized_mat_mul_with_bias_and_requantize_with_args(
        ctx,
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        min_freezed_output,
        max_freezed_output,
        &__args,
    )
}

/// quantized_mat_mul_with_bias_and_requantize with options.
pub fn quantized_mat_mul_with_bias_and_requantize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    bias: T2,
    min_a: T3,
    max_a: T4,
    min_b: T5,
    max_b: T6,
    min_freezed_output: T7,
    max_freezed_output: T8,
    __args: &QuantizedMatMulWithBiasAndRequantize,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedMatMulWithBiasAndRequantize")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;
    op.add_input(&bias.to_handle()?)?;
    op.add_input(&min_a.to_handle()?)?;
    op.add_input(&max_a.to_handle()?)?;
    op.add_input(&min_b.to_handle()?)?;
    op.add_input(&max_b.to_handle()?)?;
    op.add_input(&min_freezed_output.to_handle()?)?;
    op.add_input(&max_freezed_output.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T1 {
        op.set_attr_type("T1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T2 {
        op.set_attr_type("T2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tbias {
        op.set_attr_type("Tbias", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Toutput {
        op.set_attr_type("Toutput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_a {
        op.set_attr_bool("transpose_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_b {
        op.set_attr_bool("transpose_b", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_quant_mode {
        op.set_attr_string("input_quant_mode", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedMaxPool
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMaxPool {
    pub T: ::std::option::Option<crate::DataType>,
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub padding: ::std::option::Option<::std::string::String>,
}

impl QuantizedMaxPool {
    /// Creates a new `QuantizedMaxPool`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_max_pool with default options.
pub fn quantized_max_pool<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    min_input: T1,
    max_input: T2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedMaxPool::new();
    quantized_max_pool_with_args(ctx, input, min_input, max_input, &__args)
}

/// quantized_max_pool with options.
pub fn quantized_max_pool_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    min_input: T1,
    max_input: T2,
    __args: &QuantizedMaxPool,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedMaxPool")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&min_input.to_handle()?)?;
    op.add_input(&max_input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding {
        op.set_attr_string("padding", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMul {
    pub T1: ::std::option::Option<crate::DataType>,
    pub T2: ::std::option::Option<crate::DataType>,
    pub Toutput: ::std::option::Option<crate::DataType>,
}

impl QuantizedMul {
    /// Creates a new `QuantizedMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_mul with default options.
pub fn quantized_mul<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    min_x: T2,
    max_x: T3,
    min_y: T4,
    max_y: T5,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedMul::new();
    quantized_mul_with_args(ctx, x, y, min_x, max_x, min_y, max_y, &__args)
}

/// quantized_mul with options.
pub fn quantized_mul_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    min_x: T2,
    max_x: T3,
    min_y: T4,
    max_y: T5,
    __args: &QuantizedMul,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedMul")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;
    op.add_input(&min_x.to_handle()?)?;
    op.add_input(&max_x.to_handle()?)?;
    op.add_input(&min_y.to_handle()?)?;
    op.add_input(&max_y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T1 {
        op.set_attr_type("T1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T2 {
        op.set_attr_type("T2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Toutput {
        op.set_attr_type("Toutput", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedRelu
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedRelu {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl QuantizedRelu {
    /// Creates a new `QuantizedRelu`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_relu with default options.
pub fn quantized_relu<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    features: T0,
    min_features: T1,
    max_features: T2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedRelu::new();
    quantized_relu_with_args(ctx, features, min_features, max_features, &__args)
}

/// quantized_relu with options.
pub fn quantized_relu_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    features: T0,
    min_features: T1,
    max_features: T2,
    __args: &QuantizedRelu,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedRelu")?;

    // Required input arguments
    op.add_input(&features.to_handle()?)?;
    op.add_input(&min_features.to_handle()?)?;
    op.add_input(&max_features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedRelu6
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedRelu6 {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl QuantizedRelu6 {
    /// Creates a new `QuantizedRelu6`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_relu6 with default options.
pub fn quantized_relu6<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    features: T0,
    min_features: T1,
    max_features: T2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedRelu6::new();
    quantized_relu6_with_args(ctx, features, min_features, max_features, &__args)
}

/// quantized_relu6 with options.
pub fn quantized_relu6_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    features: T0,
    min_features: T1,
    max_features: T2,
    __args: &QuantizedRelu6,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedRelu6")?;

    // Required input arguments
    op.add_input(&features.to_handle()?)?;
    op.add_input(&min_features.to_handle()?)?;
    op.add_input(&max_features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedReluX
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedReluX {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl QuantizedReluX {
    /// Creates a new `QuantizedReluX`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_relu_x with default options.
pub fn quantized_relu_x<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    features: T0,
    max_value: T1,
    min_features: T2,
    max_features: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedReluX::new();
    quantized_relu_x_with_args(
        ctx,
        features,
        max_value,
        min_features,
        max_features,
        &__args,
    )
}

/// quantized_relu_x with options.
pub fn quantized_relu_x_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    features: T0,
    max_value: T1,
    min_features: T2,
    max_features: T3,
    __args: &QuantizedReluX,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedReluX")?;

    // Required input arguments
    op.add_input(&features.to_handle()?)?;
    op.add_input(&max_value.to_handle()?)?;
    op.add_input(&min_features.to_handle()?)?;
    op.add_input(&max_features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedReshape
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedReshape {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tshape: ::std::option::Option<crate::DataType>,
}

impl QuantizedReshape {
    /// Creates a new `QuantizedReshape`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_reshape with default options.
pub fn quantized_reshape<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    shape: T1,
    input_min: T2,
    input_max: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedReshape::new();
    quantized_reshape_with_args(ctx, tensor, shape, input_min, input_max, &__args)
}

/// quantized_reshape with options.
pub fn quantized_reshape_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    shape: T1,
    input_min: T2,
    input_max: T3,
    __args: &QuantizedReshape,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedReshape")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&input_min.to_handle()?)?;
    op.add_input(&input_max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshape {
        op.set_attr_type("Tshape", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QuantizedResizeBilinear
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedResizeBilinear {
    pub T: ::std::option::Option<crate::DataType>,
    pub align_corners: ::std::option::Option<bool>,
    pub half_pixel_centers: ::std::option::Option<bool>,
}

impl QuantizedResizeBilinear {
    /// Creates a new `QuantizedResizeBilinear`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// quantized_resize_bilinear with default options.
pub fn quantized_resize_bilinear<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    size: T1,
    min: T2,
    max: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = QuantizedResizeBilinear::new();
    quantized_resize_bilinear_with_args(ctx, images, size, min, max, &__args)
}

/// quantized_resize_bilinear with options.
pub fn quantized_resize_bilinear_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    size: T1,
    min: T2,
    max: T3,
    __args: &QuantizedResizeBilinear,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QuantizedResizeBilinear")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;
    op.add_input(&min.to_handle()?)?;
    op.add_input(&max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.align_corners {
        op.set_attr_bool("align_corners", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.half_pixel_centers {
        op.set_attr_bool("half_pixel_centers", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// QueueClose
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueClose {
    pub cancel_pending_enqueues: ::std::option::Option<bool>,
}

impl QueueClose {
    /// Creates a new `QueueClose`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_close with default options.
pub fn queue_close<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<()> {
    let __args = QueueClose::new();
    queue_close_with_args(ctx, handle, &__args)
}

/// queue_close with options.
pub fn queue_close_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &QueueClose,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueClose")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.cancel_pending_enqueues {
        op.set_attr_bool("cancel_pending_enqueues", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// QueueCloseV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueCloseV2 {
    pub cancel_pending_enqueues: ::std::option::Option<bool>,
}

impl QueueCloseV2 {
    /// Creates a new `QueueCloseV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_close_v2 with default options.
pub fn queue_close_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<()> {
    let __args = QueueCloseV2::new();
    queue_close_v2_with_args(ctx, handle, &__args)
}

/// queue_close_v2 with options.
pub fn queue_close_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &QueueCloseV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueCloseV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.cancel_pending_enqueues {
        op.set_attr_bool("cancel_pending_enqueues", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// QueueDequeue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueDequeue {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub timeout_ms: ::std::option::Option<i64>,
}

impl QueueDequeue {
    /// Creates a new `QueueDequeue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_dequeue with default options.
pub fn queue_dequeue<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = QueueDequeue::new();
    queue_dequeue_with_args(ctx, handle, &__args)
}

/// queue_dequeue with options.
pub fn queue_dequeue_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &QueueDequeue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueDequeue")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_ms {
        op.set_attr_int("timeout_ms", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QueueDequeueMany
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueDequeueMany {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub timeout_ms: ::std::option::Option<i64>,
}

impl QueueDequeueMany {
    /// Creates a new `QueueDequeueMany`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_dequeue_many with default options.
pub fn queue_dequeue_many<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    n: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = QueueDequeueMany::new();
    queue_dequeue_many_with_args(ctx, handle, n, &__args)
}

/// queue_dequeue_many with options.
pub fn queue_dequeue_many_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    n: T1,
    __args: &QueueDequeueMany,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueDequeueMany")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&n.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_ms {
        op.set_attr_int("timeout_ms", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QueueDequeueManyV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueDequeueManyV2 {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub timeout_ms: ::std::option::Option<i64>,
}

impl QueueDequeueManyV2 {
    /// Creates a new `QueueDequeueManyV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_dequeue_many_v2 with default options.
pub fn queue_dequeue_many_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    n: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = QueueDequeueManyV2::new();
    queue_dequeue_many_v2_with_args(ctx, handle, n, &__args)
}

/// queue_dequeue_many_v2 with options.
pub fn queue_dequeue_many_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    n: T1,
    __args: &QueueDequeueManyV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueDequeueManyV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&n.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_ms {
        op.set_attr_int("timeout_ms", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QueueDequeueUpTo
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueDequeueUpTo {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub timeout_ms: ::std::option::Option<i64>,
}

impl QueueDequeueUpTo {
    /// Creates a new `QueueDequeueUpTo`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_dequeue_up_to with default options.
pub fn queue_dequeue_up_to<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    n: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = QueueDequeueUpTo::new();
    queue_dequeue_up_to_with_args(ctx, handle, n, &__args)
}

/// queue_dequeue_up_to with options.
pub fn queue_dequeue_up_to_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    n: T1,
    __args: &QueueDequeueUpTo,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueDequeueUpTo")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&n.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_ms {
        op.set_attr_int("timeout_ms", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QueueDequeueUpToV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueDequeueUpToV2 {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub timeout_ms: ::std::option::Option<i64>,
}

impl QueueDequeueUpToV2 {
    /// Creates a new `QueueDequeueUpToV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_dequeue_up_to_v2 with default options.
pub fn queue_dequeue_up_to_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    n: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = QueueDequeueUpToV2::new();
    queue_dequeue_up_to_v2_with_args(ctx, handle, n, &__args)
}

/// queue_dequeue_up_to_v2 with options.
pub fn queue_dequeue_up_to_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    n: T1,
    __args: &QueueDequeueUpToV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueDequeueUpToV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&n.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_ms {
        op.set_attr_int("timeout_ms", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QueueDequeueV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueDequeueV2 {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub timeout_ms: ::std::option::Option<i64>,
}

impl QueueDequeueV2 {
    /// Creates a new `QueueDequeueV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_dequeue_v2 with default options.
pub fn queue_dequeue_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = QueueDequeueV2::new();
    queue_dequeue_v2_with_args(ctx, handle, &__args)
}

/// queue_dequeue_v2 with options.
pub fn queue_dequeue_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &QueueDequeueV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueDequeueV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_ms {
        op.set_attr_int("timeout_ms", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QueueEnqueue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueEnqueue {
    pub Tcomponents: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub timeout_ms: ::std::option::Option<i64>,
}

impl QueueEnqueue {
    /// Creates a new `QueueEnqueue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_enqueue with default options.
pub fn queue_enqueue<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    components: T1,
) -> Result<()> {
    let __args = QueueEnqueue::new();
    queue_enqueue_with_args(ctx, handle, components, &__args)
}

/// queue_enqueue with options.
pub fn queue_enqueue_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    components: T1,
    __args: &QueueEnqueue,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueEnqueue")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&components.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcomponents {
        op.set_attr_type_list("Tcomponents", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_ms {
        op.set_attr_int("timeout_ms", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// QueueEnqueueMany
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueEnqueueMany {
    pub Tcomponents: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub timeout_ms: ::std::option::Option<i64>,
}

impl QueueEnqueueMany {
    /// Creates a new `QueueEnqueueMany`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_enqueue_many with default options.
pub fn queue_enqueue_many<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    components: T1,
) -> Result<()> {
    let __args = QueueEnqueueMany::new();
    queue_enqueue_many_with_args(ctx, handle, components, &__args)
}

/// queue_enqueue_many with options.
pub fn queue_enqueue_many_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    components: T1,
    __args: &QueueEnqueueMany,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueEnqueueMany")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&components.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcomponents {
        op.set_attr_type_list("Tcomponents", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_ms {
        op.set_attr_int("timeout_ms", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// QueueEnqueueManyV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueEnqueueManyV2 {
    pub Tcomponents: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub timeout_ms: ::std::option::Option<i64>,
}

impl QueueEnqueueManyV2 {
    /// Creates a new `QueueEnqueueManyV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_enqueue_many_v2 with default options.
pub fn queue_enqueue_many_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    components: T1,
) -> Result<()> {
    let __args = QueueEnqueueManyV2::new();
    queue_enqueue_many_v2_with_args(ctx, handle, components, &__args)
}

/// queue_enqueue_many_v2 with options.
pub fn queue_enqueue_many_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    components: T1,
    __args: &QueueEnqueueManyV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueEnqueueManyV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&components.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcomponents {
        op.set_attr_type_list("Tcomponents", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_ms {
        op.set_attr_int("timeout_ms", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// QueueEnqueueV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueEnqueueV2 {
    pub Tcomponents: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub timeout_ms: ::std::option::Option<i64>,
}

impl QueueEnqueueV2 {
    /// Creates a new `QueueEnqueueV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_enqueue_v2 with default options.
pub fn queue_enqueue_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    components: T1,
) -> Result<()> {
    let __args = QueueEnqueueV2::new();
    queue_enqueue_v2_with_args(ctx, handle, components, &__args)
}

/// queue_enqueue_v2 with options.
pub fn queue_enqueue_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    components: T1,
    __args: &QueueEnqueueV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueEnqueueV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&components.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcomponents {
        op.set_attr_type_list("Tcomponents", value);
    }
    if let ::std::option::Option::Some(value) = &__args.timeout_ms {
        op.set_attr_int("timeout_ms", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// QueueIsClosed
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueIsClosed {}

impl QueueIsClosed {
    /// Creates a new `QueueIsClosed`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_is_closed with default options.
pub fn queue_is_closed<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = QueueIsClosed::new();
    queue_is_closed_with_args(ctx, handle, &__args)
}

/// queue_is_closed with options.
pub fn queue_is_closed_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &QueueIsClosed,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueIsClosed")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QueueIsClosedV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueIsClosedV2 {}

impl QueueIsClosedV2 {
    /// Creates a new `QueueIsClosedV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_is_closed_v2 with default options.
pub fn queue_is_closed_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = QueueIsClosedV2::new();
    queue_is_closed_v2_with_args(ctx, handle, &__args)
}

/// queue_is_closed_v2 with options.
pub fn queue_is_closed_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &QueueIsClosedV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueIsClosedV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QueueSize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueSize {}

impl QueueSize {
    /// Creates a new `QueueSize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_size with default options.
pub fn queue_size<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = QueueSize::new();
    queue_size_with_args(ctx, handle, &__args)
}

/// queue_size with options.
pub fn queue_size_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &QueueSize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueSize")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// QueueSizeV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueSizeV2 {}

impl QueueSizeV2 {
    /// Creates a new `QueueSizeV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// queue_size_v2 with default options.
pub fn queue_size_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = QueueSizeV2::new();
    queue_size_v2_with_args(ctx, handle, &__args)
}

/// queue_size_v2 with options.
pub fn queue_size_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &QueueSizeV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "QueueSizeV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RFFT
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RFFT {
    pub Treal: ::std::option::Option<crate::DataType>,
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl RFFT {
    /// Creates a new `RFFT`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// rfft with default options.
pub fn rfft<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    fft_length: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RFFT::new();
    rfft_with_args(ctx, input, fft_length, &__args)
}

/// rfft with options.
pub fn rfft_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    fft_length: T1,
    __args: &RFFT,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RFFT")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&fft_length.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Treal {
        op.set_attr_type("Treal", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RFFT2D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RFFT2D {
    pub Treal: ::std::option::Option<crate::DataType>,
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl RFFT2D {
    /// Creates a new `RFFT2D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// rfft2_d with default options.
pub fn rfft2_d<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    fft_length: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RFFT2D::new();
    rfft2_d_with_args(ctx, input, fft_length, &__args)
}

/// rfft2_d with options.
pub fn rfft2_d_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    fft_length: T1,
    __args: &RFFT2D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RFFT2D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&fft_length.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Treal {
        op.set_attr_type("Treal", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RFFT3D
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RFFT3D {
    pub Treal: ::std::option::Option<crate::DataType>,
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl RFFT3D {
    /// Creates a new `RFFT3D`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// rfft3_d with default options.
pub fn rfft3_d<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    fft_length: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RFFT3D::new();
    rfft3_d_with_args(ctx, input, fft_length, &__args)
}

/// rfft3_d with options.
pub fn rfft3_d_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    fft_length: T1,
    __args: &RFFT3D,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RFFT3D")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&fft_length.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Treal {
        op.set_attr_type("Treal", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RGBToHSV
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RGBToHSV {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RGBToHSV {
    /// Creates a new `RGBToHSV`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// rgbto_hsv with default options.
pub fn rgbto_hsv<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RGBToHSV::new();
    rgbto_hsv_with_args(ctx, images, &__args)
}

/// rgbto_hsv with options.
pub fn rgbto_hsv_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    __args: &RGBToHSV,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RGBToHSV")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RaggedBincount
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedBincount {
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub binary_output: ::std::option::Option<bool>,
}

impl RaggedBincount {
    /// Creates a new `RaggedBincount`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ragged_bincount with default options.
pub fn ragged_bincount<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    splits: T0,
    values: T1,
    size: T2,
    weights: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = RaggedBincount::new();
    ragged_bincount_with_args(ctx, splits, values, size, weights, &__args)
}

/// ragged_bincount with options.
pub fn ragged_bincount_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    splits: T0,
    values: T1,
    size: T2,
    weights: T3,
    __args: &RaggedBincount,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RaggedBincount")?;

    // Required input arguments
    op.add_input(&splits.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;
    op.add_input(&weights.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.binary_output {
        op.set_attr_bool("binary_output", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RaggedCountSparseOutput
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedCountSparseOutput {
    pub T: ::std::option::Option<crate::DataType>,
    pub minlength: ::std::option::Option<i64>,
    pub maxlength: ::std::option::Option<i64>,
    pub binary_output: ::std::option::Option<bool>,
    pub output_type: ::std::option::Option<crate::DataType>,
}

impl RaggedCountSparseOutput {
    /// Creates a new `RaggedCountSparseOutput`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ragged_count_sparse_output with default options.
pub fn ragged_count_sparse_output<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    splits: T0,
    values: T1,
    weights: T2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = RaggedCountSparseOutput::new();
    ragged_count_sparse_output_with_args(ctx, splits, values, weights, &__args)
}

/// ragged_count_sparse_output with options.
pub fn ragged_count_sparse_output_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    splits: T0,
    values: T1,
    weights: T2,
    __args: &RaggedCountSparseOutput,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RaggedCountSparseOutput")?;

    // Required input arguments
    op.add_input(&splits.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&weights.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.minlength {
        op.set_attr_int("minlength", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.maxlength {
        op.set_attr_int("maxlength", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.binary_output {
        op.set_attr_bool("binary_output", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_type {
        op.set_attr_type("output_type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RaggedCross
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedCross {
    pub Nsparse: ::std::option::Option<i64>,
    pub input_order: ::std::option::Option<::std::string::String>,
    pub hashed_output: ::std::option::Option<bool>,
    pub num_buckets: ::std::option::Option<i64>,
    pub hash_key: ::std::option::Option<i64>,
    pub ragged_values_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub ragged_splits_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub sparse_values_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub out_values_type: ::std::option::Option<crate::DataType>,
    pub out_row_splits_type: ::std::option::Option<crate::DataType>,
}

impl RaggedCross {
    /// Creates a new `RaggedCross`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ragged_cross with default options.
pub fn ragged_cross<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ragged_values: T0,
    ragged_row_splits: T1,
    sparse_indices: T2,
    sparse_values: T3,
    sparse_shape: T4,
    dense_inputs: T5,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RaggedCross::new();
    ragged_cross_with_args(
        ctx,
        ragged_values,
        ragged_row_splits,
        sparse_indices,
        sparse_values,
        sparse_shape,
        dense_inputs,
        &__args,
    )
}

/// ragged_cross with options.
pub fn ragged_cross_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ragged_values: T0,
    ragged_row_splits: T1,
    sparse_indices: T2,
    sparse_values: T3,
    sparse_shape: T4,
    dense_inputs: T5,
    __args: &RaggedCross,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RaggedCross")?;

    // Required input arguments
    op.add_input(&ragged_values.to_handle()?)?;
    op.add_input(&ragged_row_splits.to_handle()?)?;
    op.add_input(&sparse_indices.to_handle()?)?;
    op.add_input(&sparse_values.to_handle()?)?;
    op.add_input(&sparse_shape.to_handle()?)?;
    op.add_input(&dense_inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Nsparse {
        op.set_attr_int("Nsparse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.input_order {
        op.set_attr_string("input_order", value);
    }
    if let ::std::option::Option::Some(value) = &__args.hashed_output {
        op.set_attr_bool("hashed_output", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_buckets {
        op.set_attr_int("num_buckets", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.hash_key {
        op.set_attr_int("hash_key", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ragged_values_types {
        op.set_attr_type_list("ragged_values_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.ragged_splits_types {
        op.set_attr_type_list("ragged_splits_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.sparse_values_types {
        op.set_attr_type_list("sparse_values_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_types {
        op.set_attr_type_list("dense_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_values_type {
        op.set_attr_type("out_values_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_row_splits_type {
        op.set_attr_type("out_row_splits_type", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RaggedGather
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedGather {
    pub Tvalues: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub Tsplits: ::std::option::Option<crate::DataType>,
    pub PARAMS_RAGGED_RANK: ::std::option::Option<i64>,
    pub OUTPUT_RAGGED_RANK: ::std::option::Option<i64>,
}

impl RaggedGather {
    /// Creates a new `RaggedGather`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ragged_gather with default options.
pub fn ragged_gather<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    params_nested_splits: T0,
    params_dense_values: T1,
    indices: T2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RaggedGather::new();
    ragged_gather_with_args(
        ctx,
        params_nested_splits,
        params_dense_values,
        indices,
        &__args,
    )
}

/// ragged_gather with options.
pub fn ragged_gather_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    params_nested_splits: T0,
    params_dense_values: T1,
    indices: T2,
    __args: &RaggedGather,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RaggedGather")?;

    // Required input arguments
    op.add_input(&params_nested_splits.to_handle()?)?;
    op.add_input(&params_dense_values.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tvalues {
        op.set_attr_type("Tvalues", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsplits {
        op.set_attr_type("Tsplits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.PARAMS_RAGGED_RANK {
        op.set_attr_int("PARAMS_RAGGED_RANK", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.OUTPUT_RAGGED_RANK {
        op.set_attr_int("OUTPUT_RAGGED_RANK", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RaggedRange
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedRange {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tsplits: ::std::option::Option<crate::DataType>,
}

impl RaggedRange {
    /// Creates a new `RaggedRange`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ragged_range with default options.
pub fn ragged_range<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    starts: T0,
    limits: T1,
    deltas: T2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RaggedRange::new();
    ragged_range_with_args(ctx, starts, limits, deltas, &__args)
}

/// ragged_range with options.
pub fn ragged_range_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    starts: T0,
    limits: T1,
    deltas: T2,
    __args: &RaggedRange,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RaggedRange")?;

    // Required input arguments
    op.add_input(&starts.to_handle()?)?;
    op.add_input(&limits.to_handle()?)?;
    op.add_input(&deltas.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsplits {
        op.set_attr_type("Tsplits", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RaggedTensorFromVariant
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedTensorFromVariant {
    pub input_ragged_rank: ::std::option::Option<i64>,
    pub output_ragged_rank: ::std::option::Option<i64>,
    pub Tvalues: ::std::option::Option<crate::DataType>,
    pub Tsplits: ::std::option::Option<crate::DataType>,
}

impl RaggedTensorFromVariant {
    /// Creates a new `RaggedTensorFromVariant`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ragged_tensor_from_variant with default options.
pub fn ragged_tensor_from_variant<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    encoded_ragged: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RaggedTensorFromVariant::new();
    ragged_tensor_from_variant_with_args(ctx, encoded_ragged, &__args)
}

/// ragged_tensor_from_variant with options.
pub fn ragged_tensor_from_variant_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    encoded_ragged: T0,
    __args: &RaggedTensorFromVariant,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RaggedTensorFromVariant")?;

    // Required input arguments
    op.add_input(&encoded_ragged.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.input_ragged_rank {
        op.set_attr_int("input_ragged_rank", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_ragged_rank {
        op.set_attr_int("output_ragged_rank", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tvalues {
        op.set_attr_type("Tvalues", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsplits {
        op.set_attr_type("Tsplits", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RaggedTensorToSparse
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedTensorToSparse {
    pub RAGGED_RANK: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tsplits: ::std::option::Option<crate::DataType>,
}

impl RaggedTensorToSparse {
    /// Creates a new `RaggedTensorToSparse`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ragged_tensor_to_sparse with default options.
pub fn ragged_tensor_to_sparse<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    rt_nested_splits: T0,
    rt_dense_values: T1,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = RaggedTensorToSparse::new();
    ragged_tensor_to_sparse_with_args(ctx, rt_nested_splits, rt_dense_values, &__args)
}

/// ragged_tensor_to_sparse with options.
pub fn ragged_tensor_to_sparse_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    rt_nested_splits: T0,
    rt_dense_values: T1,
    __args: &RaggedTensorToSparse,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RaggedTensorToSparse")?;

    // Required input arguments
    op.add_input(&rt_nested_splits.to_handle()?)?;
    op.add_input(&rt_dense_values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.RAGGED_RANK {
        op.set_attr_int("RAGGED_RANK", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsplits {
        op.set_attr_type("Tsplits", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RaggedTensorToTensor
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedTensorToTensor {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindex: ::std::option::Option<crate::DataType>,
    pub Tshape: ::std::option::Option<crate::DataType>,
    pub num_row_partition_tensors: ::std::option::Option<i64>,
    pub row_partition_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}

impl RaggedTensorToTensor {
    /// Creates a new `RaggedTensorToTensor`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ragged_tensor_to_tensor with default options.
pub fn ragged_tensor_to_tensor<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    values: T1,
    default_value: T2,
    row_partition_tensors: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = RaggedTensorToTensor::new();
    ragged_tensor_to_tensor_with_args(
        ctx,
        shape,
        values,
        default_value,
        row_partition_tensors,
        &__args,
    )
}

/// ragged_tensor_to_tensor with options.
pub fn ragged_tensor_to_tensor_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    values: T1,
    default_value: T2,
    row_partition_tensors: T3,
    __args: &RaggedTensorToTensor,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RaggedTensorToTensor")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&default_value.to_handle()?)?;
    op.add_input(&row_partition_tensors.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindex {
        op.set_attr_type("Tindex", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshape {
        op.set_attr_type("Tshape", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_row_partition_tensors {
        op.set_attr_int("num_row_partition_tensors", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.row_partition_types {
        op.set_attr_string_list("row_partition_types", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RaggedTensorToVariant
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedTensorToVariant {
    pub RAGGED_RANK: ::std::option::Option<i64>,
    pub Tvalues: ::std::option::Option<crate::DataType>,
    pub Tsplits: ::std::option::Option<crate::DataType>,
    pub batched_input: ::std::option::Option<bool>,
}

impl RaggedTensorToVariant {
    /// Creates a new `RaggedTensorToVariant`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ragged_tensor_to_variant with default options.
pub fn ragged_tensor_to_variant<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    rt_nested_splits: T0,
    rt_dense_values: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RaggedTensorToVariant::new();
    ragged_tensor_to_variant_with_args(ctx, rt_nested_splits, rt_dense_values, &__args)
}

/// ragged_tensor_to_variant with options.
pub fn ragged_tensor_to_variant_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    rt_nested_splits: T0,
    rt_dense_values: T1,
    __args: &RaggedTensorToVariant,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RaggedTensorToVariant")?;

    // Required input arguments
    op.add_input(&rt_nested_splits.to_handle()?)?;
    op.add_input(&rt_dense_values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.RAGGED_RANK {
        op.set_attr_int("RAGGED_RANK", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tvalues {
        op.set_attr_type("Tvalues", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsplits {
        op.set_attr_type("Tsplits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.batched_input {
        op.set_attr_bool("batched_input", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RaggedTensorToVariantGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedTensorToVariantGradient {
    pub Tvalues: ::std::option::Option<crate::DataType>,
    pub Tsplits: ::std::option::Option<crate::DataType>,
}

impl RaggedTensorToVariantGradient {
    /// Creates a new `RaggedTensorToVariantGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ragged_tensor_to_variant_gradient with default options.
pub fn ragged_tensor_to_variant_gradient<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    encoded_ragged_grad: T0,
    row_splits: T1,
    dense_values_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RaggedTensorToVariantGradient::new();
    ragged_tensor_to_variant_gradient_with_args(
        ctx,
        encoded_ragged_grad,
        row_splits,
        dense_values_shape,
        &__args,
    )
}

/// ragged_tensor_to_variant_gradient with options.
pub fn ragged_tensor_to_variant_gradient_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    encoded_ragged_grad: T0,
    row_splits: T1,
    dense_values_shape: T2,
    __args: &RaggedTensorToVariantGradient,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RaggedTensorToVariantGradient")?;

    // Required input arguments
    op.add_input(&encoded_ragged_grad.to_handle()?)?;
    op.add_input(&row_splits.to_handle()?)?;
    op.add_input(&dense_values_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tvalues {
        op.set_attr_type("Tvalues", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsplits {
        op.set_attr_type("Tsplits", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RandomCrop
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomCrop {
    pub T: ::std::option::Option<crate::DataType>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
}

impl RandomCrop {
    /// Creates a new `RandomCrop`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// random_crop with default options.
pub fn random_crop<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    image: T0,
    size: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RandomCrop::new();
    random_crop_with_args(ctx, image, size, &__args)
}

/// random_crop with options.
pub fn random_crop_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    image: T0,
    size: T1,
    __args: &RandomCrop,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RandomCrop")?;

    // Required input arguments
    op.add_input(&image.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RandomDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl RandomDataset {
    /// Creates a new `RandomDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// random_dataset with default options.
pub fn random_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    seed: T0,
    seed2: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RandomDataset::new();
    random_dataset_with_args(ctx, seed, seed2, &__args)
}

/// random_dataset with options.
pub fn random_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    seed: T0,
    seed2: T1,
    __args: &RandomDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RandomDataset")?;

    // Required input arguments
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&seed2.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RandomGamma
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomGamma {
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub S: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RandomGamma {
    /// Creates a new `RandomGamma`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// random_gamma with default options.
pub fn random_gamma<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    alpha: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RandomGamma::new();
    random_gamma_with_args(ctx, shape, alpha, &__args)
}

/// random_gamma with options.
pub fn random_gamma_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    alpha: T1,
    __args: &RandomGamma,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RandomGamma")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&alpha.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.S {
        op.set_attr_type("S", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RandomGammaGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomGammaGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RandomGammaGrad {
    /// Creates a new `RandomGammaGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// random_gamma_grad with default options.
pub fn random_gamma_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    alpha: T0,
    sample: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RandomGammaGrad::new();
    random_gamma_grad_with_args(ctx, alpha, sample, &__args)
}

/// random_gamma_grad with options.
pub fn random_gamma_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    alpha: T0,
    sample: T1,
    __args: &RandomGammaGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RandomGammaGrad")?;

    // Required input arguments
    op.add_input(&alpha.to_handle()?)?;
    op.add_input(&sample.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RandomPoisson
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomPoisson {
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub S: ::std::option::Option<crate::DataType>,
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl RandomPoisson {
    /// Creates a new `RandomPoisson`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// random_poisson with default options.
pub fn random_poisson<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    rate: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RandomPoisson::new();
    random_poisson_with_args(ctx, shape, rate, &__args)
}

/// random_poisson with options.
pub fn random_poisson_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    rate: T1,
    __args: &RandomPoisson,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RandomPoisson")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&rate.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.S {
        op.set_attr_type("S", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RandomPoissonV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomPoissonV2 {
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub S: ::std::option::Option<crate::DataType>,
    pub R: ::std::option::Option<crate::DataType>,
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl RandomPoissonV2 {
    /// Creates a new `RandomPoissonV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// random_poisson_v2 with default options.
pub fn random_poisson_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    rate: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RandomPoissonV2::new();
    random_poisson_v2_with_args(ctx, shape, rate, &__args)
}

/// random_poisson_v2 with options.
pub fn random_poisson_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    rate: T1,
    __args: &RandomPoissonV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RandomPoissonV2")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&rate.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.S {
        op.set_attr_type("S", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.R {
        op.set_attr_type("R", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RandomShuffle
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomShuffle {
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RandomShuffle {
    /// Creates a new `RandomShuffle`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// random_shuffle with default options.
pub fn random_shuffle<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RandomShuffle::new();
    random_shuffle_with_args(ctx, value, &__args)
}

/// random_shuffle with options.
pub fn random_shuffle_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
    __args: &RandomShuffle,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RandomShuffle")?;

    // Required input arguments
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RandomShuffleQueue
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomShuffleQueue {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub capacity: ::std::option::Option<i64>,
    pub min_after_dequeue: ::std::option::Option<i64>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl RandomShuffleQueue {
    /// Creates a new `RandomShuffleQueue`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// random_shuffle_queue with default options.
pub fn random_shuffle_queue(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = RandomShuffleQueue::new();
    random_shuffle_queue_with_args(ctx, &__args)
}

/// random_shuffle_queue with options.
pub fn random_shuffle_queue_with_args(
    ctx: &crate::eager::Context,
    __args: &RandomShuffleQueue,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RandomShuffleQueue")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.min_after_dequeue {
        op.set_attr_int("min_after_dequeue", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RandomShuffleQueueV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomShuffleQueueV2 {
    pub component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub capacity: ::std::option::Option<i64>,
    pub min_after_dequeue: ::std::option::Option<i64>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl RandomShuffleQueueV2 {
    /// Creates a new `RandomShuffleQueueV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// random_shuffle_queue_v2 with default options.
pub fn random_shuffle_queue_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = RandomShuffleQueueV2::new();
    random_shuffle_queue_v2_with_args(ctx, &__args)
}

/// random_shuffle_queue_v2 with options.
pub fn random_shuffle_queue_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &RandomShuffleQueueV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RandomShuffleQueueV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.component_types {
        op.set_attr_type_list("component_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.min_after_dequeue {
        op.set_attr_int("min_after_dequeue", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RandomStandardNormal
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomStandardNormal {
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub dtype: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RandomStandardNormal {
    /// Creates a new `RandomStandardNormal`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// random_standard_normal with default options.
pub fn random_standard_normal<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RandomStandardNormal::new();
    random_standard_normal_with_args(ctx, shape, &__args)
}

/// random_standard_normal with options.
pub fn random_standard_normal_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    __args: &RandomStandardNormal,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RandomStandardNormal")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RandomUniform
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomUniform {
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub dtype: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RandomUniform {
    /// Creates a new `RandomUniform`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// random_uniform with default options.
pub fn random_uniform<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RandomUniform::new();
    random_uniform_with_args(ctx, shape, &__args)
}

/// random_uniform with options.
pub fn random_uniform_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    __args: &RandomUniform,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RandomUniform")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RandomUniformInt
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomUniformInt {
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub Tout: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RandomUniformInt {
    /// Creates a new `RandomUniformInt`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// random_uniform_int with default options.
pub fn random_uniform_int<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    minval: T1,
    maxval: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RandomUniformInt::new();
    random_uniform_int_with_args(ctx, shape, minval, maxval, &__args)
}

/// random_uniform_int with options.
pub fn random_uniform_int_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    minval: T1,
    maxval: T2,
    __args: &RandomUniformInt,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RandomUniformInt")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&minval.to_handle()?)?;
    op.add_input(&maxval.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Range
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Range {
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl Range {
    /// Creates a new `Range`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// range with default options.
pub fn range<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle, T2: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    start: T0,
    limit: T1,
    delta: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Range::new();
    range_with_args(ctx, start, limit, delta, &__args)
}

/// range with options.
pub fn range_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    start: T0,
    limit: T1,
    delta: T2,
    __args: &Range,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Range")?;

    // Required input arguments
    op.add_input(&start.to_handle()?)?;
    op.add_input(&limit.to_handle()?)?;
    op.add_input(&delta.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RangeDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RangeDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl RangeDataset {
    /// Creates a new `RangeDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// range_dataset with default options.
pub fn range_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    start: T0,
    stop: T1,
    step: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RangeDataset::new();
    range_dataset_with_args(ctx, start, stop, step, &__args)
}

/// range_dataset with options.
pub fn range_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    start: T0,
    stop: T1,
    step: T2,
    __args: &RangeDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RangeDataset")?;

    // Required input arguments
    op.add_input(&start.to_handle()?)?;
    op.add_input(&stop.to_handle()?)?;
    op.add_input(&step.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Rank
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Rank {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Rank {
    /// Creates a new `Rank`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// rank with default options.
pub fn rank<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Rank::new();
    rank_with_args(ctx, input, &__args)
}

/// rank with options.
pub fn rank_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Rank,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Rank")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReadFile
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReadFile {}

impl ReadFile {
    /// Creates a new `ReadFile`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// read_file with default options.
pub fn read_file<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    filename: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReadFile::new();
    read_file_with_args(ctx, filename, &__args)
}

/// read_file with options.
pub fn read_file_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    filename: T0,
    __args: &ReadFile,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReadFile")?;

    // Required input arguments
    op.add_input(&filename.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReadVariableOp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReadVariableOp {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl ReadVariableOp {
    /// Creates a new `ReadVariableOp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// read_variable_op with default options.
pub fn read_variable_op<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReadVariableOp::new();
    read_variable_op_with_args(ctx, resource, &__args)
}

/// read_variable_op with options.
pub fn read_variable_op_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    __args: &ReadVariableOp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReadVariableOp")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReaderNumRecordsProduced
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderNumRecordsProduced {}

impl ReaderNumRecordsProduced {
    /// Creates a new `ReaderNumRecordsProduced`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_num_records_produced with default options.
pub fn reader_num_records_produced<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReaderNumRecordsProduced::new();
    reader_num_records_produced_with_args(ctx, reader_handle, &__args)
}

/// reader_num_records_produced with options.
pub fn reader_num_records_produced_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    __args: &ReaderNumRecordsProduced,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderNumRecordsProduced")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReaderNumRecordsProducedV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderNumRecordsProducedV2 {}

impl ReaderNumRecordsProducedV2 {
    /// Creates a new `ReaderNumRecordsProducedV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_num_records_produced_v2 with default options.
pub fn reader_num_records_produced_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReaderNumRecordsProducedV2::new();
    reader_num_records_produced_v2_with_args(ctx, reader_handle, &__args)
}

/// reader_num_records_produced_v2 with options.
pub fn reader_num_records_produced_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    __args: &ReaderNumRecordsProducedV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderNumRecordsProducedV2")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReaderNumWorkUnitsCompleted
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderNumWorkUnitsCompleted {}

impl ReaderNumWorkUnitsCompleted {
    /// Creates a new `ReaderNumWorkUnitsCompleted`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_num_work_units_completed with default options.
pub fn reader_num_work_units_completed<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReaderNumWorkUnitsCompleted::new();
    reader_num_work_units_completed_with_args(ctx, reader_handle, &__args)
}

/// reader_num_work_units_completed with options.
pub fn reader_num_work_units_completed_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    __args: &ReaderNumWorkUnitsCompleted,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderNumWorkUnitsCompleted")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReaderNumWorkUnitsCompletedV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderNumWorkUnitsCompletedV2 {}

impl ReaderNumWorkUnitsCompletedV2 {
    /// Creates a new `ReaderNumWorkUnitsCompletedV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_num_work_units_completed_v2 with default options.
pub fn reader_num_work_units_completed_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReaderNumWorkUnitsCompletedV2::new();
    reader_num_work_units_completed_v2_with_args(ctx, reader_handle, &__args)
}

/// reader_num_work_units_completed_v2 with options.
pub fn reader_num_work_units_completed_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    __args: &ReaderNumWorkUnitsCompletedV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderNumWorkUnitsCompletedV2")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReaderRead
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderRead {}

impl ReaderRead {
    /// Creates a new `ReaderRead`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_read with default options.
pub fn reader_read<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    queue_handle: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = ReaderRead::new();
    reader_read_with_args(ctx, reader_handle, queue_handle, &__args)
}

/// reader_read with options.
pub fn reader_read_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    queue_handle: T1,
    __args: &ReaderRead,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderRead")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;
    op.add_input(&queue_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// ReaderReadUpTo
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderReadUpTo {}

impl ReaderReadUpTo {
    /// Creates a new `ReaderReadUpTo`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_read_up_to with default options.
pub fn reader_read_up_to<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    queue_handle: T1,
    num_records: T2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = ReaderReadUpTo::new();
    reader_read_up_to_with_args(ctx, reader_handle, queue_handle, num_records, &__args)
}

/// reader_read_up_to with options.
pub fn reader_read_up_to_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    queue_handle: T1,
    num_records: T2,
    __args: &ReaderReadUpTo,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderReadUpTo")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;
    op.add_input(&queue_handle.to_handle()?)?;
    op.add_input(&num_records.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// ReaderReadUpToV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderReadUpToV2 {}

impl ReaderReadUpToV2 {
    /// Creates a new `ReaderReadUpToV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_read_up_to_v2 with default options.
pub fn reader_read_up_to_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    queue_handle: T1,
    num_records: T2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = ReaderReadUpToV2::new();
    reader_read_up_to_v2_with_args(ctx, reader_handle, queue_handle, num_records, &__args)
}

/// reader_read_up_to_v2 with options.
pub fn reader_read_up_to_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    queue_handle: T1,
    num_records: T2,
    __args: &ReaderReadUpToV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderReadUpToV2")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;
    op.add_input(&queue_handle.to_handle()?)?;
    op.add_input(&num_records.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// ReaderReadV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderReadV2 {}

impl ReaderReadV2 {
    /// Creates a new `ReaderReadV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_read_v2 with default options.
pub fn reader_read_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    queue_handle: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = ReaderReadV2::new();
    reader_read_v2_with_args(ctx, reader_handle, queue_handle, &__args)
}

/// reader_read_v2 with options.
pub fn reader_read_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    queue_handle: T1,
    __args: &ReaderReadV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderReadV2")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;
    op.add_input(&queue_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// ReaderReset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderReset {}

impl ReaderReset {
    /// Creates a new `ReaderReset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_reset with default options.
pub fn reader_reset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
) -> Result<()> {
    let __args = ReaderReset::new();
    reader_reset_with_args(ctx, reader_handle, &__args)
}

/// reader_reset with options.
pub fn reader_reset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    __args: &ReaderReset,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderReset")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ReaderResetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderResetV2 {}

impl ReaderResetV2 {
    /// Creates a new `ReaderResetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_reset_v2 with default options.
pub fn reader_reset_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
) -> Result<()> {
    let __args = ReaderResetV2::new();
    reader_reset_v2_with_args(ctx, reader_handle, &__args)
}

/// reader_reset_v2 with options.
pub fn reader_reset_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    __args: &ReaderResetV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderResetV2")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ReaderRestoreState
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderRestoreState {}

impl ReaderRestoreState {
    /// Creates a new `ReaderRestoreState`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_restore_state with default options.
pub fn reader_restore_state<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    state: T1,
) -> Result<()> {
    let __args = ReaderRestoreState::new();
    reader_restore_state_with_args(ctx, reader_handle, state, &__args)
}

/// reader_restore_state with options.
pub fn reader_restore_state_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    state: T1,
    __args: &ReaderRestoreState,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderRestoreState")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;
    op.add_input(&state.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ReaderRestoreStateV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderRestoreStateV2 {}

impl ReaderRestoreStateV2 {
    /// Creates a new `ReaderRestoreStateV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_restore_state_v2 with default options.
pub fn reader_restore_state_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    state: T1,
) -> Result<()> {
    let __args = ReaderRestoreStateV2::new();
    reader_restore_state_v2_with_args(ctx, reader_handle, state, &__args)
}

/// reader_restore_state_v2 with options.
pub fn reader_restore_state_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    state: T1,
    __args: &ReaderRestoreStateV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderRestoreStateV2")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;
    op.add_input(&state.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ReaderSerializeState
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderSerializeState {}

impl ReaderSerializeState {
    /// Creates a new `ReaderSerializeState`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_serialize_state with default options.
pub fn reader_serialize_state<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReaderSerializeState::new();
    reader_serialize_state_with_args(ctx, reader_handle, &__args)
}

/// reader_serialize_state with options.
pub fn reader_serialize_state_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    __args: &ReaderSerializeState,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderSerializeState")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReaderSerializeStateV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderSerializeStateV2 {}

impl ReaderSerializeStateV2 {
    /// Creates a new `ReaderSerializeStateV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reader_serialize_state_v2 with default options.
pub fn reader_serialize_state_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReaderSerializeStateV2::new();
    reader_serialize_state_v2_with_args(ctx, reader_handle, &__args)
}

/// reader_serialize_state_v2 with options.
pub fn reader_serialize_state_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reader_handle: T0,
    __args: &ReaderSerializeStateV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReaderSerializeStateV2")?;

    // Required input arguments
    op.add_input(&reader_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Real
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Real {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl Real {
    /// Creates a new `Real`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// real with default options.
pub fn real<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Real::new();
    real_with_args(ctx, input, &__args)
}

/// real with options.
pub fn real_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Real,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Real")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RealDiv
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RealDiv {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RealDiv {
    /// Creates a new `RealDiv`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// real_div with default options.
pub fn real_div<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RealDiv::new();
    real_div_with_args(ctx, x, y, &__args)
}

/// real_div with options.
pub fn real_div_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RealDiv,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RealDiv")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RebatchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RebatchDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub use_fallback: ::std::option::Option<bool>,
}

impl RebatchDataset {
    /// Creates a new `RebatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// rebatch_dataset with default options.
pub fn rebatch_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_replicas: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RebatchDataset::new();
    rebatch_dataset_with_args(ctx, input_dataset, num_replicas, &__args)
}

/// rebatch_dataset with options.
pub fn rebatch_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_replicas: T1,
    __args: &RebatchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RebatchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&num_replicas.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.use_fallback {
        op.set_attr_bool("use_fallback", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RebatchDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RebatchDatasetV2 {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl RebatchDatasetV2 {
    /// Creates a new `RebatchDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// rebatch_dataset_v2 with default options.
pub fn rebatch_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_sizes: T1,
    drop_remainder: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RebatchDatasetV2::new();
    rebatch_dataset_v2_with_args(ctx, input_dataset, batch_sizes, drop_remainder, &__args)
}

/// rebatch_dataset_v2 with options.
pub fn rebatch_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    batch_sizes: T1,
    drop_remainder: T2,
    __args: &RebatchDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RebatchDatasetV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&batch_sizes.to_handle()?)?;
    op.add_input(&drop_remainder.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Reciprocal
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Reciprocal {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Reciprocal {
    /// Creates a new `Reciprocal`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reciprocal with default options.
pub fn reciprocal<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Reciprocal::new();
    reciprocal_with_args(ctx, x, &__args)
}

/// reciprocal with options.
pub fn reciprocal_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Reciprocal,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Reciprocal")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReciprocalGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReciprocalGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl ReciprocalGrad {
    /// Creates a new `ReciprocalGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reciprocal_grad with default options.
pub fn reciprocal_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    dy: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReciprocalGrad::new();
    reciprocal_grad_with_args(ctx, y, dy, &__args)
}

/// reciprocal_grad with options.
pub fn reciprocal_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    dy: T1,
    __args: &ReciprocalGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReciprocalGrad")?;

    // Required input arguments
    op.add_input(&y.to_handle()?)?;
    op.add_input(&dy.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RecordInput
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RecordInput {
    pub file_pattern: ::std::option::Option<::std::string::String>,
    pub file_random_seed: ::std::option::Option<i64>,
    pub file_shuffle_shift_ratio: ::std::option::Option<f32>,
    pub file_buffer_size: ::std::option::Option<i64>,
    pub file_parallelism: ::std::option::Option<i64>,
    pub batch_size: ::std::option::Option<i64>,
    pub compression_type: ::std::option::Option<::std::string::String>,
}

impl RecordInput {
    /// Creates a new `RecordInput`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// record_input with default options.
pub fn record_input(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = RecordInput::new();
    record_input_with_args(ctx, &__args)
}

/// record_input with options.
pub fn record_input_with_args(
    ctx: &crate::eager::Context,
    __args: &RecordInput,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RecordInput")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.file_pattern {
        op.set_attr_string("file_pattern", value);
    }
    if let ::std::option::Option::Some(value) = &__args.file_random_seed {
        op.set_attr_int("file_random_seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.file_shuffle_shift_ratio {
        op.set_attr_float("file_shuffle_shift_ratio", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.file_buffer_size {
        op.set_attr_int("file_buffer_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.file_parallelism {
        op.set_attr_int("file_parallelism", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.batch_size {
        op.set_attr_int("batch_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.compression_type {
        op.set_attr_string("compression_type", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Recv
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Recv {
    pub tensor_type: ::std::option::Option<crate::DataType>,
    pub tensor_name: ::std::option::Option<::std::string::String>,
    pub send_device: ::std::option::Option<::std::string::String>,
    pub send_device_incarnation: ::std::option::Option<i64>,
    pub recv_device: ::std::option::Option<::std::string::String>,
    pub client_terminated: ::std::option::Option<bool>,
}

impl Recv {
    /// Creates a new `Recv`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// recv with default options.
pub fn recv(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = Recv::new();
    recv_with_args(ctx, &__args)
}

/// recv with options.
pub fn recv_with_args(
    ctx: &crate::eager::Context,
    __args: &Recv,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Recv")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.tensor_type {
        op.set_attr_type("tensor_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_name {
        op.set_attr_string("tensor_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.send_device {
        op.set_attr_string("send_device", value);
    }
    if let ::std::option::Option::Some(value) = &__args.send_device_incarnation {
        op.set_attr_int("send_device_incarnation", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.recv_device {
        op.set_attr_string("recv_device", value);
    }
    if let ::std::option::Option::Some(value) = &__args.client_terminated {
        op.set_attr_bool("client_terminated", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RecvTPUEmbeddingActivations
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RecvTPUEmbeddingActivations {
    pub num_outputs: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RecvTPUEmbeddingActivations {
    /// Creates a new `RecvTPUEmbeddingActivations`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// recv_tpuembedding_activations with default options.
pub fn recv_tpuembedding_activations(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = RecvTPUEmbeddingActivations::new();
    recv_tpuembedding_activations_with_args(ctx, &__args)
}

/// recv_tpuembedding_activations with options.
pub fn recv_tpuembedding_activations_with_args(
    ctx: &crate::eager::Context,
    __args: &RecvTPUEmbeddingActivations,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RecvTPUEmbeddingActivations")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_outputs {
        op.set_attr_int("num_outputs", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReduceDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReduceDataset {
    pub f: ::std::option::Option<::std::string::String>,
    pub Tstate: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub use_inter_op_parallelism: ::std::option::Option<bool>,
}

impl ReduceDataset {
    /// Creates a new `ReduceDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reduce_dataset with default options.
pub fn reduce_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    initial_state: T1,
    other_arguments: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReduceDataset::new();
    reduce_dataset_with_args(ctx, input_dataset, initial_state, other_arguments, &__args)
}

/// reduce_dataset with options.
pub fn reduce_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    initial_state: T1,
    other_arguments: T2,
    __args: &ReduceDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReduceDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&initial_state.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tstate {
        op.set_attr_type_list("Tstate", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.use_inter_op_parallelism {
        op.set_attr_bool("use_inter_op_parallelism", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReduceJoin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReduceJoin {
    pub keep_dims: ::std::option::Option<bool>,
    pub separator: ::std::option::Option<::std::string::String>,
}

impl ReduceJoin {
    /// Creates a new `ReduceJoin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reduce_join with default options.
pub fn reduce_join<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    reduction_indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReduceJoin::new();
    reduce_join_with_args(ctx, inputs, reduction_indices, &__args)
}

/// reduce_join with options.
pub fn reduce_join_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    reduction_indices: T1,
    __args: &ReduceJoin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReduceJoin")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;
    op.add_input(&reduction_indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.separator {
        op.set_attr_string("separator", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RefEnter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefEnter {
    pub T: ::std::option::Option<crate::DataType>,
    pub frame_name: ::std::option::Option<::std::string::String>,
    pub is_constant: ::std::option::Option<bool>,
    pub parallel_iterations: ::std::option::Option<i64>,
}

impl RefEnter {
    /// Creates a new `RefEnter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ref_enter with default options.
pub fn ref_enter<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RefEnter::new();
    ref_enter_with_args(ctx, data, &__args)
}

/// ref_enter with options.
pub fn ref_enter_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    __args: &RefEnter,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RefEnter")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.frame_name {
        op.set_attr_string("frame_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_constant {
        op.set_attr_bool("is_constant", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.parallel_iterations {
        op.set_attr_int("parallel_iterations", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RefExit
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefExit {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RefExit {
    /// Creates a new `RefExit`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ref_exit with default options.
pub fn ref_exit<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RefExit::new();
    ref_exit_with_args(ctx, data, &__args)
}

/// ref_exit with options.
pub fn ref_exit_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    __args: &RefExit,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RefExit")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RefIdentity
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefIdentity {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RefIdentity {
    /// Creates a new `RefIdentity`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ref_identity with default options.
pub fn ref_identity<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RefIdentity::new();
    ref_identity_with_args(ctx, input, &__args)
}

/// ref_identity with options.
pub fn ref_identity_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &RefIdentity,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RefIdentity")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RefMerge
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefMerge {
    pub T: ::std::option::Option<crate::DataType>,
    pub N: ::std::option::Option<i64>,
}

impl RefMerge {
    /// Creates a new `RefMerge`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ref_merge with default options.
pub fn ref_merge<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RefMerge::new();
    ref_merge_with_args(ctx, inputs, &__args)
}

/// ref_merge with options.
pub fn ref_merge_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &RefMerge,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RefMerge")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RefNextIteration
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefNextIteration {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RefNextIteration {
    /// Creates a new `RefNextIteration`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ref_next_iteration with default options.
pub fn ref_next_iteration<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RefNextIteration::new();
    ref_next_iteration_with_args(ctx, data, &__args)
}

/// ref_next_iteration with options.
pub fn ref_next_iteration_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    __args: &RefNextIteration,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RefNextIteration")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RefSelect
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefSelect {
    pub T: ::std::option::Option<crate::DataType>,
    pub N: ::std::option::Option<i64>,
}

impl RefSelect {
    /// Creates a new `RefSelect`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ref_select with default options.
pub fn ref_select<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    index: T0,
    inputs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RefSelect::new();
    ref_select_with_args(ctx, index, inputs, &__args)
}

/// ref_select with options.
pub fn ref_select_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    index: T0,
    inputs: T1,
    __args: &RefSelect,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RefSelect")?;

    // Required input arguments
    op.add_input(&index.to_handle()?)?;
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RefSwitch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefSwitch {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RefSwitch {
    /// Creates a new `RefSwitch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// ref_switch with default options.
pub fn ref_switch<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    pred: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RefSwitch::new();
    ref_switch_with_args(ctx, data, pred, &__args)
}

/// ref_switch with options.
pub fn ref_switch_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    pred: T1,
    __args: &RefSwitch,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RefSwitch")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&pred.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RegexFullMatch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RegexFullMatch {}

impl RegexFullMatch {
    /// Creates a new `RegexFullMatch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// regex_full_match with default options.
pub fn regex_full_match<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    pattern: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RegexFullMatch::new();
    regex_full_match_with_args(ctx, input, pattern, &__args)
}

/// regex_full_match with options.
pub fn regex_full_match_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    pattern: T1,
    __args: &RegexFullMatch,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RegexFullMatch")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&pattern.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RegexReplace
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RegexReplace {
    pub replace_global: ::std::option::Option<bool>,
}

impl RegexReplace {
    /// Creates a new `RegexReplace`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// regex_replace with default options.
pub fn regex_replace<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    pattern: T1,
    rewrite: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RegexReplace::new();
    regex_replace_with_args(ctx, input, pattern, rewrite, &__args)
}

/// regex_replace with options.
pub fn regex_replace_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    pattern: T1,
    rewrite: T2,
    __args: &RegexReplace,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RegexReplace")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&pattern.to_handle()?)?;
    op.add_input(&rewrite.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.replace_global {
        op.set_attr_bool("replace_global", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RegisterDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RegisterDataset {
    pub external_state_policy: ::std::option::Option<i64>,
}

impl RegisterDataset {
    /// Creates a new `RegisterDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// register_dataset with default options.
pub fn register_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    dataset: T0,
    address: T1,
    protocol: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RegisterDataset::new();
    register_dataset_with_args(ctx, dataset, address, protocol, &__args)
}

/// register_dataset with options.
pub fn register_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    dataset: T0,
    address: T1,
    protocol: T2,
    __args: &RegisterDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RegisterDataset")?;

    // Required input arguments
    op.add_input(&dataset.to_handle()?)?;
    op.add_input(&address.to_handle()?)?;
    op.add_input(&protocol.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.external_state_policy {
        op.set_attr_int("external_state_policy", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Relu
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Relu {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Relu {
    /// Creates a new `Relu`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// relu with default options.
pub fn relu<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Relu::new();
    relu_with_args(ctx, features, &__args)
}

/// relu with options.
pub fn relu_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
    __args: &Relu,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Relu")?;

    // Required input arguments
    op.add_input(&features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Relu6
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Relu6 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Relu6 {
    /// Creates a new `Relu6`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// relu6 with default options.
pub fn relu6<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Relu6::new();
    relu6_with_args(ctx, features, &__args)
}

/// relu6 with options.
pub fn relu6_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
    __args: &Relu6,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Relu6")?;

    // Required input arguments
    op.add_input(&features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Relu6Grad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Relu6Grad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Relu6Grad {
    /// Creates a new `Relu6Grad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// relu6_grad with default options.
pub fn relu6_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    features: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Relu6Grad::new();
    relu6_grad_with_args(ctx, gradients, features, &__args)
}

/// relu6_grad with options.
pub fn relu6_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    features: T1,
    __args: &Relu6Grad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Relu6Grad")?;

    // Required input arguments
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReluGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReluGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl ReluGrad {
    /// Creates a new `ReluGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// relu_grad with default options.
pub fn relu_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    features: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReluGrad::new();
    relu_grad_with_args(ctx, gradients, features, &__args)
}

/// relu_grad with options.
pub fn relu_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    features: T1,
    __args: &ReluGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReluGrad")?;

    // Required input arguments
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RemoteCall
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RemoteCall {
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub f: ::std::option::Option<::std::string::String>,
}

impl RemoteCall {
    /// Creates a new `RemoteCall`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// remote_call with default options.
pub fn remote_call<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    target: T0,
    args: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RemoteCall::new();
    remote_call_with_args(ctx, target, args, &__args)
}

/// remote_call with options.
pub fn remote_call_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    target: T0,
    args: T1,
    __args: &RemoteCall,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RemoteCall")?;

    // Required input arguments
    op.add_input(&target.to_handle()?)?;
    op.add_input(&args.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RepeatDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RepeatDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl RepeatDataset {
    /// Creates a new `RepeatDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// repeat_dataset with default options.
pub fn repeat_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    count: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RepeatDataset::new();
    repeat_dataset_with_args(ctx, input_dataset, count, &__args)
}

/// repeat_dataset with options.
pub fn repeat_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    count: T1,
    __args: &RepeatDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RepeatDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&count.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RequantizationRange
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RequantizationRange {
    pub Tinput: ::std::option::Option<crate::DataType>,
}

impl RequantizationRange {
    /// Creates a new `RequantizationRange`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// requantization_range with default options.
pub fn requantization_range<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RequantizationRange::new();
    requantization_range_with_args(ctx, input, input_min, input_max, &__args)
}

/// requantization_range with options.
pub fn requantization_range_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
    __args: &RequantizationRange,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RequantizationRange")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_min.to_handle()?)?;
    op.add_input(&input_max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RequantizationRangePerChannel
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RequantizationRangePerChannel {
    pub T: ::std::option::Option<crate::DataType>,
    pub clip_value_max: ::std::option::Option<f32>,
}

impl RequantizationRangePerChannel {
    /// Creates a new `RequantizationRangePerChannel`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// requantization_range_per_channel with default options.
pub fn requantization_range_per_channel<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RequantizationRangePerChannel::new();
    requantization_range_per_channel_with_args(ctx, input, input_min, input_max, &__args)
}

/// requantization_range_per_channel with options.
pub fn requantization_range_per_channel_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
    __args: &RequantizationRangePerChannel,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RequantizationRangePerChannel")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_min.to_handle()?)?;
    op.add_input(&input_max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.clip_value_max {
        op.set_attr_float("clip_value_max", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Requantize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Requantize {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl Requantize {
    /// Creates a new `Requantize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// requantize with default options.
pub fn requantize<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
    requested_output_min: T3,
    requested_output_max: T4,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = Requantize::new();
    requantize_with_args(
        ctx,
        input,
        input_min,
        input_max,
        requested_output_min,
        requested_output_max,
        &__args,
    )
}

/// requantize with options.
pub fn requantize_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
    requested_output_min: T3,
    requested_output_max: T4,
    __args: &Requantize,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Requantize")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_min.to_handle()?)?;
    op.add_input(&input_max.to_handle()?)?;
    op.add_input(&requested_output_min.to_handle()?)?;
    op.add_input(&requested_output_max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RequantizePerChannel
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RequantizePerChannel {
    pub T: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl RequantizePerChannel {
    /// Creates a new `RequantizePerChannel`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// requantize_per_channel with default options.
pub fn requantize_per_channel<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
    requested_output_min: T3,
    requested_output_max: T4,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = RequantizePerChannel::new();
    requantize_per_channel_with_args(
        ctx,
        input,
        input_min,
        input_max,
        requested_output_min,
        requested_output_max,
        &__args,
    )
}

/// requantize_per_channel with options.
pub fn requantize_per_channel_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    input_min: T1,
    input_max: T2,
    requested_output_min: T3,
    requested_output_max: T4,
    __args: &RequantizePerChannel,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RequantizePerChannel")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&input_min.to_handle()?)?;
    op.add_input(&input_max.to_handle()?)?;
    op.add_input(&requested_output_min.to_handle()?)?;
    op.add_input(&requested_output_max.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Reshape
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Reshape {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tshape: ::std::option::Option<crate::DataType>,
}

impl Reshape {
    /// Creates a new `Reshape`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reshape with default options.
pub fn reshape<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    shape: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Reshape::new();
    reshape_with_args(ctx, tensor, shape, &__args)
}

/// reshape with options.
pub fn reshape_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    shape: T1,
    __args: &Reshape,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Reshape")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshape {
        op.set_attr_type("Tshape", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResizeArea
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeArea {
    pub T: ::std::option::Option<crate::DataType>,
    pub align_corners: ::std::option::Option<bool>,
}

impl ResizeArea {
    /// Creates a new `ResizeArea`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resize_area with default options.
pub fn resize_area<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    size: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResizeArea::new();
    resize_area_with_args(ctx, images, size, &__args)
}

/// resize_area with options.
pub fn resize_area_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    size: T1,
    __args: &ResizeArea,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResizeArea")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.align_corners {
        op.set_attr_bool("align_corners", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResizeBicubic
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeBicubic {
    pub T: ::std::option::Option<crate::DataType>,
    pub align_corners: ::std::option::Option<bool>,
    pub half_pixel_centers: ::std::option::Option<bool>,
}

impl ResizeBicubic {
    /// Creates a new `ResizeBicubic`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resize_bicubic with default options.
pub fn resize_bicubic<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    size: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResizeBicubic::new();
    resize_bicubic_with_args(ctx, images, size, &__args)
}

/// resize_bicubic with options.
pub fn resize_bicubic_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    size: T1,
    __args: &ResizeBicubic,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResizeBicubic")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.align_corners {
        op.set_attr_bool("align_corners", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.half_pixel_centers {
        op.set_attr_bool("half_pixel_centers", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResizeBicubicGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeBicubicGrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub align_corners: ::std::option::Option<bool>,
    pub half_pixel_centers: ::std::option::Option<bool>,
}

impl ResizeBicubicGrad {
    /// Creates a new `ResizeBicubicGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resize_bicubic_grad with default options.
pub fn resize_bicubic_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    grads: T0,
    original_image: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResizeBicubicGrad::new();
    resize_bicubic_grad_with_args(ctx, grads, original_image, &__args)
}

/// resize_bicubic_grad with options.
pub fn resize_bicubic_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    grads: T0,
    original_image: T1,
    __args: &ResizeBicubicGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResizeBicubicGrad")?;

    // Required input arguments
    op.add_input(&grads.to_handle()?)?;
    op.add_input(&original_image.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.align_corners {
        op.set_attr_bool("align_corners", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.half_pixel_centers {
        op.set_attr_bool("half_pixel_centers", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResizeBilinear
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeBilinear {
    pub T: ::std::option::Option<crate::DataType>,
    pub align_corners: ::std::option::Option<bool>,
    pub half_pixel_centers: ::std::option::Option<bool>,
}

impl ResizeBilinear {
    /// Creates a new `ResizeBilinear`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resize_bilinear with default options.
pub fn resize_bilinear<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    size: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResizeBilinear::new();
    resize_bilinear_with_args(ctx, images, size, &__args)
}

/// resize_bilinear with options.
pub fn resize_bilinear_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    size: T1,
    __args: &ResizeBilinear,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResizeBilinear")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.align_corners {
        op.set_attr_bool("align_corners", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.half_pixel_centers {
        op.set_attr_bool("half_pixel_centers", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResizeBilinearGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeBilinearGrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub align_corners: ::std::option::Option<bool>,
    pub half_pixel_centers: ::std::option::Option<bool>,
}

impl ResizeBilinearGrad {
    /// Creates a new `ResizeBilinearGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resize_bilinear_grad with default options.
pub fn resize_bilinear_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    grads: T0,
    original_image: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResizeBilinearGrad::new();
    resize_bilinear_grad_with_args(ctx, grads, original_image, &__args)
}

/// resize_bilinear_grad with options.
pub fn resize_bilinear_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    grads: T0,
    original_image: T1,
    __args: &ResizeBilinearGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResizeBilinearGrad")?;

    // Required input arguments
    op.add_input(&grads.to_handle()?)?;
    op.add_input(&original_image.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.align_corners {
        op.set_attr_bool("align_corners", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.half_pixel_centers {
        op.set_attr_bool("half_pixel_centers", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResizeNearestNeighbor
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeNearestNeighbor {
    pub T: ::std::option::Option<crate::DataType>,
    pub align_corners: ::std::option::Option<bool>,
    pub half_pixel_centers: ::std::option::Option<bool>,
}

impl ResizeNearestNeighbor {
    /// Creates a new `ResizeNearestNeighbor`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resize_nearest_neighbor with default options.
pub fn resize_nearest_neighbor<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    size: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResizeNearestNeighbor::new();
    resize_nearest_neighbor_with_args(ctx, images, size, &__args)
}

/// resize_nearest_neighbor with options.
pub fn resize_nearest_neighbor_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    images: T0,
    size: T1,
    __args: &ResizeNearestNeighbor,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResizeNearestNeighbor")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.align_corners {
        op.set_attr_bool("align_corners", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.half_pixel_centers {
        op.set_attr_bool("half_pixel_centers", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResizeNearestNeighborGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeNearestNeighborGrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub align_corners: ::std::option::Option<bool>,
    pub half_pixel_centers: ::std::option::Option<bool>,
}

impl ResizeNearestNeighborGrad {
    /// Creates a new `ResizeNearestNeighborGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resize_nearest_neighbor_grad with default options.
pub fn resize_nearest_neighbor_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    grads: T0,
    size: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResizeNearestNeighborGrad::new();
    resize_nearest_neighbor_grad_with_args(ctx, grads, size, &__args)
}

/// resize_nearest_neighbor_grad with options.
pub fn resize_nearest_neighbor_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grads: T0,
    size: T1,
    __args: &ResizeNearestNeighborGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResizeNearestNeighborGrad")?;

    // Required input arguments
    op.add_input(&grads.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.align_corners {
        op.set_attr_bool("align_corners", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.half_pixel_centers {
        op.set_attr_bool("half_pixel_centers", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResourceAccumulatorApplyGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceAccumulatorApplyGradient {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl ResourceAccumulatorApplyGradient {
    /// Creates a new `ResourceAccumulatorApplyGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_accumulator_apply_gradient with default options.
pub fn resource_accumulator_apply_gradient<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    local_step: T1,
    gradient: T2,
) -> Result<()> {
    let __args = ResourceAccumulatorApplyGradient::new();
    resource_accumulator_apply_gradient_with_args(ctx, handle, local_step, gradient, &__args)
}

/// resource_accumulator_apply_gradient with options.
pub fn resource_accumulator_apply_gradient_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    local_step: T1,
    gradient: T2,
    __args: &ResourceAccumulatorApplyGradient,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceAccumulatorApplyGradient")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&local_step.to_handle()?)?;
    op.add_input(&gradient.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceAccumulatorNumAccumulated
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceAccumulatorNumAccumulated {}

impl ResourceAccumulatorNumAccumulated {
    /// Creates a new `ResourceAccumulatorNumAccumulated`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_accumulator_num_accumulated with default options.
pub fn resource_accumulator_num_accumulated<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResourceAccumulatorNumAccumulated::new();
    resource_accumulator_num_accumulated_with_args(ctx, handle, &__args)
}

/// resource_accumulator_num_accumulated with options.
pub fn resource_accumulator_num_accumulated_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &ResourceAccumulatorNumAccumulated,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceAccumulatorNumAccumulated")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResourceAccumulatorSetGlobalStep
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceAccumulatorSetGlobalStep {}

impl ResourceAccumulatorSetGlobalStep {
    /// Creates a new `ResourceAccumulatorSetGlobalStep`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_accumulator_set_global_step with default options.
pub fn resource_accumulator_set_global_step<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    new_global_step: T1,
) -> Result<()> {
    let __args = ResourceAccumulatorSetGlobalStep::new();
    resource_accumulator_set_global_step_with_args(ctx, handle, new_global_step, &__args)
}

/// resource_accumulator_set_global_step with options.
pub fn resource_accumulator_set_global_step_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    new_global_step: T1,
    __args: &ResourceAccumulatorSetGlobalStep,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceAccumulatorSetGlobalStep")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&new_global_step.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceAccumulatorTakeGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceAccumulatorTakeGradient {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl ResourceAccumulatorTakeGradient {
    /// Creates a new `ResourceAccumulatorTakeGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_accumulator_take_gradient with default options.
pub fn resource_accumulator_take_gradient<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    num_required: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResourceAccumulatorTakeGradient::new();
    resource_accumulator_take_gradient_with_args(ctx, handle, num_required, &__args)
}

/// resource_accumulator_take_gradient with options.
pub fn resource_accumulator_take_gradient_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    num_required: T1,
    __args: &ResourceAccumulatorTakeGradient,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceAccumulatorTakeGradient")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&num_required.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResourceApplyAdaMax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdaMax {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceApplyAdaMax {
    /// Creates a new `ResourceApplyAdaMax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_ada_max with default options.
pub fn resource_apply_ada_max<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    v: T2,
    beta1_power: T3,
    lr: T4,
    beta1: T5,
    beta2: T6,
    epsilon: T7,
    grad: T8,
) -> Result<()> {
    let __args = ResourceApplyAdaMax::new();
    resource_apply_ada_max_with_args(
        ctx,
        var,
        m,
        v,
        beta1_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad,
        &__args,
    )
}

/// resource_apply_ada_max with options.
pub fn resource_apply_ada_max_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    v: T2,
    beta1_power: T3,
    lr: T4,
    beta1: T5,
    beta2: T6,
    epsilon: T7,
    grad: T8,
    __args: &ResourceApplyAdaMax,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyAdaMax")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;
    op.add_input(&beta1_power.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&beta1.to_handle()?)?;
    op.add_input(&beta2.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyAdadelta
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdadelta {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceApplyAdadelta {
    /// Creates a new `ResourceApplyAdadelta`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_adadelta with default options.
pub fn resource_apply_adadelta<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    accum_update: T2,
    lr: T3,
    rho: T4,
    epsilon: T5,
    grad: T6,
) -> Result<()> {
    let __args = ResourceApplyAdadelta::new();
    resource_apply_adadelta_with_args(
        ctx,
        var,
        accum,
        accum_update,
        lr,
        rho,
        epsilon,
        grad,
        &__args,
    )
}

/// resource_apply_adadelta with options.
pub fn resource_apply_adadelta_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    accum_update: T2,
    lr: T3,
    rho: T4,
    epsilon: T5,
    grad: T6,
    __args: &ResourceApplyAdadelta,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyAdadelta")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&accum_update.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&rho.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyAdagrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdagrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub update_slots: ::std::option::Option<bool>,
}

impl ResourceApplyAdagrad {
    /// Creates a new `ResourceApplyAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_adagrad with default options.
pub fn resource_apply_adagrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
) -> Result<()> {
    let __args = ResourceApplyAdagrad::new();
    resource_apply_adagrad_with_args(ctx, var, accum, lr, grad, &__args)
}

/// resource_apply_adagrad with options.
pub fn resource_apply_adagrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    __args: &ResourceApplyAdagrad,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyAdagrad")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.update_slots {
        op.set_attr_bool("update_slots", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyAdagradDA
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdagradDA {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceApplyAdagradDA {
    /// Creates a new `ResourceApplyAdagradDA`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_adagrad_da with default options.
pub fn resource_apply_adagrad_da<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    gradient_accumulator: T1,
    gradient_squared_accumulator: T2,
    grad: T3,
    lr: T4,
    l1: T5,
    l2: T6,
    global_step: T7,
) -> Result<()> {
    let __args = ResourceApplyAdagradDA::new();
    resource_apply_adagrad_da_with_args(
        ctx,
        var,
        gradient_accumulator,
        gradient_squared_accumulator,
        grad,
        lr,
        l1,
        l2,
        global_step,
        &__args,
    )
}

/// resource_apply_adagrad_da with options.
pub fn resource_apply_adagrad_da_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    gradient_accumulator: T1,
    gradient_squared_accumulator: T2,
    grad: T3,
    lr: T4,
    l1: T5,
    l2: T6,
    global_step: T7,
    __args: &ResourceApplyAdagradDA,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyAdagradDA")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&gradient_accumulator.to_handle()?)?;
    op.add_input(&gradient_squared_accumulator.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&global_step.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyAdagradV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdagradV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub update_slots: ::std::option::Option<bool>,
}

impl ResourceApplyAdagradV2 {
    /// Creates a new `ResourceApplyAdagradV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_adagrad_v2 with default options.
pub fn resource_apply_adagrad_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    epsilon: T3,
    grad: T4,
) -> Result<()> {
    let __args = ResourceApplyAdagradV2::new();
    resource_apply_adagrad_v2_with_args(ctx, var, accum, lr, epsilon, grad, &__args)
}

/// resource_apply_adagrad_v2 with options.
pub fn resource_apply_adagrad_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    epsilon: T3,
    grad: T4,
    __args: &ResourceApplyAdagradV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyAdagradV2")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.update_slots {
        op.set_attr_bool("update_slots", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyAdam
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdam {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub use_nesterov: ::std::option::Option<bool>,
}

impl ResourceApplyAdam {
    /// Creates a new `ResourceApplyAdam`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_adam with default options.
pub fn resource_apply_adam<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    v: T2,
    beta1_power: T3,
    beta2_power: T4,
    lr: T5,
    beta1: T6,
    beta2: T7,
    epsilon: T8,
    grad: T9,
) -> Result<()> {
    let __args = ResourceApplyAdam::new();
    resource_apply_adam_with_args(
        ctx,
        var,
        m,
        v,
        beta1_power,
        beta2_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad,
        &__args,
    )
}

/// resource_apply_adam with options.
pub fn resource_apply_adam_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    v: T2,
    beta1_power: T3,
    beta2_power: T4,
    lr: T5,
    beta1: T6,
    beta2: T7,
    epsilon: T8,
    grad: T9,
    __args: &ResourceApplyAdam,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyAdam")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;
    op.add_input(&beta1_power.to_handle()?)?;
    op.add_input(&beta2_power.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&beta1.to_handle()?)?;
    op.add_input(&beta2.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_nesterov {
        op.set_attr_bool("use_nesterov", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyAdamWithAmsgrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdamWithAmsgrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceApplyAdamWithAmsgrad {
    /// Creates a new `ResourceApplyAdamWithAmsgrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_adam_with_amsgrad with default options.
pub fn resource_apply_adam_with_amsgrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    v: T2,
    vhat: T3,
    beta1_power: T4,
    beta2_power: T5,
    lr: T6,
    beta1: T7,
    beta2: T8,
    epsilon: T9,
    grad: T10,
) -> Result<()> {
    let __args = ResourceApplyAdamWithAmsgrad::new();
    resource_apply_adam_with_amsgrad_with_args(
        ctx,
        var,
        m,
        v,
        vhat,
        beta1_power,
        beta2_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad,
        &__args,
    )
}

/// resource_apply_adam_with_amsgrad with options.
pub fn resource_apply_adam_with_amsgrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
    T10: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    v: T2,
    vhat: T3,
    beta1_power: T4,
    beta2_power: T5,
    lr: T6,
    beta1: T7,
    beta2: T8,
    epsilon: T9,
    grad: T10,
    __args: &ResourceApplyAdamWithAmsgrad,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyAdamWithAmsgrad")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&v.to_handle()?)?;
    op.add_input(&vhat.to_handle()?)?;
    op.add_input(&beta1_power.to_handle()?)?;
    op.add_input(&beta2_power.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&beta1.to_handle()?)?;
    op.add_input(&beta2.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyAddSign
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAddSign {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceApplyAddSign {
    /// Creates a new `ResourceApplyAddSign`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_add_sign with default options.
pub fn resource_apply_add_sign<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    lr: T2,
    alpha: T3,
    sign_decay: T4,
    beta: T5,
    grad: T6,
) -> Result<()> {
    let __args = ResourceApplyAddSign::new();
    resource_apply_add_sign_with_args(ctx, var, m, lr, alpha, sign_decay, beta, grad, &__args)
}

/// resource_apply_add_sign with options.
pub fn resource_apply_add_sign_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    lr: T2,
    alpha: T3,
    sign_decay: T4,
    beta: T5,
    grad: T6,
    __args: &ResourceApplyAddSign,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyAddSign")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&alpha.to_handle()?)?;
    op.add_input(&sign_decay.to_handle()?)?;
    op.add_input(&beta.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyCenteredRMSProp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyCenteredRMSProp {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceApplyCenteredRMSProp {
    /// Creates a new `ResourceApplyCenteredRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_centered_rmsprop with default options.
pub fn resource_apply_centered_rmsprop<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    mg: T1,
    ms: T2,
    mom: T3,
    lr: T4,
    rho: T5,
    momentum: T6,
    epsilon: T7,
    grad: T8,
) -> Result<()> {
    let __args = ResourceApplyCenteredRMSProp::new();
    resource_apply_centered_rmsprop_with_args(
        ctx, var, mg, ms, mom, lr, rho, momentum, epsilon, grad, &__args,
    )
}

/// resource_apply_centered_rmsprop with options.
pub fn resource_apply_centered_rmsprop_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    mg: T1,
    ms: T2,
    mom: T3,
    lr: T4,
    rho: T5,
    momentum: T6,
    epsilon: T7,
    grad: T8,
    __args: &ResourceApplyCenteredRMSProp,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyCenteredRMSProp")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&mg.to_handle()?)?;
    op.add_input(&ms.to_handle()?)?;
    op.add_input(&mom.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&rho.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyFtrl
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyFtrl {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub multiply_linear_by_lr: ::std::option::Option<bool>,
}

impl ResourceApplyFtrl {
    /// Creates a new `ResourceApplyFtrl`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_ftrl with default options.
pub fn resource_apply_ftrl<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    lr: T4,
    l1: T5,
    l2: T6,
    lr_power: T7,
) -> Result<()> {
    let __args = ResourceApplyFtrl::new();
    resource_apply_ftrl_with_args(ctx, var, accum, linear, grad, lr, l1, l2, lr_power, &__args)
}

/// resource_apply_ftrl with options.
pub fn resource_apply_ftrl_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    lr: T4,
    l1: T5,
    l2: T6,
    lr_power: T7,
    __args: &ResourceApplyFtrl,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyFtrl")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&linear.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&lr_power.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.multiply_linear_by_lr {
        op.set_attr_bool("multiply_linear_by_lr", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyFtrlV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyFtrlV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub multiply_linear_by_lr: ::std::option::Option<bool>,
}

impl ResourceApplyFtrlV2 {
    /// Creates a new `ResourceApplyFtrlV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_ftrl_v2 with default options.
pub fn resource_apply_ftrl_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    lr: T4,
    l1: T5,
    l2: T6,
    l2_shrinkage: T7,
    lr_power: T8,
) -> Result<()> {
    let __args = ResourceApplyFtrlV2::new();
    resource_apply_ftrl_v2_with_args(
        ctx,
        var,
        accum,
        linear,
        grad,
        lr,
        l1,
        l2,
        l2_shrinkage,
        lr_power,
        &__args,
    )
}

/// resource_apply_ftrl_v2 with options.
pub fn resource_apply_ftrl_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    lr: T4,
    l1: T5,
    l2: T6,
    l2_shrinkage: T7,
    lr_power: T8,
    __args: &ResourceApplyFtrlV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyFtrlV2")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&linear.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&l2_shrinkage.to_handle()?)?;
    op.add_input(&lr_power.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.multiply_linear_by_lr {
        op.set_attr_bool("multiply_linear_by_lr", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyGradientDescent
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyGradientDescent {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceApplyGradientDescent {
    /// Creates a new `ResourceApplyGradientDescent`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_gradient_descent with default options.
pub fn resource_apply_gradient_descent<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    alpha: T1,
    delta: T2,
) -> Result<()> {
    let __args = ResourceApplyGradientDescent::new();
    resource_apply_gradient_descent_with_args(ctx, var, alpha, delta, &__args)
}

/// resource_apply_gradient_descent with options.
pub fn resource_apply_gradient_descent_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    alpha: T1,
    delta: T2,
    __args: &ResourceApplyGradientDescent,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyGradientDescent")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&alpha.to_handle()?)?;
    op.add_input(&delta.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyKerasMomentum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyKerasMomentum {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub use_nesterov: ::std::option::Option<bool>,
}

impl ResourceApplyKerasMomentum {
    /// Creates a new `ResourceApplyKerasMomentum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_keras_momentum with default options.
pub fn resource_apply_keras_momentum<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    momentum: T4,
) -> Result<()> {
    let __args = ResourceApplyKerasMomentum::new();
    resource_apply_keras_momentum_with_args(ctx, var, accum, lr, grad, momentum, &__args)
}

/// resource_apply_keras_momentum with options.
pub fn resource_apply_keras_momentum_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    momentum: T4,
    __args: &ResourceApplyKerasMomentum,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyKerasMomentum")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_nesterov {
        op.set_attr_bool("use_nesterov", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyMomentum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyMomentum {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub use_nesterov: ::std::option::Option<bool>,
}

impl ResourceApplyMomentum {
    /// Creates a new `ResourceApplyMomentum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_momentum with default options.
pub fn resource_apply_momentum<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    momentum: T4,
) -> Result<()> {
    let __args = ResourceApplyMomentum::new();
    resource_apply_momentum_with_args(ctx, var, accum, lr, grad, momentum, &__args)
}

/// resource_apply_momentum with options.
pub fn resource_apply_momentum_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    momentum: T4,
    __args: &ResourceApplyMomentum,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyMomentum")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_nesterov {
        op.set_attr_bool("use_nesterov", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyPowerSign
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyPowerSign {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceApplyPowerSign {
    /// Creates a new `ResourceApplyPowerSign`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_power_sign with default options.
pub fn resource_apply_power_sign<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    lr: T2,
    logbase: T3,
    sign_decay: T4,
    beta: T5,
    grad: T6,
) -> Result<()> {
    let __args = ResourceApplyPowerSign::new();
    resource_apply_power_sign_with_args(ctx, var, m, lr, logbase, sign_decay, beta, grad, &__args)
}

/// resource_apply_power_sign with options.
pub fn resource_apply_power_sign_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    m: T1,
    lr: T2,
    logbase: T3,
    sign_decay: T4,
    beta: T5,
    grad: T6,
    __args: &ResourceApplyPowerSign,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyPowerSign")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&m.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&logbase.to_handle()?)?;
    op.add_input(&sign_decay.to_handle()?)?;
    op.add_input(&beta.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyProximalAdagrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyProximalAdagrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceApplyProximalAdagrad {
    /// Creates a new `ResourceApplyProximalAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_proximal_adagrad with default options.
pub fn resource_apply_proximal_adagrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    l1: T3,
    l2: T4,
    grad: T5,
) -> Result<()> {
    let __args = ResourceApplyProximalAdagrad::new();
    resource_apply_proximal_adagrad_with_args(ctx, var, accum, lr, l1, l2, grad, &__args)
}

/// resource_apply_proximal_adagrad with options.
pub fn resource_apply_proximal_adagrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    l1: T3,
    l2: T4,
    grad: T5,
    __args: &ResourceApplyProximalAdagrad,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyProximalAdagrad")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyProximalGradientDescent
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyProximalGradientDescent {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceApplyProximalGradientDescent {
    /// Creates a new `ResourceApplyProximalGradientDescent`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_proximal_gradient_descent with default options.
pub fn resource_apply_proximal_gradient_descent<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    alpha: T1,
    l1: T2,
    l2: T3,
    delta: T4,
) -> Result<()> {
    let __args = ResourceApplyProximalGradientDescent::new();
    resource_apply_proximal_gradient_descent_with_args(ctx, var, alpha, l1, l2, delta, &__args)
}

/// resource_apply_proximal_gradient_descent with options.
pub fn resource_apply_proximal_gradient_descent_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    alpha: T1,
    l1: T2,
    l2: T3,
    delta: T4,
    __args: &ResourceApplyProximalGradientDescent,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyProximalGradientDescent")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&alpha.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&delta.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceApplyRMSProp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyRMSProp {
    pub T: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceApplyRMSProp {
    /// Creates a new `ResourceApplyRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_apply_rmsprop with default options.
pub fn resource_apply_rmsprop<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    ms: T1,
    mom: T2,
    lr: T3,
    rho: T4,
    momentum: T5,
    epsilon: T6,
    grad: T7,
) -> Result<()> {
    let __args = ResourceApplyRMSProp::new();
    resource_apply_rmsprop_with_args(ctx, var, ms, mom, lr, rho, momentum, epsilon, grad, &__args)
}

/// resource_apply_rmsprop with options.
pub fn resource_apply_rmsprop_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    ms: T1,
    mom: T2,
    lr: T3,
    rho: T4,
    momentum: T5,
    epsilon: T6,
    grad: T7,
    __args: &ResourceApplyRMSProp,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceApplyRMSProp")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&ms.to_handle()?)?;
    op.add_input(&mom.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&rho.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceConditionalAccumulator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceConditionalAccumulator {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub reduction_type: ::std::option::Option<::std::string::String>,
}

impl ResourceConditionalAccumulator {
    /// Creates a new `ResourceConditionalAccumulator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_conditional_accumulator with default options.
pub fn resource_conditional_accumulator(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResourceConditionalAccumulator::new();
    resource_conditional_accumulator_with_args(ctx, &__args)
}

/// resource_conditional_accumulator with options.
pub fn resource_conditional_accumulator_with_args(
    ctx: &crate::eager::Context,
    __args: &ResourceConditionalAccumulator,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceConditionalAccumulator")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.reduction_type {
        op.set_attr_string("reduction_type", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResourceCountUpTo
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceCountUpTo {
    pub limit: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl ResourceCountUpTo {
    /// Creates a new `ResourceCountUpTo`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_count_up_to with default options.
pub fn resource_count_up_to<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResourceCountUpTo::new();
    resource_count_up_to_with_args(ctx, resource, &__args)
}

/// resource_count_up_to with options.
pub fn resource_count_up_to_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    __args: &ResourceCountUpTo,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceCountUpTo")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.limit {
        op.set_attr_int("limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResourceGather
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceGather {
    pub batch_dims: ::std::option::Option<i64>,
    pub validate_indices: ::std::option::Option<bool>,
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl ResourceGather {
    /// Creates a new `ResourceGather`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_gather with default options.
pub fn resource_gather<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResourceGather::new();
    resource_gather_with_args(ctx, resource, indices, &__args)
}

/// resource_gather with options.
pub fn resource_gather_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    __args: &ResourceGather,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceGather")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.batch_dims {
        op.set_attr_int("batch_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.validate_indices {
        op.set_attr_bool("validate_indices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResourceGatherNd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceGatherNd {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl ResourceGatherNd {
    /// Creates a new `ResourceGatherNd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_gather_nd with default options.
pub fn resource_gather_nd<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ResourceGatherNd::new();
    resource_gather_nd_with_args(ctx, resource, indices, &__args)
}

/// resource_gather_nd with options.
pub fn resource_gather_nd_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    __args: &ResourceGatherNd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceGatherNd")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ResourceScatterAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterAdd {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl ResourceScatterAdd {
    /// Creates a new `ResourceScatterAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_scatter_add with default options.
pub fn resource_scatter_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
) -> Result<()> {
    let __args = ResourceScatterAdd::new();
    resource_scatter_add_with_args(ctx, resource, indices, updates, &__args)
}

/// resource_scatter_add with options.
pub fn resource_scatter_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
    __args: &ResourceScatterAdd,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceScatterAdd")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceScatterDiv
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterDiv {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl ResourceScatterDiv {
    /// Creates a new `ResourceScatterDiv`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_scatter_div with default options.
pub fn resource_scatter_div<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
) -> Result<()> {
    let __args = ResourceScatterDiv::new();
    resource_scatter_div_with_args(ctx, resource, indices, updates, &__args)
}

/// resource_scatter_div with options.
pub fn resource_scatter_div_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
    __args: &ResourceScatterDiv,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceScatterDiv")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceScatterMax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterMax {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl ResourceScatterMax {
    /// Creates a new `ResourceScatterMax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_scatter_max with default options.
pub fn resource_scatter_max<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
) -> Result<()> {
    let __args = ResourceScatterMax::new();
    resource_scatter_max_with_args(ctx, resource, indices, updates, &__args)
}

/// resource_scatter_max with options.
pub fn resource_scatter_max_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
    __args: &ResourceScatterMax,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceScatterMax")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceScatterMin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterMin {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl ResourceScatterMin {
    /// Creates a new `ResourceScatterMin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_scatter_min with default options.
pub fn resource_scatter_min<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
) -> Result<()> {
    let __args = ResourceScatterMin::new();
    resource_scatter_min_with_args(ctx, resource, indices, updates, &__args)
}

/// resource_scatter_min with options.
pub fn resource_scatter_min_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
    __args: &ResourceScatterMin,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceScatterMin")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceScatterMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterMul {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl ResourceScatterMul {
    /// Creates a new `ResourceScatterMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_scatter_mul with default options.
pub fn resource_scatter_mul<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
) -> Result<()> {
    let __args = ResourceScatterMul::new();
    resource_scatter_mul_with_args(ctx, resource, indices, updates, &__args)
}

/// resource_scatter_mul with options.
pub fn resource_scatter_mul_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
    __args: &ResourceScatterMul,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceScatterMul")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceScatterNdAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterNdAdd {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceScatterNdAdd {
    /// Creates a new `ResourceScatterNdAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_scatter_nd_add with default options.
pub fn resource_scatter_nd_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<()> {
    let __args = ResourceScatterNdAdd::new();
    resource_scatter_nd_add_with_args(ctx, ref_, indices, updates, &__args)
}

/// resource_scatter_nd_add with options.
pub fn resource_scatter_nd_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ResourceScatterNdAdd,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceScatterNdAdd")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceScatterNdMax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterNdMax {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceScatterNdMax {
    /// Creates a new `ResourceScatterNdMax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_scatter_nd_max with default options.
pub fn resource_scatter_nd_max<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<()> {
    let __args = ResourceScatterNdMax::new();
    resource_scatter_nd_max_with_args(ctx, ref_, indices, updates, &__args)
}

/// resource_scatter_nd_max with options.
pub fn resource_scatter_nd_max_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ResourceScatterNdMax,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceScatterNdMax")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceScatterNdMin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterNdMin {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceScatterNdMin {
    /// Creates a new `ResourceScatterNdMin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_scatter_nd_min with default options.
pub fn resource_scatter_nd_min<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<()> {
    let __args = ResourceScatterNdMin::new();
    resource_scatter_nd_min_with_args(ctx, ref_, indices, updates, &__args)
}

/// resource_scatter_nd_min with options.
pub fn resource_scatter_nd_min_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ResourceScatterNdMin,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceScatterNdMin")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceScatterNdSub
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterNdSub {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceScatterNdSub {
    /// Creates a new `ResourceScatterNdSub`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_scatter_nd_sub with default options.
pub fn resource_scatter_nd_sub<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<()> {
    let __args = ResourceScatterNdSub::new();
    resource_scatter_nd_sub_with_args(ctx, ref_, indices, updates, &__args)
}

/// resource_scatter_nd_sub with options.
pub fn resource_scatter_nd_sub_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ResourceScatterNdSub,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceScatterNdSub")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceScatterNdUpdate
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterNdUpdate {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceScatterNdUpdate {
    /// Creates a new `ResourceScatterNdUpdate`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_scatter_nd_update with default options.
pub fn resource_scatter_nd_update<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<()> {
    let __args = ResourceScatterNdUpdate::new();
    resource_scatter_nd_update_with_args(ctx, ref_, indices, updates, &__args)
}

/// resource_scatter_nd_update with options.
pub fn resource_scatter_nd_update_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ResourceScatterNdUpdate,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceScatterNdUpdate")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceScatterSub
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterSub {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl ResourceScatterSub {
    /// Creates a new `ResourceScatterSub`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_scatter_sub with default options.
pub fn resource_scatter_sub<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
) -> Result<()> {
    let __args = ResourceScatterSub::new();
    resource_scatter_sub_with_args(ctx, resource, indices, updates, &__args)
}

/// resource_scatter_sub with options.
pub fn resource_scatter_sub_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
    __args: &ResourceScatterSub,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceScatterSub")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceScatterUpdate
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterUpdate {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl ResourceScatterUpdate {
    /// Creates a new `ResourceScatterUpdate`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_scatter_update with default options.
pub fn resource_scatter_update<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
) -> Result<()> {
    let __args = ResourceScatterUpdate::new();
    resource_scatter_update_with_args(ctx, resource, indices, updates, &__args)
}

/// resource_scatter_update with options.
pub fn resource_scatter_update_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    indices: T1,
    updates: T2,
    __args: &ResourceScatterUpdate,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceScatterUpdate")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceSparseApplyAdadelta
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyAdadelta {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceSparseApplyAdadelta {
    /// Creates a new `ResourceSparseApplyAdadelta`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_sparse_apply_adadelta with default options.
pub fn resource_sparse_apply_adadelta<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    accum_update: T2,
    lr: T3,
    rho: T4,
    epsilon: T5,
    grad: T6,
    indices: T7,
) -> Result<()> {
    let __args = ResourceSparseApplyAdadelta::new();
    resource_sparse_apply_adadelta_with_args(
        ctx,
        var,
        accum,
        accum_update,
        lr,
        rho,
        epsilon,
        grad,
        indices,
        &__args,
    )
}

/// resource_sparse_apply_adadelta with options.
pub fn resource_sparse_apply_adadelta_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    accum_update: T2,
    lr: T3,
    rho: T4,
    epsilon: T5,
    grad: T6,
    indices: T7,
    __args: &ResourceSparseApplyAdadelta,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceSparseApplyAdadelta")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&accum_update.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&rho.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceSparseApplyAdagrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyAdagrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub update_slots: ::std::option::Option<bool>,
}

impl ResourceSparseApplyAdagrad {
    /// Creates a new `ResourceSparseApplyAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_sparse_apply_adagrad with default options.
pub fn resource_sparse_apply_adagrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    indices: T4,
) -> Result<()> {
    let __args = ResourceSparseApplyAdagrad::new();
    resource_sparse_apply_adagrad_with_args(ctx, var, accum, lr, grad, indices, &__args)
}

/// resource_sparse_apply_adagrad with options.
pub fn resource_sparse_apply_adagrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    indices: T4,
    __args: &ResourceSparseApplyAdagrad,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceSparseApplyAdagrad")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.update_slots {
        op.set_attr_bool("update_slots", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceSparseApplyAdagradDA
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyAdagradDA {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceSparseApplyAdagradDA {
    /// Creates a new `ResourceSparseApplyAdagradDA`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_sparse_apply_adagrad_da with default options.
pub fn resource_sparse_apply_adagrad_da<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    gradient_accumulator: T1,
    gradient_squared_accumulator: T2,
    grad: T3,
    indices: T4,
    lr: T5,
    l1: T6,
    l2: T7,
    global_step: T8,
) -> Result<()> {
    let __args = ResourceSparseApplyAdagradDA::new();
    resource_sparse_apply_adagrad_da_with_args(
        ctx,
        var,
        gradient_accumulator,
        gradient_squared_accumulator,
        grad,
        indices,
        lr,
        l1,
        l2,
        global_step,
        &__args,
    )
}

/// resource_sparse_apply_adagrad_da with options.
pub fn resource_sparse_apply_adagrad_da_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    gradient_accumulator: T1,
    gradient_squared_accumulator: T2,
    grad: T3,
    indices: T4,
    lr: T5,
    l1: T6,
    l2: T7,
    global_step: T8,
    __args: &ResourceSparseApplyAdagradDA,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceSparseApplyAdagradDA")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&gradient_accumulator.to_handle()?)?;
    op.add_input(&gradient_squared_accumulator.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&global_step.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceSparseApplyAdagradV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyAdagradV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub update_slots: ::std::option::Option<bool>,
}

impl ResourceSparseApplyAdagradV2 {
    /// Creates a new `ResourceSparseApplyAdagradV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_sparse_apply_adagrad_v2 with default options.
pub fn resource_sparse_apply_adagrad_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    epsilon: T3,
    grad: T4,
    indices: T5,
) -> Result<()> {
    let __args = ResourceSparseApplyAdagradV2::new();
    resource_sparse_apply_adagrad_v2_with_args(ctx, var, accum, lr, epsilon, grad, indices, &__args)
}

/// resource_sparse_apply_adagrad_v2 with options.
pub fn resource_sparse_apply_adagrad_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    epsilon: T3,
    grad: T4,
    indices: T5,
    __args: &ResourceSparseApplyAdagradV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceSparseApplyAdagradV2")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.update_slots {
        op.set_attr_bool("update_slots", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceSparseApplyCenteredRMSProp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyCenteredRMSProp {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceSparseApplyCenteredRMSProp {
    /// Creates a new `ResourceSparseApplyCenteredRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_sparse_apply_centered_rmsprop with default options.
pub fn resource_sparse_apply_centered_rmsprop<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    mg: T1,
    ms: T2,
    mom: T3,
    lr: T4,
    rho: T5,
    momentum: T6,
    epsilon: T7,
    grad: T8,
    indices: T9,
) -> Result<()> {
    let __args = ResourceSparseApplyCenteredRMSProp::new();
    resource_sparse_apply_centered_rmsprop_with_args(
        ctx, var, mg, ms, mom, lr, rho, momentum, epsilon, grad, indices, &__args,
    )
}

/// resource_sparse_apply_centered_rmsprop with options.
pub fn resource_sparse_apply_centered_rmsprop_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    mg: T1,
    ms: T2,
    mom: T3,
    lr: T4,
    rho: T5,
    momentum: T6,
    epsilon: T7,
    grad: T8,
    indices: T9,
    __args: &ResourceSparseApplyCenteredRMSProp,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceSparseApplyCenteredRMSProp")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&mg.to_handle()?)?;
    op.add_input(&ms.to_handle()?)?;
    op.add_input(&mom.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&rho.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceSparseApplyFtrl
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyFtrl {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub multiply_linear_by_lr: ::std::option::Option<bool>,
}

impl ResourceSparseApplyFtrl {
    /// Creates a new `ResourceSparseApplyFtrl`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_sparse_apply_ftrl with default options.
pub fn resource_sparse_apply_ftrl<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    indices: T4,
    lr: T5,
    l1: T6,
    l2: T7,
    lr_power: T8,
) -> Result<()> {
    let __args = ResourceSparseApplyFtrl::new();
    resource_sparse_apply_ftrl_with_args(
        ctx, var, accum, linear, grad, indices, lr, l1, l2, lr_power, &__args,
    )
}

/// resource_sparse_apply_ftrl with options.
pub fn resource_sparse_apply_ftrl_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    indices: T4,
    lr: T5,
    l1: T6,
    l2: T7,
    lr_power: T8,
    __args: &ResourceSparseApplyFtrl,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceSparseApplyFtrl")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&linear.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&lr_power.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.multiply_linear_by_lr {
        op.set_attr_bool("multiply_linear_by_lr", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceSparseApplyFtrlV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyFtrlV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub multiply_linear_by_lr: ::std::option::Option<bool>,
}

impl ResourceSparseApplyFtrlV2 {
    /// Creates a new `ResourceSparseApplyFtrlV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_sparse_apply_ftrl_v2 with default options.
pub fn resource_sparse_apply_ftrl_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    indices: T4,
    lr: T5,
    l1: T6,
    l2: T7,
    l2_shrinkage: T8,
    lr_power: T9,
) -> Result<()> {
    let __args = ResourceSparseApplyFtrlV2::new();
    resource_sparse_apply_ftrl_v2_with_args(
        ctx,
        var,
        accum,
        linear,
        grad,
        indices,
        lr,
        l1,
        l2,
        l2_shrinkage,
        lr_power,
        &__args,
    )
}

/// resource_sparse_apply_ftrl_v2 with options.
pub fn resource_sparse_apply_ftrl_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    indices: T4,
    lr: T5,
    l1: T6,
    l2: T7,
    l2_shrinkage: T8,
    lr_power: T9,
    __args: &ResourceSparseApplyFtrlV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceSparseApplyFtrlV2")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&linear.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&l2_shrinkage.to_handle()?)?;
    op.add_input(&lr_power.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.multiply_linear_by_lr {
        op.set_attr_bool("multiply_linear_by_lr", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceSparseApplyKerasMomentum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyKerasMomentum {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub use_nesterov: ::std::option::Option<bool>,
}

impl ResourceSparseApplyKerasMomentum {
    /// Creates a new `ResourceSparseApplyKerasMomentum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_sparse_apply_keras_momentum with default options.
pub fn resource_sparse_apply_keras_momentum<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    indices: T4,
    momentum: T5,
) -> Result<()> {
    let __args = ResourceSparseApplyKerasMomentum::new();
    resource_sparse_apply_keras_momentum_with_args(
        ctx, var, accum, lr, grad, indices, momentum, &__args,
    )
}

/// resource_sparse_apply_keras_momentum with options.
pub fn resource_sparse_apply_keras_momentum_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    indices: T4,
    momentum: T5,
    __args: &ResourceSparseApplyKerasMomentum,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceSparseApplyKerasMomentum")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_nesterov {
        op.set_attr_bool("use_nesterov", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceSparseApplyMomentum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyMomentum {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub use_nesterov: ::std::option::Option<bool>,
}

impl ResourceSparseApplyMomentum {
    /// Creates a new `ResourceSparseApplyMomentum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_sparse_apply_momentum with default options.
pub fn resource_sparse_apply_momentum<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    indices: T4,
    momentum: T5,
) -> Result<()> {
    let __args = ResourceSparseApplyMomentum::new();
    resource_sparse_apply_momentum_with_args(ctx, var, accum, lr, grad, indices, momentum, &__args)
}

/// resource_sparse_apply_momentum with options.
pub fn resource_sparse_apply_momentum_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    indices: T4,
    momentum: T5,
    __args: &ResourceSparseApplyMomentum,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceSparseApplyMomentum")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_nesterov {
        op.set_attr_bool("use_nesterov", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceSparseApplyProximalAdagrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyProximalAdagrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceSparseApplyProximalAdagrad {
    /// Creates a new `ResourceSparseApplyProximalAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_sparse_apply_proximal_adagrad with default options.
pub fn resource_sparse_apply_proximal_adagrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    l1: T3,
    l2: T4,
    grad: T5,
    indices: T6,
) -> Result<()> {
    let __args = ResourceSparseApplyProximalAdagrad::new();
    resource_sparse_apply_proximal_adagrad_with_args(
        ctx, var, accum, lr, l1, l2, grad, indices, &__args,
    )
}

/// resource_sparse_apply_proximal_adagrad with options.
pub fn resource_sparse_apply_proximal_adagrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    l1: T3,
    l2: T4,
    grad: T5,
    indices: T6,
    __args: &ResourceSparseApplyProximalAdagrad,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceSparseApplyProximalAdagrad")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceSparseApplyProximalGradientDescent
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyProximalGradientDescent {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceSparseApplyProximalGradientDescent {
    /// Creates a new `ResourceSparseApplyProximalGradientDescent`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_sparse_apply_proximal_gradient_descent with default options.
pub fn resource_sparse_apply_proximal_gradient_descent<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    alpha: T1,
    l1: T2,
    l2: T3,
    grad: T4,
    indices: T5,
) -> Result<()> {
    let __args = ResourceSparseApplyProximalGradientDescent::new();
    resource_sparse_apply_proximal_gradient_descent_with_args(
        ctx, var, alpha, l1, l2, grad, indices, &__args,
    )
}

/// resource_sparse_apply_proximal_gradient_descent with options.
pub fn resource_sparse_apply_proximal_gradient_descent_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    alpha: T1,
    l1: T2,
    l2: T3,
    grad: T4,
    indices: T5,
    __args: &ResourceSparseApplyProximalGradientDescent,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceSparseApplyProximalGradientDescent")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&alpha.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceSparseApplyRMSProp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyRMSProp {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ResourceSparseApplyRMSProp {
    /// Creates a new `ResourceSparseApplyRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_sparse_apply_rmsprop with default options.
pub fn resource_sparse_apply_rmsprop<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    ms: T1,
    mom: T2,
    lr: T3,
    rho: T4,
    momentum: T5,
    epsilon: T6,
    grad: T7,
    indices: T8,
) -> Result<()> {
    let __args = ResourceSparseApplyRMSProp::new();
    resource_sparse_apply_rmsprop_with_args(
        ctx, var, ms, mom, lr, rho, momentum, epsilon, grad, indices, &__args,
    )
}

/// resource_sparse_apply_rmsprop with options.
pub fn resource_sparse_apply_rmsprop_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    ms: T1,
    mom: T2,
    lr: T3,
    rho: T4,
    momentum: T5,
    epsilon: T6,
    grad: T7,
    indices: T8,
    __args: &ResourceSparseApplyRMSProp,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceSparseApplyRMSProp")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&ms.to_handle()?)?;
    op.add_input(&mom.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&rho.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ResourceStridedSliceAssign
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceStridedSliceAssign {
    pub T: ::std::option::Option<crate::DataType>,
    pub Index: ::std::option::Option<crate::DataType>,
    pub begin_mask: ::std::option::Option<i64>,
    pub end_mask: ::std::option::Option<i64>,
    pub ellipsis_mask: ::std::option::Option<i64>,
    pub new_axis_mask: ::std::option::Option<i64>,
    pub shrink_axis_mask: ::std::option::Option<i64>,
}

impl ResourceStridedSliceAssign {
    /// Creates a new `ResourceStridedSliceAssign`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// resource_strided_slice_assign with default options.
pub fn resource_strided_slice_assign<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    begin: T1,
    end: T2,
    strides: T3,
    value: T4,
) -> Result<()> {
    let __args = ResourceStridedSliceAssign::new();
    resource_strided_slice_assign_with_args(ctx, ref_, begin, end, strides, value, &__args)
}

/// resource_strided_slice_assign with options.
pub fn resource_strided_slice_assign_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    begin: T1,
    end: T2,
    strides: T3,
    value: T4,
    __args: &ResourceStridedSliceAssign,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ResourceStridedSliceAssign")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&begin.to_handle()?)?;
    op.add_input(&end.to_handle()?)?;
    op.add_input(&strides.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Index {
        op.set_attr_type("Index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.begin_mask {
        op.set_attr_int("begin_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.end_mask {
        op.set_attr_int("end_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ellipsis_mask {
        op.set_attr_int("ellipsis_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.new_axis_mask {
        op.set_attr_int("new_axis_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shrink_axis_mask {
        op.set_attr_int("shrink_axis_mask", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Restore
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Restore {
    pub dt: ::std::option::Option<crate::DataType>,
    pub preferred_shard: ::std::option::Option<i64>,
}

impl Restore {
    /// Creates a new `Restore`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// restore with default options.
pub fn restore<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    file_pattern: T0,
    tensor_name: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Restore::new();
    restore_with_args(ctx, file_pattern, tensor_name, &__args)
}

/// restore with options.
pub fn restore_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    file_pattern: T0,
    tensor_name: T1,
    __args: &Restore,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Restore")?;

    // Required input arguments
    op.add_input(&file_pattern.to_handle()?)?;
    op.add_input(&tensor_name.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dt {
        op.set_attr_type("dt", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.preferred_shard {
        op.set_attr_int("preferred_shard", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RestoreSlice
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RestoreSlice {
    pub dt: ::std::option::Option<crate::DataType>,
    pub preferred_shard: ::std::option::Option<i64>,
}

impl RestoreSlice {
    /// Creates a new `RestoreSlice`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// restore_slice with default options.
pub fn restore_slice<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    file_pattern: T0,
    tensor_name: T1,
    shape_and_slice: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RestoreSlice::new();
    restore_slice_with_args(ctx, file_pattern, tensor_name, shape_and_slice, &__args)
}

/// restore_slice with options.
pub fn restore_slice_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    file_pattern: T0,
    tensor_name: T1,
    shape_and_slice: T2,
    __args: &RestoreSlice,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RestoreSlice")?;

    // Required input arguments
    op.add_input(&file_pattern.to_handle()?)?;
    op.add_input(&tensor_name.to_handle()?)?;
    op.add_input(&shape_and_slice.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dt {
        op.set_attr_type("dt", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.preferred_shard {
        op.set_attr_int("preferred_shard", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RestoreV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RestoreV2 {
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl RestoreV2 {
    /// Creates a new `RestoreV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// restore_v2 with default options.
pub fn restore_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    prefix: T0,
    tensor_names: T1,
    shape_and_slices: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RestoreV2::new();
    restore_v2_with_args(ctx, prefix, tensor_names, shape_and_slices, &__args)
}

/// restore_v2 with options.
pub fn restore_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    prefix: T0,
    tensor_names: T1,
    shape_and_slices: T2,
    __args: &RestoreV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RestoreV2")?;

    // Required input arguments
    op.add_input(&prefix.to_handle()?)?;
    op.add_input(&tensor_names.to_handle()?)?;
    op.add_input(&shape_and_slices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingADAMParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingADAMParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingADAMParameters {
    /// Creates a new `RetrieveTPUEmbeddingADAMParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_adamparameters with default options.
pub fn retrieve_tpuembedding_adamparameters(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = RetrieveTPUEmbeddingADAMParameters::new();
    retrieve_tpuembedding_adamparameters_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_adamparameters with options.
pub fn retrieve_tpuembedding_adamparameters_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingADAMParameters,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingADAMParameters")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingADAMParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingADAMParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_adamparameters_grad_accum_debug with default options.
pub fn retrieve_tpuembedding_adamparameters_grad_accum_debug(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = RetrieveTPUEmbeddingADAMParametersGradAccumDebug::new();
    retrieve_tpuembedding_adamparameters_grad_accum_debug_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_adamparameters_grad_accum_debug with options.
pub fn retrieve_tpuembedding_adamparameters_grad_accum_debug_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingADAMParametersGradAccumDebug,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingADAMParametersGradAccumDebug")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingAdadeltaParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingAdadeltaParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingAdadeltaParameters {
    /// Creates a new `RetrieveTPUEmbeddingAdadeltaParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_adadelta_parameters with default options.
pub fn retrieve_tpuembedding_adadelta_parameters(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = RetrieveTPUEmbeddingAdadeltaParameters::new();
    retrieve_tpuembedding_adadelta_parameters_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_adadelta_parameters with options.
pub fn retrieve_tpuembedding_adadelta_parameters_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingAdadeltaParameters,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingAdadeltaParameters")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_adadelta_parameters_grad_accum_debug with default options.
pub fn retrieve_tpuembedding_adadelta_parameters_grad_accum_debug(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug::new();
    retrieve_tpuembedding_adadelta_parameters_grad_accum_debug_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_adadelta_parameters_grad_accum_debug with options.
pub fn retrieve_tpuembedding_adadelta_parameters_grad_accum_debug_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op =
        crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingAdagradParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingAdagradParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingAdagradParameters {
    /// Creates a new `RetrieveTPUEmbeddingAdagradParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_adagrad_parameters with default options.
pub fn retrieve_tpuembedding_adagrad_parameters(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RetrieveTPUEmbeddingAdagradParameters::new();
    retrieve_tpuembedding_adagrad_parameters_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_adagrad_parameters with options.
pub fn retrieve_tpuembedding_adagrad_parameters_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingAdagradParameters,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingAdagradParameters")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingAdagradParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingAdagradParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_adagrad_parameters_grad_accum_debug with default options.
pub fn retrieve_tpuembedding_adagrad_parameters_grad_accum_debug(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = RetrieveTPUEmbeddingAdagradParametersGradAccumDebug::new();
    retrieve_tpuembedding_adagrad_parameters_grad_accum_debug_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_adagrad_parameters_grad_accum_debug with options.
pub fn retrieve_tpuembedding_adagrad_parameters_grad_accum_debug_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingAdagradParametersGradAccumDebug,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingAdagradParametersGradAccumDebug")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingCenteredRMSPropParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingCenteredRMSPropParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingCenteredRMSPropParameters {
    /// Creates a new `RetrieveTPUEmbeddingCenteredRMSPropParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_centered_rmsprop_parameters with default options.
pub fn retrieve_tpuembedding_centered_rmsprop_parameters(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = RetrieveTPUEmbeddingCenteredRMSPropParameters::new();
    retrieve_tpuembedding_centered_rmsprop_parameters_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_centered_rmsprop_parameters with options.
pub fn retrieve_tpuembedding_centered_rmsprop_parameters_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingCenteredRMSPropParameters,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingCenteredRMSPropParameters")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingFTRLParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingFTRLParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingFTRLParameters {
    /// Creates a new `RetrieveTPUEmbeddingFTRLParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_ftrlparameters with default options.
pub fn retrieve_tpuembedding_ftrlparameters(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = RetrieveTPUEmbeddingFTRLParameters::new();
    retrieve_tpuembedding_ftrlparameters_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_ftrlparameters with options.
pub fn retrieve_tpuembedding_ftrlparameters_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingFTRLParameters,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingFTRLParameters")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingFTRLParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingFTRLParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_ftrlparameters_grad_accum_debug with default options.
pub fn retrieve_tpuembedding_ftrlparameters_grad_accum_debug(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = RetrieveTPUEmbeddingFTRLParametersGradAccumDebug::new();
    retrieve_tpuembedding_ftrlparameters_grad_accum_debug_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_ftrlparameters_grad_accum_debug with options.
pub fn retrieve_tpuembedding_ftrlparameters_grad_accum_debug_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingFTRLParametersGradAccumDebug,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingFTRLParametersGradAccumDebug")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingFrequencyEstimatorParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingFrequencyEstimatorParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingFrequencyEstimatorParameters {
    /// Creates a new `RetrieveTPUEmbeddingFrequencyEstimatorParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_frequency_estimator_parameters with default options.
pub fn retrieve_tpuembedding_frequency_estimator_parameters(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RetrieveTPUEmbeddingFrequencyEstimatorParameters::new();
    retrieve_tpuembedding_frequency_estimator_parameters_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_frequency_estimator_parameters with options.
pub fn retrieve_tpuembedding_frequency_estimator_parameters_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingFrequencyEstimatorParameters,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingFrequencyEstimatorParameters")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_frequency_estimator_parameters_grad_accum_debug with default options.
pub fn retrieve_tpuembedding_frequency_estimator_parameters_grad_accum_debug(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = RetrieveTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug::new();
    retrieve_tpuembedding_frequency_estimator_parameters_grad_accum_debug_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_frequency_estimator_parameters_grad_accum_debug with options.
pub fn retrieve_tpuembedding_frequency_estimator_parameters_grad_accum_debug_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(
        ctx,
        "RetrieveTPUEmbeddingFrequencyEstimatorParametersGradAccumDebug",
    )?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingMDLAdagradLightParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingMDLAdagradLightParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingMDLAdagradLightParameters {
    /// Creates a new `RetrieveTPUEmbeddingMDLAdagradLightParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_mdladagrad_light_parameters with default options.
pub fn retrieve_tpuembedding_mdladagrad_light_parameters(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = RetrieveTPUEmbeddingMDLAdagradLightParameters::new();
    retrieve_tpuembedding_mdladagrad_light_parameters_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_mdladagrad_light_parameters with options.
pub fn retrieve_tpuembedding_mdladagrad_light_parameters_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingMDLAdagradLightParameters,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingMDLAdagradLightParameters")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingMomentumParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingMomentumParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingMomentumParameters {
    /// Creates a new `RetrieveTPUEmbeddingMomentumParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_momentum_parameters with default options.
pub fn retrieve_tpuembedding_momentum_parameters(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RetrieveTPUEmbeddingMomentumParameters::new();
    retrieve_tpuembedding_momentum_parameters_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_momentum_parameters with options.
pub fn retrieve_tpuembedding_momentum_parameters_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingMomentumParameters,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingMomentumParameters")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingMomentumParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingMomentumParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_momentum_parameters_grad_accum_debug with default options.
pub fn retrieve_tpuembedding_momentum_parameters_grad_accum_debug(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = RetrieveTPUEmbeddingMomentumParametersGradAccumDebug::new();
    retrieve_tpuembedding_momentum_parameters_grad_accum_debug_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_momentum_parameters_grad_accum_debug with options.
pub fn retrieve_tpuembedding_momentum_parameters_grad_accum_debug_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingMomentumParametersGradAccumDebug,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op =
        crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingMomentumParametersGradAccumDebug")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingProximalAdagradParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingProximalAdagradParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingProximalAdagradParameters {
    /// Creates a new `RetrieveTPUEmbeddingProximalAdagradParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_proximal_adagrad_parameters with default options.
pub fn retrieve_tpuembedding_proximal_adagrad_parameters(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RetrieveTPUEmbeddingProximalAdagradParameters::new();
    retrieve_tpuembedding_proximal_adagrad_parameters_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_proximal_adagrad_parameters with options.
pub fn retrieve_tpuembedding_proximal_adagrad_parameters_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingProximalAdagradParameters,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingProximalAdagradParameters")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_proximal_adagrad_parameters_grad_accum_debug with default options.
pub fn retrieve_tpuembedding_proximal_adagrad_parameters_grad_accum_debug(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug::new();
    retrieve_tpuembedding_proximal_adagrad_parameters_grad_accum_debug_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_proximal_adagrad_parameters_grad_accum_debug with options.
pub fn retrieve_tpuembedding_proximal_adagrad_parameters_grad_accum_debug_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(
        ctx,
        "RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug",
    )?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingProximalYogiParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingProximalYogiParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingProximalYogiParameters {
    /// Creates a new `RetrieveTPUEmbeddingProximalYogiParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_proximal_yogi_parameters with default options.
pub fn retrieve_tpuembedding_proximal_yogi_parameters(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = RetrieveTPUEmbeddingProximalYogiParameters::new();
    retrieve_tpuembedding_proximal_yogi_parameters_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_proximal_yogi_parameters with options.
pub fn retrieve_tpuembedding_proximal_yogi_parameters_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingProximalYogiParameters,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingProximalYogiParameters")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_proximal_yogi_parameters_grad_accum_debug with default options.
pub fn retrieve_tpuembedding_proximal_yogi_parameters_grad_accum_debug(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug::new();
    retrieve_tpuembedding_proximal_yogi_parameters_grad_accum_debug_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_proximal_yogi_parameters_grad_accum_debug with options.
pub fn retrieve_tpuembedding_proximal_yogi_parameters_grad_accum_debug_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(
        ctx,
        "RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug",
    )?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingRMSPropParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingRMSPropParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingRMSPropParameters {
    /// Creates a new `RetrieveTPUEmbeddingRMSPropParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_rmsprop_parameters with default options.
pub fn retrieve_tpuembedding_rmsprop_parameters(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = RetrieveTPUEmbeddingRMSPropParameters::new();
    retrieve_tpuembedding_rmsprop_parameters_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_rmsprop_parameters with options.
pub fn retrieve_tpuembedding_rmsprop_parameters_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingRMSPropParameters,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingRMSPropParameters")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_rmsprop_parameters_grad_accum_debug with default options.
pub fn retrieve_tpuembedding_rmsprop_parameters_grad_accum_debug(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug::new();
    retrieve_tpuembedding_rmsprop_parameters_grad_accum_debug_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_rmsprop_parameters_grad_accum_debug with options.
pub fn retrieve_tpuembedding_rmsprop_parameters_grad_accum_debug_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingStochasticGradientDescentParameters
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    /// Creates a new `RetrieveTPUEmbeddingStochasticGradientDescentParameters`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_stochastic_gradient_descent_parameters with default options.
pub fn retrieve_tpuembedding_stochastic_gradient_descent_parameters(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = RetrieveTPUEmbeddingStochasticGradientDescentParameters::new();
    retrieve_tpuembedding_stochastic_gradient_descent_parameters_with_args(ctx, &__args)
}

/// retrieve_tpuembedding_stochastic_gradient_descent_parameters with options.
pub fn retrieve_tpuembedding_stochastic_gradient_descent_parameters_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingStochasticGradientDescentParameters,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(
        ctx,
        "RetrieveTPUEmbeddingStochasticGradientDescentParameters",
    )?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug {
    pub table_id: ::std::option::Option<i64>,
    pub table_name: ::std::option::Option<::std::string::String>,
    pub num_shards: ::std::option::Option<i64>,
    pub shard_id: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// retrieve_tpuembedding_stochastic_gradient_descent_parameters_grad_accum_debug with default options.
pub fn retrieve_tpuembedding_stochastic_gradient_descent_parameters_grad_accum_debug(
    ctx: &crate::eager::Context,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug::new();
    retrieve_tpuembedding_stochastic_gradient_descent_parameters_grad_accum_debug_with_args(
        ctx, &__args,
    )
}

/// retrieve_tpuembedding_stochastic_gradient_descent_parameters_grad_accum_debug with options.
pub fn retrieve_tpuembedding_stochastic_gradient_descent_parameters_grad_accum_debug_with_args(
    ctx: &crate::eager::Context,
    __args: &RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(
        ctx,
        "RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug",
    )?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.table_name {
        op.set_attr_string("table_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_shards {
        op.set_attr_int("num_shards", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_id {
        op.set_attr_int("shard_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Reverse
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Reverse {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Reverse {
    /// Creates a new `Reverse`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reverse with default options.
pub fn reverse<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    dims: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Reverse::new();
    reverse_with_args(ctx, tensor, dims, &__args)
}

/// reverse with options.
pub fn reverse_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    dims: T1,
    __args: &Reverse,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Reverse")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&dims.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReverseSequence
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReverseSequence {
    pub seq_dim: ::std::option::Option<i64>,
    pub batch_dim: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tlen: ::std::option::Option<crate::DataType>,
}

impl ReverseSequence {
    /// Creates a new `ReverseSequence`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reverse_sequence with default options.
pub fn reverse_sequence<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    seq_lengths: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReverseSequence::new();
    reverse_sequence_with_args(ctx, input, seq_lengths, &__args)
}

/// reverse_sequence with options.
pub fn reverse_sequence_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    seq_lengths: T1,
    __args: &ReverseSequence,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReverseSequence")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&seq_lengths.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.seq_dim {
        op.set_attr_int("seq_dim", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.batch_dim {
        op.set_attr_int("batch_dim", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tlen {
        op.set_attr_type("Tlen", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ReverseV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReverseV2 {
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl ReverseV2 {
    /// Creates a new `ReverseV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// reverse_v2 with default options.
pub fn reverse_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    axis: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ReverseV2::new();
    reverse_v2_with_args(ctx, tensor, axis, &__args)
}

/// reverse_v2 with options.
pub fn reverse_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    axis: T1,
    __args: &ReverseV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ReverseV2")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RightShift
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RightShift {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RightShift {
    /// Creates a new `RightShift`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// right_shift with default options.
pub fn right_shift<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RightShift::new();
    right_shift_with_args(ctx, x, y, &__args)
}

/// right_shift with options.
pub fn right_shift_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RightShift,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RightShift")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Rint
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Rint {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Rint {
    /// Creates a new `Rint`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// rint with default options.
pub fn rint<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Rint::new();
    rint_with_args(ctx, x, &__args)
}

/// rint with options.
pub fn rint_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Rint,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Rint")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscAbs
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscAbs {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscAbs {
    /// Creates a new `RiscAbs`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_abs with default options.
pub fn risc_abs<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscAbs::new();
    risc_abs_with_args(ctx, x, &__args)
}

/// risc_abs with options.
pub fn risc_abs_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscAbs,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscAbs")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscAdd {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscAdd {
    /// Creates a new `RiscAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_add with default options.
pub fn risc_add<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscAdd::new();
    risc_add_with_args(ctx, x, y, &__args)
}

/// risc_add with options.
pub fn risc_add_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RiscAdd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscAdd")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscBinaryArithmetic
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscBinaryArithmetic {
    pub op_type: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscBinaryArithmetic {
    /// Creates a new `RiscBinaryArithmetic`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_binary_arithmetic with default options.
pub fn risc_binary_arithmetic<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscBinaryArithmetic::new();
    risc_binary_arithmetic_with_args(ctx, x, y, &__args)
}

/// risc_binary_arithmetic with options.
pub fn risc_binary_arithmetic_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RiscBinaryArithmetic,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscBinaryArithmetic")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.op_type {
        op.set_attr_string("op_type", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscBinaryComparison
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscBinaryComparison {
    pub op_type: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscBinaryComparison {
    /// Creates a new `RiscBinaryComparison`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_binary_comparison with default options.
pub fn risc_binary_comparison<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscBinaryComparison::new();
    risc_binary_comparison_with_args(ctx, x, y, &__args)
}

/// risc_binary_comparison with options.
pub fn risc_binary_comparison_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RiscBinaryComparison,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscBinaryComparison")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.op_type {
        op.set_attr_string("op_type", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscBitcast
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscBitcast {
    pub SrcT: ::std::option::Option<crate::DataType>,
    pub DstT: ::std::option::Option<crate::DataType>,
}

impl RiscBitcast {
    /// Creates a new `RiscBitcast`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_bitcast with default options.
pub fn risc_bitcast<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscBitcast::new();
    risc_bitcast_with_args(ctx, x, &__args)
}

/// risc_bitcast with options.
pub fn risc_bitcast_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscBitcast,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscBitcast")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.SrcT {
        op.set_attr_type("SrcT", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.DstT {
        op.set_attr_type("DstT", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscBroadcast
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscBroadcast {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl RiscBroadcast {
    /// Creates a new `RiscBroadcast`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_broadcast with default options.
pub fn risc_broadcast<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    shape: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscBroadcast::new();
    risc_broadcast_with_args(ctx, input, shape, &__args)
}

/// risc_broadcast with options.
pub fn risc_broadcast_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    shape: T1,
    __args: &RiscBroadcast,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscBroadcast")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscCast
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscCast {
    pub SrcT: ::std::option::Option<crate::DataType>,
    pub DstT: ::std::option::Option<crate::DataType>,
}

impl RiscCast {
    /// Creates a new `RiscCast`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_cast with default options.
pub fn risc_cast<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscCast::new();
    risc_cast_with_args(ctx, x, &__args)
}

/// risc_cast with options.
pub fn risc_cast_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscCast,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscCast")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.SrcT {
        op.set_attr_type("SrcT", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.DstT {
        op.set_attr_type("DstT", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscCeil
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscCeil {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscCeil {
    /// Creates a new `RiscCeil`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_ceil with default options.
pub fn risc_ceil<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscCeil::new();
    risc_ceil_with_args(ctx, x, &__args)
}

/// risc_ceil with options.
pub fn risc_ceil_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscCeil,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscCeil")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscCholesky
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscCholesky {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscCholesky {
    /// Creates a new `RiscCholesky`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_cholesky with default options.
pub fn risc_cholesky<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscCholesky::new();
    risc_cholesky_with_args(ctx, input, &__args)
}

/// risc_cholesky with options.
pub fn risc_cholesky_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &RiscCholesky,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscCholesky")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscConcat
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscConcat {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl RiscConcat {
    /// Creates a new `RiscConcat`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_concat with default options.
pub fn risc_concat<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    values: T0,
    axis: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscConcat::new();
    risc_concat_with_args(ctx, values, axis, &__args)
}

/// risc_concat with options.
pub fn risc_concat_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    values: T0,
    axis: T1,
    __args: &RiscConcat,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscConcat")?;

    // Required input arguments
    op.add_input(&values.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscCondition
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscCondition {
    pub func_true: ::std::option::Option<::std::string::String>,
    pub func_false: ::std::option::Option<::std::string::String>,
    pub SrcT: ::std::option::Option<crate::DataType>,
    pub DstT: ::std::option::Option<crate::DataType>,
}

impl RiscCondition {
    /// Creates a new `RiscCondition`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_condition with default options.
pub fn risc_condition<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    pred: T0,
    input_true: T1,
    input_false: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscCondition::new();
    risc_condition_with_args(ctx, pred, input_true, input_false, &__args)
}

/// risc_condition with options.
pub fn risc_condition_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    pred: T0,
    input_true: T1,
    input_false: T2,
    __args: &RiscCondition,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscCondition")?;

    // Required input arguments
    op.add_input(&pred.to_handle()?)?;
    op.add_input(&input_true.to_handle()?)?;
    op.add_input(&input_false.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.func_true {
        op.set_attr_string("func_true", value);
    }
    if let ::std::option::Option::Some(value) = &__args.func_false {
        op.set_attr_string("func_false", value);
    }
    if let ::std::option::Option::Some(value) = &__args.SrcT {
        op.set_attr_type("SrcT", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.DstT {
        op.set_attr_type("DstT", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscConv
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscConv {
    pub T: ::std::option::Option<crate::DataType>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub dilations: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl RiscConv {
    /// Creates a new `RiscConv`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_conv with default options.
pub fn risc_conv<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscConv::new();
    risc_conv_with_args(ctx, input, filter, &__args)
}

/// risc_conv with options.
pub fn risc_conv_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    filter: T1,
    __args: &RiscConv,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscConv")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&filter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dilations {
        op.set_attr_int_list("dilations", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscCos
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscCos {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscCos {
    /// Creates a new `RiscCos`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_cos with default options.
pub fn risc_cos<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscCos::new();
    risc_cos_with_args(ctx, x, &__args)
}

/// risc_cos with options.
pub fn risc_cos_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscCos,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscCos")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscDiv
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscDiv {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscDiv {
    /// Creates a new `RiscDiv`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_div with default options.
pub fn risc_div<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscDiv::new();
    risc_div_with_args(ctx, x, y, &__args)
}

/// risc_div with options.
pub fn risc_div_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RiscDiv,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscDiv")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscDot
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscDot {
    pub transpose_a: ::std::option::Option<bool>,
    pub transpose_b: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscDot {
    /// Creates a new `RiscDot`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_dot with default options.
pub fn risc_dot<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscDot::new();
    risc_dot_with_args(ctx, a, b, &__args)
}

/// risc_dot with options.
pub fn risc_dot_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    __args: &RiscDot,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscDot")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.transpose_a {
        op.set_attr_bool("transpose_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_b {
        op.set_attr_bool("transpose_b", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscExp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscExp {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscExp {
    /// Creates a new `RiscExp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_exp with default options.
pub fn risc_exp<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscExp::new();
    risc_exp_with_args(ctx, x, &__args)
}

/// risc_exp with options.
pub fn risc_exp_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscExp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscExp")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscFft
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscFft {
    pub Tcomplex: ::std::option::Option<crate::DataType>,
}

impl RiscFft {
    /// Creates a new `RiscFft`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_fft with default options.
pub fn risc_fft<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscFft::new();
    risc_fft_with_args(ctx, input, &__args)
}

/// risc_fft with options.
pub fn risc_fft_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &RiscFft,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscFft")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcomplex {
        op.set_attr_type("Tcomplex", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscFloor
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscFloor {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscFloor {
    /// Creates a new `RiscFloor`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_floor with default options.
pub fn risc_floor<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscFloor::new();
    risc_floor_with_args(ctx, x, &__args)
}

/// risc_floor with options.
pub fn risc_floor_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscFloor,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscFloor")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscGather
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscGather {
    pub batch_dims: ::std::option::Option<i64>,
    pub Tparams: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub Taxis: ::std::option::Option<crate::DataType>,
}

impl RiscGather {
    /// Creates a new `RiscGather`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_gather with default options.
pub fn risc_gather<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    params: T0,
    indices: T1,
    axis: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscGather::new();
    risc_gather_with_args(ctx, params, indices, axis, &__args)
}

/// risc_gather with options.
pub fn risc_gather_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    params: T0,
    indices: T1,
    axis: T2,
    __args: &RiscGather,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscGather")?;

    // Required input arguments
    op.add_input(&params.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.batch_dims {
        op.set_attr_int("batch_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tparams {
        op.set_attr_type("Tparams", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Taxis {
        op.set_attr_type("Taxis", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscImag
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscImag {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl RiscImag {
    /// Creates a new `RiscImag`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_imag with default options.
pub fn risc_imag<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscImag::new();
    risc_imag_with_args(ctx, input, &__args)
}

/// risc_imag with options.
pub fn risc_imag_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &RiscImag,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscImag")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscIsFinite
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscIsFinite {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscIsFinite {
    /// Creates a new `RiscIsFinite`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_is_finite with default options.
pub fn risc_is_finite<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscIsFinite::new();
    risc_is_finite_with_args(ctx, x, &__args)
}

/// risc_is_finite with options.
pub fn risc_is_finite_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscIsFinite,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscIsFinite")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscLog
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscLog {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscLog {
    /// Creates a new `RiscLog`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_log with default options.
pub fn risc_log<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscLog::new();
    risc_log_with_args(ctx, x, &__args)
}

/// risc_log with options.
pub fn risc_log_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscLog,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscLog")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscLogicalAnd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscLogicalAnd {}

impl RiscLogicalAnd {
    /// Creates a new `RiscLogicalAnd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_logical_and with default options.
pub fn risc_logical_and<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscLogicalAnd::new();
    risc_logical_and_with_args(ctx, x, y, &__args)
}

/// risc_logical_and with options.
pub fn risc_logical_and_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RiscLogicalAnd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscLogicalAnd")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscLogicalNot
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscLogicalNot {}

impl RiscLogicalNot {
    /// Creates a new `RiscLogicalNot`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_logical_not with default options.
pub fn risc_logical_not<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscLogicalNot::new();
    risc_logical_not_with_args(ctx, x, &__args)
}

/// risc_logical_not with options.
pub fn risc_logical_not_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscLogicalNot,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscLogicalNot")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscLogicalOr
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscLogicalOr {}

impl RiscLogicalOr {
    /// Creates a new `RiscLogicalOr`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_logical_or with default options.
pub fn risc_logical_or<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscLogicalOr::new();
    risc_logical_or_with_args(ctx, x, y, &__args)
}

/// risc_logical_or with options.
pub fn risc_logical_or_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RiscLogicalOr,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscLogicalOr")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscMax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscMax {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscMax {
    /// Creates a new `RiscMax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_max with default options.
pub fn risc_max<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscMax::new();
    risc_max_with_args(ctx, x, y, &__args)
}

/// risc_max with options.
pub fn risc_max_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RiscMax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscMax")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscMin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscMin {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscMin {
    /// Creates a new `RiscMin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_min with default options.
pub fn risc_min<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscMin::new();
    risc_min_with_args(ctx, x, y, &__args)
}

/// risc_min with options.
pub fn risc_min_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RiscMin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscMin")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscMul {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscMul {
    /// Creates a new `RiscMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_mul with default options.
pub fn risc_mul<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscMul::new();
    risc_mul_with_args(ctx, x, y, &__args)
}

/// risc_mul with options.
pub fn risc_mul_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RiscMul,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscMul")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscNeg
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscNeg {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscNeg {
    /// Creates a new `RiscNeg`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_neg with default options.
pub fn risc_neg<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscNeg::new();
    risc_neg_with_args(ctx, x, &__args)
}

/// risc_neg with options.
pub fn risc_neg_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscNeg,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscNeg")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscPad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscPad {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tpaddings: ::std::option::Option<crate::DataType>,
}

impl RiscPad {
    /// Creates a new `RiscPad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_pad with default options.
pub fn risc_pad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
    constant_values: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscPad::new();
    risc_pad_with_args(ctx, input, paddings, constant_values, &__args)
}

/// risc_pad with options.
pub fn risc_pad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
    constant_values: T2,
    __args: &RiscPad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscPad")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&paddings.to_handle()?)?;
    op.add_input(&constant_values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tpaddings {
        op.set_attr_type("Tpaddings", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscPool
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscPool {
    pub ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    pub strides: ::std::option::Option<::std::vec::Vec<i64>>,
    pub pooling_type: ::std::option::Option<::std::string::String>,
    pub data_format: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscPool {
    /// Creates a new `RiscPool`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_pool with default options.
pub fn risc_pool<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscPool::new();
    risc_pool_with_args(ctx, value, &__args)
}

/// risc_pool with options.
pub fn risc_pool_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
    __args: &RiscPool,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscPool")?;

    // Required input arguments
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.ksize {
        op.set_attr_int_list("ksize", value);
    }
    if let ::std::option::Option::Some(value) = &__args.strides {
        op.set_attr_int_list("strides", value);
    }
    if let ::std::option::Option::Some(value) = &__args.pooling_type {
        op.set_attr_string("pooling_type", value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscPow
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscPow {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscPow {
    /// Creates a new `RiscPow`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_pow with default options.
pub fn risc_pow<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscPow::new();
    risc_pow_with_args(ctx, x, y, &__args)
}

/// risc_pow with options.
pub fn risc_pow_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RiscPow,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscPow")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscRandomUniform
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscRandomUniform {
    pub seed: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscRandomUniform {
    /// Creates a new `RiscRandomUniform`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_random_uniform with default options.
pub fn risc_random_uniform<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscRandomUniform::new();
    risc_random_uniform_with_args(ctx, shape, &__args)
}

/// risc_random_uniform with options.
pub fn risc_random_uniform_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    __args: &RiscRandomUniform,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscRandomUniform")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscReal
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscReal {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tout: ::std::option::Option<crate::DataType>,
}

impl RiscReal {
    /// Creates a new `RiscReal`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_real with default options.
pub fn risc_real<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscReal::new();
    risc_real_with_args(ctx, input, &__args)
}

/// risc_real with options.
pub fn risc_real_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &RiscReal,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscReal")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type("Tout", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscReduce
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscReduce {
    pub reduce_type: ::std::option::Option<::std::string::String>,
    pub Index: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscReduce {
    /// Creates a new `RiscReduce`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_reduce with default options.
pub fn risc_reduce<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    axis: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscReduce::new();
    risc_reduce_with_args(ctx, tensor, axis, &__args)
}

/// risc_reduce with options.
pub fn risc_reduce_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    axis: T1,
    __args: &RiscReduce,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscReduce")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.reduce_type {
        op.set_attr_string("reduce_type", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Index {
        op.set_attr_type("Index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscRem
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscRem {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscRem {
    /// Creates a new `RiscRem`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_rem with default options.
pub fn risc_rem<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscRem::new();
    risc_rem_with_args(ctx, x, y, &__args)
}

/// risc_rem with options.
pub fn risc_rem_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RiscRem,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscRem")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscReshape
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscReshape {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tshape: ::std::option::Option<crate::DataType>,
}

impl RiscReshape {
    /// Creates a new `RiscReshape`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_reshape with default options.
pub fn risc_reshape<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    shape: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscReshape::new();
    risc_reshape_with_args(ctx, tensor, shape, &__args)
}

/// risc_reshape with options.
pub fn risc_reshape_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    shape: T1,
    __args: &RiscReshape,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscReshape")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshape {
        op.set_attr_type("Tshape", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscReverse
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscReverse {
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscReverse {
    /// Creates a new `RiscReverse`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_reverse with default options.
pub fn risc_reverse<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    axis: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscReverse::new();
    risc_reverse_with_args(ctx, tensor, axis, &__args)
}

/// risc_reverse with options.
pub fn risc_reverse_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    axis: T1,
    __args: &RiscReverse,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscReverse")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscScatter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscScatter {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl RiscScatter {
    /// Creates a new `RiscScatter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_scatter with default options.
pub fn risc_scatter<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    updates: T1,
    shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscScatter::new();
    risc_scatter_with_args(ctx, indices, updates, shape, &__args)
}

/// risc_scatter with options.
pub fn risc_scatter_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    updates: T1,
    shape: T2,
    __args: &RiscScatter,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscScatter")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscShape
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscShape {
    pub T: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl RiscShape {
    /// Creates a new `RiscShape`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_shape with default options.
pub fn risc_shape<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscShape::new();
    risc_shape_with_args(ctx, input, &__args)
}

/// risc_shape with options.
pub fn risc_shape_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &RiscShape,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscShape")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscSign
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscSign {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscSign {
    /// Creates a new `RiscSign`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_sign with default options.
pub fn risc_sign<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscSign::new();
    risc_sign_with_args(ctx, x, &__args)
}

/// risc_sign with options.
pub fn risc_sign_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscSign,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscSign")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscSlice
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscSlice {
    pub T: ::std::option::Option<crate::DataType>,
    pub Index: ::std::option::Option<crate::DataType>,
}

impl RiscSlice {
    /// Creates a new `RiscSlice`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_slice with default options.
pub fn risc_slice<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    begin: T1,
    size: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscSlice::new();
    risc_slice_with_args(ctx, input, begin, size, &__args)
}

/// risc_slice with options.
pub fn risc_slice_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    begin: T1,
    size: T2,
    __args: &RiscSlice,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscSlice")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&begin.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Index {
        op.set_attr_type("Index", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscSort
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscSort {
    pub Index: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub direction: ::std::option::Option<::std::string::String>,
}

impl RiscSort {
    /// Creates a new `RiscSort`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_sort with default options.
pub fn risc_sort<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    axis: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscSort::new();
    risc_sort_with_args(ctx, input, axis, &__args)
}

/// risc_sort with options.
pub fn risc_sort_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    axis: T1,
    __args: &RiscSort,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscSort")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Index {
        op.set_attr_type("Index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.direction {
        op.set_attr_string("direction", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscSqueeze
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscSqueeze {
    pub T: ::std::option::Option<crate::DataType>,
    pub squeeze_dims: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl RiscSqueeze {
    /// Creates a new `RiscSqueeze`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_squeeze with default options.
pub fn risc_squeeze<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscSqueeze::new();
    risc_squeeze_with_args(ctx, input, &__args)
}

/// risc_squeeze with options.
pub fn risc_squeeze_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &RiscSqueeze,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscSqueeze")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.squeeze_dims {
        op.set_attr_int_list("squeeze_dims", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscSub
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscSub {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscSub {
    /// Creates a new `RiscSub`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_sub with default options.
pub fn risc_sub<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscSub::new();
    risc_sub_with_args(ctx, x, y, &__args)
}

/// risc_sub with options.
pub fn risc_sub_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &RiscSub,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscSub")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscTranspose
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscTranspose {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tperm: ::std::option::Option<crate::DataType>,
}

impl RiscTranspose {
    /// Creates a new `RiscTranspose`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_transpose with default options.
pub fn risc_transpose<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    perm: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscTranspose::new();
    risc_transpose_with_args(ctx, x, perm, &__args)
}

/// risc_transpose with options.
pub fn risc_transpose_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    perm: T1,
    __args: &RiscTranspose,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscTranspose")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&perm.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tperm {
        op.set_attr_type("Tperm", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscTriangularSolve
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscTriangularSolve {
    pub lower: ::std::option::Option<bool>,
    pub adjoint: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscTriangularSolve {
    /// Creates a new `RiscTriangularSolve`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_triangular_solve with default options.
pub fn risc_triangular_solve<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscTriangularSolve::new();
    risc_triangular_solve_with_args(ctx, matrix, rhs, &__args)
}

/// risc_triangular_solve with options.
pub fn risc_triangular_solve_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    matrix: T0,
    rhs: T1,
    __args: &RiscTriangularSolve,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscTriangularSolve")?;

    // Required input arguments
    op.add_input(&matrix.to_handle()?)?;
    op.add_input(&rhs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.lower {
        op.set_attr_bool("lower", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adjoint {
        op.set_attr_bool("adjoint", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscUnary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscUnary {
    pub op_type: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl RiscUnary {
    /// Creates a new `RiscUnary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_unary with default options.
pub fn risc_unary<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscUnary::new();
    risc_unary_with_args(ctx, x, &__args)
}

/// risc_unary with options.
pub fn risc_unary_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &RiscUnary,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscUnary")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.op_type {
        op.set_attr_string("op_type", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RiscWhile
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RiscWhile {
    pub T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub cond: ::std::option::Option<::std::string::String>,
    pub body: ::std::option::Option<::std::string::String>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub parallel_iterations: ::std::option::Option<i64>,
}

impl RiscWhile {
    /// Creates a new `RiscWhile`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// risc_while with default options.
pub fn risc_while<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = RiscWhile::new();
    risc_while_with_args(ctx, input, &__args)
}

/// risc_while with options.
pub fn risc_while_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &RiscWhile,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RiscWhile")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type_list("T", value);
    }
    if let ::std::option::Option::Some(value) = &__args.cond {
        op.set_attr_string("cond", value);
    }
    if let ::std::option::Option::Some(value) = &__args.body {
        op.set_attr_string("body", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.parallel_iterations {
        op.set_attr_int("parallel_iterations", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RngReadAndSkip
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RngReadAndSkip {}

impl RngReadAndSkip {
    /// Creates a new `RngReadAndSkip`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// rng_read_and_skip with default options.
pub fn rng_read_and_skip<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    alg: T1,
    delta: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = RngReadAndSkip::new();
    rng_read_and_skip_with_args(ctx, resource, alg, delta, &__args)
}

/// rng_read_and_skip with options.
pub fn rng_read_and_skip_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    alg: T1,
    delta: T2,
    __args: &RngReadAndSkip,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RngReadAndSkip")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&alg.to_handle()?)?;
    op.add_input(&delta.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RngSkip
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RngSkip {}

impl RngSkip {
    /// Creates a new `RngSkip`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// rng_skip with default options.
pub fn rng_skip<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    delta: T2,
) -> Result<()> {
    let __args = RngSkip::new();
    rng_skip_with_args(ctx, resource, algorithm, delta, &__args)
}

/// rng_skip with options.
pub fn rng_skip_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    delta: T2,
    __args: &RngSkip,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RngSkip")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&algorithm.to_handle()?)?;
    op.add_input(&delta.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Roll
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Roll {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tshift: ::std::option::Option<crate::DataType>,
    pub Taxis: ::std::option::Option<crate::DataType>,
}

impl Roll {
    /// Creates a new `Roll`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// roll with default options.
pub fn roll<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle, T2: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    shift: T1,
    axis: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Roll::new();
    roll_with_args(ctx, input, shift, axis, &__args)
}

/// roll with options.
pub fn roll_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    shift: T1,
    axis: T2,
    __args: &Roll,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Roll")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&shift.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshift {
        op.set_attr_type("Tshift", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Taxis {
        op.set_attr_type("Taxis", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Round
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Round {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Round {
    /// Creates a new `Round`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// round with default options.
pub fn round<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Round::new();
    round_with_args(ctx, x, &__args)
}

/// round with options.
pub fn round_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Round,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Round")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Rsqrt
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Rsqrt {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Rsqrt {
    /// Creates a new `Rsqrt`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// rsqrt with default options.
pub fn rsqrt<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Rsqrt::new();
    rsqrt_with_args(ctx, x, &__args)
}

/// rsqrt with options.
pub fn rsqrt_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Rsqrt,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Rsqrt")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// RsqrtGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RsqrtGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl RsqrtGrad {
    /// Creates a new `RsqrtGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// rsqrt_grad with default options.
pub fn rsqrt_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    dy: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = RsqrtGrad::new();
    rsqrt_grad_with_args(ctx, y, dy, &__args)
}

/// rsqrt_grad with options.
pub fn rsqrt_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    dy: T1,
    __args: &RsqrtGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "RsqrtGrad")?;

    // Required input arguments
    op.add_input(&y.to_handle()?)?;
    op.add_input(&dy.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SampleDistortedBoundingBox
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SampleDistortedBoundingBox {
    pub T: ::std::option::Option<crate::DataType>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub min_object_covered: ::std::option::Option<f32>,
    pub aspect_ratio_range: ::std::option::Option<::std::vec::Vec<f32>>,
    pub area_range: ::std::option::Option<::std::vec::Vec<f32>>,
    pub max_attempts: ::std::option::Option<i64>,
    pub use_image_if_no_bounding_boxes: ::std::option::Option<bool>,
}

impl SampleDistortedBoundingBox {
    /// Creates a new `SampleDistortedBoundingBox`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sample_distorted_bounding_box with default options.
pub fn sample_distorted_bounding_box<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    image_size: T0,
    bounding_boxes: T1,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SampleDistortedBoundingBox::new();
    sample_distorted_bounding_box_with_args(ctx, image_size, bounding_boxes, &__args)
}

/// sample_distorted_bounding_box with options.
pub fn sample_distorted_bounding_box_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    image_size: T0,
    bounding_boxes: T1,
    __args: &SampleDistortedBoundingBox,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SampleDistortedBoundingBox")?;

    // Required input arguments
    op.add_input(&image_size.to_handle()?)?;
    op.add_input(&bounding_boxes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.min_object_covered {
        op.set_attr_float("min_object_covered", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.aspect_ratio_range {
        op.set_attr_float_list("aspect_ratio_range", value);
    }
    if let ::std::option::Option::Some(value) = &__args.area_range {
        op.set_attr_float_list("area_range", value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_attempts {
        op.set_attr_int("max_attempts", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_image_if_no_bounding_boxes {
        op.set_attr_bool("use_image_if_no_bounding_boxes", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SampleDistortedBoundingBoxV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SampleDistortedBoundingBoxV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub aspect_ratio_range: ::std::option::Option<::std::vec::Vec<f32>>,
    pub area_range: ::std::option::Option<::std::vec::Vec<f32>>,
    pub max_attempts: ::std::option::Option<i64>,
    pub use_image_if_no_bounding_boxes: ::std::option::Option<bool>,
}

impl SampleDistortedBoundingBoxV2 {
    /// Creates a new `SampleDistortedBoundingBoxV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sample_distorted_bounding_box_v2 with default options.
pub fn sample_distorted_bounding_box_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    image_size: T0,
    bounding_boxes: T1,
    min_object_covered: T2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SampleDistortedBoundingBoxV2::new();
    sample_distorted_bounding_box_v2_with_args(
        ctx,
        image_size,
        bounding_boxes,
        min_object_covered,
        &__args,
    )
}

/// sample_distorted_bounding_box_v2 with options.
pub fn sample_distorted_bounding_box_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    image_size: T0,
    bounding_boxes: T1,
    min_object_covered: T2,
    __args: &SampleDistortedBoundingBoxV2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SampleDistortedBoundingBoxV2")?;

    // Required input arguments
    op.add_input(&image_size.to_handle()?)?;
    op.add_input(&bounding_boxes.to_handle()?)?;
    op.add_input(&min_object_covered.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.aspect_ratio_range {
        op.set_attr_float_list("aspect_ratio_range", value);
    }
    if let ::std::option::Option::Some(value) = &__args.area_range {
        op.set_attr_float_list("area_range", value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_attempts {
        op.set_attr_int("max_attempts", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_image_if_no_bounding_boxes {
        op.set_attr_bool("use_image_if_no_bounding_boxes", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SamplingDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SamplingDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl SamplingDataset {
    /// Creates a new `SamplingDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sampling_dataset with default options.
pub fn sampling_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    rate: T1,
    seed: T2,
    seed2: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SamplingDataset::new();
    sampling_dataset_with_args(ctx, input_dataset, rate, seed, seed2, &__args)
}

/// sampling_dataset with options.
pub fn sampling_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    rate: T1,
    seed: T2,
    seed2: T3,
    __args: &SamplingDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SamplingDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&rate.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&seed2.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Save
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Save {
    pub T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl Save {
    /// Creates a new `Save`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// save with default options.
pub fn save<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle, T2: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    filename: T0,
    tensor_names: T1,
    data: T2,
) -> Result<()> {
    let __args = Save::new();
    save_with_args(ctx, filename, tensor_names, data, &__args)
}

/// save with options.
pub fn save_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filename: T0,
    tensor_names: T1,
    data: T2,
    __args: &Save,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Save")?;

    // Required input arguments
    op.add_input(&filename.to_handle()?)?;
    op.add_input(&tensor_names.to_handle()?)?;
    op.add_input(&data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type_list("T", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// SaveDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SaveDataset {
    pub compression: ::std::option::Option<::std::string::String>,
    pub shard_func: ::std::option::Option<::std::string::String>,
    pub use_shard_func: ::std::option::Option<bool>,
    pub Tshard_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl SaveDataset {
    /// Creates a new `SaveDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// save_dataset with default options.
pub fn save_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    path: T1,
    shard_func_other_args: T2,
) -> Result<()> {
    let __args = SaveDataset::new();
    save_dataset_with_args(ctx, input_dataset, path, shard_func_other_args, &__args)
}

/// save_dataset with options.
pub fn save_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    path: T1,
    shard_func_other_args: T2,
    __args: &SaveDataset,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SaveDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&path.to_handle()?)?;
    op.add_input(&shard_func_other_args.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.compression {
        op.set_attr_string("compression", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_func {
        op.set_attr_string("shard_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_shard_func {
        op.set_attr_bool("use_shard_func", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshard_func_args {
        op.set_attr_type_list("Tshard_func_args", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// SaveSlices
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SaveSlices {
    pub T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl SaveSlices {
    /// Creates a new `SaveSlices`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// save_slices with default options.
pub fn save_slices<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filename: T0,
    tensor_names: T1,
    shapes_and_slices: T2,
    data: T3,
) -> Result<()> {
    let __args = SaveSlices::new();
    save_slices_with_args(
        ctx,
        filename,
        tensor_names,
        shapes_and_slices,
        data,
        &__args,
    )
}

/// save_slices with options.
pub fn save_slices_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filename: T0,
    tensor_names: T1,
    shapes_and_slices: T2,
    data: T3,
    __args: &SaveSlices,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SaveSlices")?;

    // Required input arguments
    op.add_input(&filename.to_handle()?)?;
    op.add_input(&tensor_names.to_handle()?)?;
    op.add_input(&shapes_and_slices.to_handle()?)?;
    op.add_input(&data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type_list("T", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// SaveV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SaveV2 {
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl SaveV2 {
    /// Creates a new `SaveV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// save_v2 with default options.
pub fn save_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    prefix: T0,
    tensor_names: T1,
    shape_and_slices: T2,
    tensors: T3,
) -> Result<()> {
    let __args = SaveV2::new();
    save_v2_with_args(
        ctx,
        prefix,
        tensor_names,
        shape_and_slices,
        tensors,
        &__args,
    )
}

/// save_v2 with options.
pub fn save_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    prefix: T0,
    tensor_names: T1,
    shape_and_slices: T2,
    tensors: T3,
    __args: &SaveV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SaveV2")?;

    // Required input arguments
    op.add_input(&prefix.to_handle()?)?;
    op.add_input(&tensor_names.to_handle()?)?;
    op.add_input(&shape_and_slices.to_handle()?)?;
    op.add_input(&tensors.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// ScalarSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScalarSummary {
    pub T: ::std::option::Option<crate::DataType>,
}

impl ScalarSummary {
    /// Creates a new `ScalarSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scalar_summary with default options.
pub fn scalar_summary<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tags: T0,
    values: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScalarSummary::new();
    scalar_summary_with_args(ctx, tags, values, &__args)
}

/// scalar_summary with options.
pub fn scalar_summary_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tags: T0,
    values: T1,
    __args: &ScalarSummary,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScalarSummary")?;

    // Required input arguments
    op.add_input(&tags.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScaleAndTranslate
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScaleAndTranslate {
    pub T: ::std::option::Option<crate::DataType>,
    pub kernel_type: ::std::option::Option<::std::string::String>,
    pub antialias: ::std::option::Option<bool>,
}

impl ScaleAndTranslate {
    /// Creates a new `ScaleAndTranslate`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scale_and_translate with default options.
pub fn scale_and_translate<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    size: T1,
    scale: T2,
    translation: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScaleAndTranslate::new();
    scale_and_translate_with_args(ctx, images, size, scale, translation, &__args)
}

/// scale_and_translate with options.
pub fn scale_and_translate_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    images: T0,
    size: T1,
    scale: T2,
    translation: T3,
    __args: &ScaleAndTranslate,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScaleAndTranslate")?;

    // Required input arguments
    op.add_input(&images.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;
    op.add_input(&scale.to_handle()?)?;
    op.add_input(&translation.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.kernel_type {
        op.set_attr_string("kernel_type", value);
    }
    if let ::std::option::Option::Some(value) = &__args.antialias {
        op.set_attr_bool("antialias", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScaleAndTranslateGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScaleAndTranslateGrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub kernel_type: ::std::option::Option<::std::string::String>,
    pub antialias: ::std::option::Option<bool>,
}

impl ScaleAndTranslateGrad {
    /// Creates a new `ScaleAndTranslateGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scale_and_translate_grad with default options.
pub fn scale_and_translate_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grads: T0,
    original_image: T1,
    scale: T2,
    translation: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScaleAndTranslateGrad::new();
    scale_and_translate_grad_with_args(ctx, grads, original_image, scale, translation, &__args)
}

/// scale_and_translate_grad with options.
pub fn scale_and_translate_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grads: T0,
    original_image: T1,
    scale: T2,
    translation: T3,
    __args: &ScaleAndTranslateGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScaleAndTranslateGrad")?;

    // Required input arguments
    op.add_input(&grads.to_handle()?)?;
    op.add_input(&original_image.to_handle()?)?;
    op.add_input(&scale.to_handle()?)?;
    op.add_input(&translation.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.kernel_type {
        op.set_attr_string("kernel_type", value);
    }
    if let ::std::option::Option::Some(value) = &__args.antialias {
        op.set_attr_bool("antialias", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScanDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScanDataset {
    pub f: ::std::option::Option<::std::string::String>,
    pub Tstate: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub preserve_cardinality: ::std::option::Option<bool>,
    pub use_default_device: ::std::option::Option<bool>,
}

impl ScanDataset {
    /// Creates a new `ScanDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scan_dataset with default options.
pub fn scan_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    initial_state: T1,
    other_arguments: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScanDataset::new();
    scan_dataset_with_args(ctx, input_dataset, initial_state, other_arguments, &__args)
}

/// scan_dataset with options.
pub fn scan_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    initial_state: T1,
    other_arguments: T2,
    __args: &ScanDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScanDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&initial_state.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tstate {
        op.set_attr_type_list("Tstate", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.preserve_cardinality {
        op.set_attr_bool("preserve_cardinality", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_default_device {
        op.set_attr_bool("use_default_device", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterAdd {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ScatterAdd {
    /// Creates a new `ScatterAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_add with default options.
pub fn scatter_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterAdd::new();
    scatter_add_with_args(ctx, ref_, indices, updates, &__args)
}

/// scatter_add with options.
pub fn scatter_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterAdd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterAdd")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterDiv
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterDiv {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ScatterDiv {
    /// Creates a new `ScatterDiv`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_div with default options.
pub fn scatter_div<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterDiv::new();
    scatter_div_with_args(ctx, ref_, indices, updates, &__args)
}

/// scatter_div with options.
pub fn scatter_div_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterDiv,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterDiv")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterMax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterMax {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ScatterMax {
    /// Creates a new `ScatterMax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_max with default options.
pub fn scatter_max<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterMax::new();
    scatter_max_with_args(ctx, ref_, indices, updates, &__args)
}

/// scatter_max with options.
pub fn scatter_max_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterMax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterMax")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterMin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterMin {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ScatterMin {
    /// Creates a new `ScatterMin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_min with default options.
pub fn scatter_min<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterMin::new();
    scatter_min_with_args(ctx, ref_, indices, updates, &__args)
}

/// scatter_min with options.
pub fn scatter_min_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterMin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterMin")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterMul {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ScatterMul {
    /// Creates a new `ScatterMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_mul with default options.
pub fn scatter_mul<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterMul::new();
    scatter_mul_with_args(ctx, ref_, indices, updates, &__args)
}

/// scatter_mul with options.
pub fn scatter_mul_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterMul,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterMul")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterNd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNd {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl ScatterNd {
    /// Creates a new `ScatterNd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_nd with default options.
pub fn scatter_nd<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    updates: T1,
    shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterNd::new();
    scatter_nd_with_args(ctx, indices, updates, shape, &__args)
}

/// scatter_nd with options.
pub fn scatter_nd_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    updates: T1,
    shape: T2,
    __args: &ScatterNd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterNd")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterNdAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNdAdd {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ScatterNdAdd {
    /// Creates a new `ScatterNdAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_nd_add with default options.
pub fn scatter_nd_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterNdAdd::new();
    scatter_nd_add_with_args(ctx, ref_, indices, updates, &__args)
}

/// scatter_nd_add with options.
pub fn scatter_nd_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterNdAdd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterNdAdd")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterNdMax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNdMax {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ScatterNdMax {
    /// Creates a new `ScatterNdMax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_nd_max with default options.
pub fn scatter_nd_max<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterNdMax::new();
    scatter_nd_max_with_args(ctx, ref_, indices, updates, &__args)
}

/// scatter_nd_max with options.
pub fn scatter_nd_max_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterNdMax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterNdMax")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterNdMin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNdMin {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ScatterNdMin {
    /// Creates a new `ScatterNdMin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_nd_min with default options.
pub fn scatter_nd_min<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterNdMin::new();
    scatter_nd_min_with_args(ctx, ref_, indices, updates, &__args)
}

/// scatter_nd_min with options.
pub fn scatter_nd_min_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterNdMin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterNdMin")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterNdNonAliasingAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNdNonAliasingAdd {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl ScatterNdNonAliasingAdd {
    /// Creates a new `ScatterNdNonAliasingAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_nd_non_aliasing_add with default options.
pub fn scatter_nd_non_aliasing_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterNdNonAliasingAdd::new();
    scatter_nd_non_aliasing_add_with_args(ctx, input, indices, updates, &__args)
}

/// scatter_nd_non_aliasing_add with options.
pub fn scatter_nd_non_aliasing_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterNdNonAliasingAdd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterNdNonAliasingAdd")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterNdSub
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNdSub {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ScatterNdSub {
    /// Creates a new `ScatterNdSub`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_nd_sub with default options.
pub fn scatter_nd_sub<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterNdSub::new();
    scatter_nd_sub_with_args(ctx, ref_, indices, updates, &__args)
}

/// scatter_nd_sub with options.
pub fn scatter_nd_sub_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterNdSub,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterNdSub")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterNdUpdate
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNdUpdate {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ScatterNdUpdate {
    /// Creates a new `ScatterNdUpdate`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_nd_update with default options.
pub fn scatter_nd_update<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterNdUpdate::new();
    scatter_nd_update_with_args(ctx, ref_, indices, updates, &__args)
}

/// scatter_nd_update with options.
pub fn scatter_nd_update_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterNdUpdate,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterNdUpdate")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterSub
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterSub {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ScatterSub {
    /// Creates a new `ScatterSub`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_sub with default options.
pub fn scatter_sub<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterSub::new();
    scatter_sub_with_args(ctx, ref_, indices, updates, &__args)
}

/// scatter_sub with options.
pub fn scatter_sub_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterSub,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterSub")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ScatterUpdate
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterUpdate {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl ScatterUpdate {
    /// Creates a new `ScatterUpdate`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// scatter_update with default options.
pub fn scatter_update<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ScatterUpdate::new();
    scatter_update_with_args(ctx, ref_, indices, updates, &__args)
}

/// scatter_update with options.
pub fn scatter_update_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    indices: T1,
    updates: T2,
    __args: &ScatterUpdate,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ScatterUpdate")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SdcaFprint
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SdcaFprint {}

impl SdcaFprint {
    /// Creates a new `SdcaFprint`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sdca_fprint with default options.
pub fn sdca_fprint<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = SdcaFprint::new();
    sdca_fprint_with_args(ctx, input, &__args)
}

/// sdca_fprint with options.
pub fn sdca_fprint_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &SdcaFprint,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SdcaFprint")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SdcaOptimizer
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SdcaOptimizer {
    pub loss_type: ::std::option::Option<::std::string::String>,
    pub adaptative: ::std::option::Option<bool>,
    pub num_sparse_features: ::std::option::Option<i64>,
    pub num_sparse_features_with_values: ::std::option::Option<i64>,
    pub num_dense_features: ::std::option::Option<i64>,
    pub l1: ::std::option::Option<f32>,
    pub l2: ::std::option::Option<f32>,
    pub num_loss_partitions: ::std::option::Option<i64>,
    pub num_inner_iterations: ::std::option::Option<i64>,
}

impl SdcaOptimizer {
    /// Creates a new `SdcaOptimizer`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sdca_optimizer with default options.
pub fn sdca_optimizer<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_example_indices: T0,
    sparse_feature_indices: T1,
    sparse_feature_values: T2,
    dense_features: T3,
    example_weights: T4,
    example_labels: T5,
    sparse_indices: T6,
    sparse_weights: T7,
    dense_weights: T8,
    example_state_data: T9,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SdcaOptimizer::new();
    sdca_optimizer_with_args(
        ctx,
        sparse_example_indices,
        sparse_feature_indices,
        sparse_feature_values,
        dense_features,
        example_weights,
        example_labels,
        sparse_indices,
        sparse_weights,
        dense_weights,
        example_state_data,
        &__args,
    )
}

/// sdca_optimizer with options.
pub fn sdca_optimizer_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_example_indices: T0,
    sparse_feature_indices: T1,
    sparse_feature_values: T2,
    dense_features: T3,
    example_weights: T4,
    example_labels: T5,
    sparse_indices: T6,
    sparse_weights: T7,
    dense_weights: T8,
    example_state_data: T9,
    __args: &SdcaOptimizer,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SdcaOptimizer")?;

    // Required input arguments
    op.add_input(&sparse_example_indices.to_handle()?)?;
    op.add_input(&sparse_feature_indices.to_handle()?)?;
    op.add_input(&sparse_feature_values.to_handle()?)?;
    op.add_input(&dense_features.to_handle()?)?;
    op.add_input(&example_weights.to_handle()?)?;
    op.add_input(&example_labels.to_handle()?)?;
    op.add_input(&sparse_indices.to_handle()?)?;
    op.add_input(&sparse_weights.to_handle()?)?;
    op.add_input(&dense_weights.to_handle()?)?;
    op.add_input(&example_state_data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.loss_type {
        op.set_attr_string("loss_type", value);
    }
    if let ::std::option::Option::Some(value) = &__args.adaptative {
        op.set_attr_bool("adaptative", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_sparse_features {
        op.set_attr_int("num_sparse_features", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_sparse_features_with_values {
        op.set_attr_int("num_sparse_features_with_values", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_dense_features {
        op.set_attr_int("num_dense_features", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.l1 {
        op.set_attr_float("l1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.l2 {
        op.set_attr_float("l2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_loss_partitions {
        op.set_attr_int("num_loss_partitions", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_inner_iterations {
        op.set_attr_int("num_inner_iterations", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SdcaOptimizerV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SdcaOptimizerV2 {
    pub loss_type: ::std::option::Option<::std::string::String>,
    pub adaptive: ::std::option::Option<bool>,
    pub num_sparse_features: ::std::option::Option<i64>,
    pub num_sparse_features_with_values: ::std::option::Option<i64>,
    pub num_dense_features: ::std::option::Option<i64>,
    pub l1: ::std::option::Option<f32>,
    pub l2: ::std::option::Option<f32>,
    pub num_loss_partitions: ::std::option::Option<i64>,
    pub num_inner_iterations: ::std::option::Option<i64>,
}

impl SdcaOptimizerV2 {
    /// Creates a new `SdcaOptimizerV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sdca_optimizer_v2 with default options.
pub fn sdca_optimizer_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_example_indices: T0,
    sparse_feature_indices: T1,
    sparse_feature_values: T2,
    dense_features: T3,
    example_weights: T4,
    example_labels: T5,
    sparse_indices: T6,
    sparse_weights: T7,
    dense_weights: T8,
    example_state_data: T9,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SdcaOptimizerV2::new();
    sdca_optimizer_v2_with_args(
        ctx,
        sparse_example_indices,
        sparse_feature_indices,
        sparse_feature_values,
        dense_features,
        example_weights,
        example_labels,
        sparse_indices,
        sparse_weights,
        dense_weights,
        example_state_data,
        &__args,
    )
}

/// sdca_optimizer_v2 with options.
pub fn sdca_optimizer_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_example_indices: T0,
    sparse_feature_indices: T1,
    sparse_feature_values: T2,
    dense_features: T3,
    example_weights: T4,
    example_labels: T5,
    sparse_indices: T6,
    sparse_weights: T7,
    dense_weights: T8,
    example_state_data: T9,
    __args: &SdcaOptimizerV2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SdcaOptimizerV2")?;

    // Required input arguments
    op.add_input(&sparse_example_indices.to_handle()?)?;
    op.add_input(&sparse_feature_indices.to_handle()?)?;
    op.add_input(&sparse_feature_values.to_handle()?)?;
    op.add_input(&dense_features.to_handle()?)?;
    op.add_input(&example_weights.to_handle()?)?;
    op.add_input(&example_labels.to_handle()?)?;
    op.add_input(&sparse_indices.to_handle()?)?;
    op.add_input(&sparse_weights.to_handle()?)?;
    op.add_input(&dense_weights.to_handle()?)?;
    op.add_input(&example_state_data.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.loss_type {
        op.set_attr_string("loss_type", value);
    }
    if let ::std::option::Option::Some(value) = &__args.adaptive {
        op.set_attr_bool("adaptive", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_sparse_features {
        op.set_attr_int("num_sparse_features", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_sparse_features_with_values {
        op.set_attr_int("num_sparse_features_with_values", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_dense_features {
        op.set_attr_int("num_dense_features", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.l1 {
        op.set_attr_float("l1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.l2 {
        op.set_attr_float("l2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_loss_partitions {
        op.set_attr_int("num_loss_partitions", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_inner_iterations {
        op.set_attr_int("num_inner_iterations", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SdcaShrinkL1
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SdcaShrinkL1 {
    pub num_features: ::std::option::Option<i64>,
    pub l1: ::std::option::Option<f32>,
    pub l2: ::std::option::Option<f32>,
}

impl SdcaShrinkL1 {
    /// Creates a new `SdcaShrinkL1`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sdca_shrink_l1 with default options.
pub fn sdca_shrink_l1<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    weights: T0,
) -> Result<()> {
    let __args = SdcaShrinkL1::new();
    sdca_shrink_l1_with_args(ctx, weights, &__args)
}

/// sdca_shrink_l1 with options.
pub fn sdca_shrink_l1_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    weights: T0,
    __args: &SdcaShrinkL1,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SdcaShrinkL1")?;

    // Required input arguments
    op.add_input(&weights.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_features {
        op.set_attr_int("num_features", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.l1 {
        op.set_attr_float("l1", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.l2 {
        op.set_attr_float("l2", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// SegmentMax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SegmentMax {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl SegmentMax {
    /// Creates a new `SegmentMax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// segment_max with default options.
pub fn segment_max<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SegmentMax::new();
    segment_max_with_args(ctx, data, segment_ids, &__args)
}

/// segment_max with options.
pub fn segment_max_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    __args: &SegmentMax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SegmentMax")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SegmentMean
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SegmentMean {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl SegmentMean {
    /// Creates a new `SegmentMean`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// segment_mean with default options.
pub fn segment_mean<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SegmentMean::new();
    segment_mean_with_args(ctx, data, segment_ids, &__args)
}

/// segment_mean with options.
pub fn segment_mean_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    __args: &SegmentMean,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SegmentMean")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SegmentMin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SegmentMin {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl SegmentMin {
    /// Creates a new `SegmentMin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// segment_min with default options.
pub fn segment_min<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SegmentMin::new();
    segment_min_with_args(ctx, data, segment_ids, &__args)
}

/// segment_min with options.
pub fn segment_min_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    __args: &SegmentMin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SegmentMin")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SegmentProd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SegmentProd {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl SegmentProd {
    /// Creates a new `SegmentProd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// segment_prod with default options.
pub fn segment_prod<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SegmentProd::new();
    segment_prod_with_args(ctx, data, segment_ids, &__args)
}

/// segment_prod with options.
pub fn segment_prod_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    __args: &SegmentProd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SegmentProd")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SegmentSum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SegmentSum {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl SegmentSum {
    /// Creates a new `SegmentSum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// segment_sum with default options.
pub fn segment_sum<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SegmentSum::new();
    segment_sum_with_args(ctx, data, segment_ids, &__args)
}

/// segment_sum with options.
pub fn segment_sum_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    __args: &SegmentSum,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SegmentSum")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Select
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Select {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Select {
    /// Creates a new `Select`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// select with default options.
pub fn select<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    condition: T0,
    t: T1,
    e: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Select::new();
    select_with_args(ctx, condition, t, e, &__args)
}

/// select with options.
pub fn select_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    condition: T0,
    t: T1,
    e: T2,
    __args: &Select,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Select")?;

    // Required input arguments
    op.add_input(&condition.to_handle()?)?;
    op.add_input(&t.to_handle()?)?;
    op.add_input(&e.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SelectV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SelectV2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SelectV2 {
    /// Creates a new `SelectV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// select_v2 with default options.
pub fn select_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    condition: T0,
    t: T1,
    e: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SelectV2::new();
    select_v2_with_args(ctx, condition, t, e, &__args)
}

/// select_v2 with options.
pub fn select_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    condition: T0,
    t: T1,
    e: T2,
    __args: &SelectV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SelectV2")?;

    // Required input arguments
    op.add_input(&condition.to_handle()?)?;
    op.add_input(&t.to_handle()?)?;
    op.add_input(&e.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SelfAdjointEig
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SelfAdjointEig {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SelfAdjointEig {
    /// Creates a new `SelfAdjointEig`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// self_adjoint_eig with default options.
pub fn self_adjoint_eig<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = SelfAdjointEig::new();
    self_adjoint_eig_with_args(ctx, input, &__args)
}

/// self_adjoint_eig with options.
pub fn self_adjoint_eig_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &SelfAdjointEig,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SelfAdjointEig")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SelfAdjointEigV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SelfAdjointEigV2 {
    pub compute_v: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl SelfAdjointEigV2 {
    /// Creates a new `SelfAdjointEigV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// self_adjoint_eig_v2 with default options.
pub fn self_adjoint_eig_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = SelfAdjointEigV2::new();
    self_adjoint_eig_v2_with_args(ctx, input, &__args)
}

/// self_adjoint_eig_v2 with options.
pub fn self_adjoint_eig_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &SelfAdjointEigV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SelfAdjointEigV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.compute_v {
        op.set_attr_bool("compute_v", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Selu
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Selu {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Selu {
    /// Creates a new `Selu`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// selu with default options.
pub fn selu<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Selu::new();
    selu_with_args(ctx, features, &__args)
}

/// selu with options.
pub fn selu_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
    __args: &Selu,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Selu")?;

    // Required input arguments
    op.add_input(&features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SeluGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SeluGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SeluGrad {
    /// Creates a new `SeluGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// selu_grad with default options.
pub fn selu_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    outputs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SeluGrad::new();
    selu_grad_with_args(ctx, gradients, outputs, &__args)
}

/// selu_grad with options.
pub fn selu_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    outputs: T1,
    __args: &SeluGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SeluGrad")?;

    // Required input arguments
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&outputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Send
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Send {
    pub T: ::std::option::Option<crate::DataType>,
    pub tensor_name: ::std::option::Option<::std::string::String>,
    pub send_device: ::std::option::Option<::std::string::String>,
    pub send_device_incarnation: ::std::option::Option<i64>,
    pub recv_device: ::std::option::Option<::std::string::String>,
    pub client_terminated: ::std::option::Option<bool>,
}

impl Send {
    /// Creates a new `Send`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// send with default options.
pub fn send<T0: crate::eager::ToHandle>(ctx: &crate::eager::Context, tensor: T0) -> Result<()> {
    let __args = Send::new();
    send_with_args(ctx, tensor, &__args)
}

/// send with options.
pub fn send_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    __args: &Send,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Send")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_name {
        op.set_attr_string("tensor_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.send_device {
        op.set_attr_string("send_device", value);
    }
    if let ::std::option::Option::Some(value) = &__args.send_device_incarnation {
        op.set_attr_int("send_device_incarnation", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.recv_device {
        op.set_attr_string("recv_device", value);
    }
    if let ::std::option::Option::Some(value) = &__args.client_terminated {
        op.set_attr_bool("client_terminated", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// SendTPUEmbeddingGradients
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SendTPUEmbeddingGradients {
    pub N: ::std::option::Option<i64>,
    pub NN: ::std::option::Option<i64>,
    pub config: ::std::option::Option<::std::string::String>,
}

impl SendTPUEmbeddingGradients {
    /// Creates a new `SendTPUEmbeddingGradients`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// send_tpuembedding_gradients with default options.
pub fn send_tpuembedding_gradients<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    learning_rates: T1,
) -> Result<()> {
    let __args = SendTPUEmbeddingGradients::new();
    send_tpuembedding_gradients_with_args(ctx, inputs, learning_rates, &__args)
}

/// send_tpuembedding_gradients with options.
pub fn send_tpuembedding_gradients_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    inputs: T0,
    learning_rates: T1,
    __args: &SendTPUEmbeddingGradients,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SendTPUEmbeddingGradients")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;
    op.add_input(&learning_rates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.NN {
        op.set_attr_int("NN", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// SerializeIterator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SerializeIterator {
    pub external_state_policy: ::std::option::Option<i64>,
}

impl SerializeIterator {
    /// Creates a new `SerializeIterator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// serialize_iterator with default options.
pub fn serialize_iterator<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = SerializeIterator::new();
    serialize_iterator_with_args(ctx, resource_handle, &__args)
}

/// serialize_iterator with options.
pub fn serialize_iterator_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource_handle: T0,
    __args: &SerializeIterator,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SerializeIterator")?;

    // Required input arguments
    op.add_input(&resource_handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.external_state_policy {
        op.set_attr_int("external_state_policy", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SerializeManySparse
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SerializeManySparse {
    pub T: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl SerializeManySparse {
    /// Creates a new `SerializeManySparse`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// serialize_many_sparse with default options.
pub fn serialize_many_sparse<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_indices: T0,
    sparse_values: T1,
    sparse_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SerializeManySparse::new();
    serialize_many_sparse_with_args(ctx, sparse_indices, sparse_values, sparse_shape, &__args)
}

/// serialize_many_sparse with options.
pub fn serialize_many_sparse_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_indices: T0,
    sparse_values: T1,
    sparse_shape: T2,
    __args: &SerializeManySparse,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SerializeManySparse")?;

    // Required input arguments
    op.add_input(&sparse_indices.to_handle()?)?;
    op.add_input(&sparse_values.to_handle()?)?;
    op.add_input(&sparse_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SerializeSparse
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SerializeSparse {
    pub T: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl SerializeSparse {
    /// Creates a new `SerializeSparse`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// serialize_sparse with default options.
pub fn serialize_sparse<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_indices: T0,
    sparse_values: T1,
    sparse_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SerializeSparse::new();
    serialize_sparse_with_args(ctx, sparse_indices, sparse_values, sparse_shape, &__args)
}

/// serialize_sparse with options.
pub fn serialize_sparse_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_indices: T0,
    sparse_values: T1,
    sparse_shape: T2,
    __args: &SerializeSparse,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SerializeSparse")?;

    // Required input arguments
    op.add_input(&sparse_indices.to_handle()?)?;
    op.add_input(&sparse_values.to_handle()?)?;
    op.add_input(&sparse_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SerializeTensor
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SerializeTensor {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SerializeTensor {
    /// Creates a new `SerializeTensor`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// serialize_tensor with default options.
pub fn serialize_tensor<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = SerializeTensor::new();
    serialize_tensor_with_args(ctx, tensor, &__args)
}

/// serialize_tensor with options.
pub fn serialize_tensor_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    __args: &SerializeTensor,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SerializeTensor")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SetSize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SetSize {
    pub validate_indices: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl SetSize {
    /// Creates a new `SetSize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// set_size with default options.
pub fn set_size<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    set_indices: T0,
    set_values: T1,
    set_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SetSize::new();
    set_size_with_args(ctx, set_indices, set_values, set_shape, &__args)
}

/// set_size with options.
pub fn set_size_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    set_indices: T0,
    set_values: T1,
    set_shape: T2,
    __args: &SetSize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SetSize")?;

    // Required input arguments
    op.add_input(&set_indices.to_handle()?)?;
    op.add_input(&set_values.to_handle()?)?;
    op.add_input(&set_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.validate_indices {
        op.set_attr_bool("validate_indices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SetStatsAggregatorDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SetStatsAggregatorDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl SetStatsAggregatorDataset {
    /// Creates a new `SetStatsAggregatorDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// set_stats_aggregator_dataset with default options.
pub fn set_stats_aggregator_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    stats_aggregator: T1,
    tag: T2,
    counter_prefix: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SetStatsAggregatorDataset::new();
    set_stats_aggregator_dataset_with_args(
        ctx,
        input_dataset,
        stats_aggregator,
        tag,
        counter_prefix,
        &__args,
    )
}

/// set_stats_aggregator_dataset with options.
pub fn set_stats_aggregator_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    stats_aggregator: T1,
    tag: T2,
    counter_prefix: T3,
    __args: &SetStatsAggregatorDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SetStatsAggregatorDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&stats_aggregator.to_handle()?)?;
    op.add_input(&tag.to_handle()?)?;
    op.add_input(&counter_prefix.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Shape
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Shape {
    pub T: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl Shape {
    /// Creates a new `Shape`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// shape with default options.
pub fn shape<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Shape::new();
    shape_with_args(ctx, input, &__args)
}

/// shape with options.
pub fn shape_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Shape,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Shape")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ShapeN
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShapeN {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl ShapeN {
    /// Creates a new `ShapeN`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// shape_n with default options.
pub fn shape_n<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ShapeN::new();
    shape_n_with_args(ctx, input, &__args)
}

/// shape_n with options.
pub fn shape_n_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &ShapeN,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ShapeN")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ShardDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShardDataset {
    pub require_non_empty: ::std::option::Option<bool>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ShardDataset {
    /// Creates a new `ShardDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// shard_dataset with default options.
pub fn shard_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_shards: T1,
    index: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ShardDataset::new();
    shard_dataset_with_args(ctx, input_dataset, num_shards, index, &__args)
}

/// shard_dataset with options.
pub fn shard_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    num_shards: T1,
    index: T2,
    __args: &ShardDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ShardDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&num_shards.to_handle()?)?;
    op.add_input(&index.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.require_non_empty {
        op.set_attr_bool("require_non_empty", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ShardedFilename
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShardedFilename {}

impl ShardedFilename {
    /// Creates a new `ShardedFilename`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sharded_filename with default options.
pub fn sharded_filename<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    basename: T0,
    shard: T1,
    num_shards: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ShardedFilename::new();
    sharded_filename_with_args(ctx, basename, shard, num_shards, &__args)
}

/// sharded_filename with options.
pub fn sharded_filename_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    basename: T0,
    shard: T1,
    num_shards: T2,
    __args: &ShardedFilename,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ShardedFilename")?;

    // Required input arguments
    op.add_input(&basename.to_handle()?)?;
    op.add_input(&shard.to_handle()?)?;
    op.add_input(&num_shards.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ShardedFilespec
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShardedFilespec {}

impl ShardedFilespec {
    /// Creates a new `ShardedFilespec`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sharded_filespec with default options.
pub fn sharded_filespec<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    basename: T0,
    num_shards: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ShardedFilespec::new();
    sharded_filespec_with_args(ctx, basename, num_shards, &__args)
}

/// sharded_filespec with options.
pub fn sharded_filespec_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    basename: T0,
    num_shards: T1,
    __args: &ShardedFilespec,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ShardedFilespec")?;

    // Required input arguments
    op.add_input(&basename.to_handle()?)?;
    op.add_input(&num_shards.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ShuffleAndRepeatDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShuffleAndRepeatDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub reshuffle_each_iteration: ::std::option::Option<bool>,
}

impl ShuffleAndRepeatDataset {
    /// Creates a new `ShuffleAndRepeatDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// shuffle_and_repeat_dataset with default options.
pub fn shuffle_and_repeat_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    buffer_size: T1,
    seed: T2,
    seed2: T3,
    count: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = ShuffleAndRepeatDataset::new();
    shuffle_and_repeat_dataset_with_args(
        ctx,
        input_dataset,
        buffer_size,
        seed,
        seed2,
        count,
        &__args,
    )
}

/// shuffle_and_repeat_dataset with options.
pub fn shuffle_and_repeat_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    buffer_size: T1,
    seed: T2,
    seed2: T3,
    count: T4,
    __args: &ShuffleAndRepeatDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ShuffleAndRepeatDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&seed2.to_handle()?)?;
    op.add_input(&count.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.reshuffle_each_iteration {
        op.set_attr_bool("reshuffle_each_iteration", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ShuffleAndRepeatDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShuffleAndRepeatDatasetV2 {
    pub reshuffle_each_iteration: ::std::option::Option<bool>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ShuffleAndRepeatDatasetV2 {
    /// Creates a new `ShuffleAndRepeatDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// shuffle_and_repeat_dataset_v2 with default options.
pub fn shuffle_and_repeat_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    buffer_size: T1,
    seed: T2,
    seed2: T3,
    count: T4,
    seed_generator: T5,
) -> Result<crate::eager::TensorHandle> {
    let __args = ShuffleAndRepeatDatasetV2::new();
    shuffle_and_repeat_dataset_v2_with_args(
        ctx,
        input_dataset,
        buffer_size,
        seed,
        seed2,
        count,
        seed_generator,
        &__args,
    )
}

/// shuffle_and_repeat_dataset_v2 with options.
pub fn shuffle_and_repeat_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    buffer_size: T1,
    seed: T2,
    seed2: T3,
    count: T4,
    seed_generator: T5,
    __args: &ShuffleAndRepeatDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ShuffleAndRepeatDatasetV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&seed2.to_handle()?)?;
    op.add_input(&count.to_handle()?)?;
    op.add_input(&seed_generator.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.reshuffle_each_iteration {
        op.set_attr_bool("reshuffle_each_iteration", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ShuffleDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShuffleDataset {
    pub reshuffle_each_iteration: ::std::option::Option<bool>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ShuffleDataset {
    /// Creates a new `ShuffleDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// shuffle_dataset with default options.
pub fn shuffle_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    buffer_size: T1,
    seed: T2,
    seed2: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = ShuffleDataset::new();
    shuffle_dataset_with_args(ctx, input_dataset, buffer_size, seed, seed2, &__args)
}

/// shuffle_dataset with options.
pub fn shuffle_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    buffer_size: T1,
    seed: T2,
    seed2: T3,
    __args: &ShuffleDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ShuffleDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&seed2.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.reshuffle_each_iteration {
        op.set_attr_bool("reshuffle_each_iteration", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ShuffleDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShuffleDatasetV2 {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ShuffleDatasetV2 {
    /// Creates a new `ShuffleDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// shuffle_dataset_v2 with default options.
pub fn shuffle_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    buffer_size: T1,
    seed_generator: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = ShuffleDatasetV2::new();
    shuffle_dataset_v2_with_args(ctx, input_dataset, buffer_size, seed_generator, &__args)
}

/// shuffle_dataset_v2 with options.
pub fn shuffle_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    buffer_size: T1,
    seed_generator: T2,
    __args: &ShuffleDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ShuffleDatasetV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;
    op.add_input(&seed_generator.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ShuffleDatasetV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShuffleDatasetV3 {
    pub reshuffle_each_iteration: ::std::option::Option<bool>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ShuffleDatasetV3 {
    /// Creates a new `ShuffleDatasetV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// shuffle_dataset_v3 with default options.
pub fn shuffle_dataset_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    buffer_size: T1,
    seed: T2,
    seed2: T3,
    seed_generator: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = ShuffleDatasetV3::new();
    shuffle_dataset_v3_with_args(
        ctx,
        input_dataset,
        buffer_size,
        seed,
        seed2,
        seed_generator,
        &__args,
    )
}

/// shuffle_dataset_v3 with options.
pub fn shuffle_dataset_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    buffer_size: T1,
    seed: T2,
    seed2: T3,
    seed_generator: T4,
    __args: &ShuffleDatasetV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ShuffleDatasetV3")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&seed2.to_handle()?)?;
    op.add_input(&seed_generator.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.reshuffle_each_iteration {
        op.set_attr_bool("reshuffle_each_iteration", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ShutdownDistributedTPU
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShutdownDistributedTPU {}

impl ShutdownDistributedTPU {
    /// Creates a new `ShutdownDistributedTPU`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// shutdown_distributed_tpu with default options.
pub fn shutdown_distributed_tpu(ctx: &crate::eager::Context) -> Result<()> {
    let __args = ShutdownDistributedTPU::new();
    shutdown_distributed_tpu_with_args(ctx, &__args)
}

/// shutdown_distributed_tpu with options.
pub fn shutdown_distributed_tpu_with_args(
    ctx: &crate::eager::Context,
    __args: &ShutdownDistributedTPU,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ShutdownDistributedTPU")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Sigmoid
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sigmoid {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Sigmoid {
    /// Creates a new `Sigmoid`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sigmoid with default options.
pub fn sigmoid<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Sigmoid::new();
    sigmoid_with_args(ctx, x, &__args)
}

/// sigmoid with options.
pub fn sigmoid_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Sigmoid,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Sigmoid")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SigmoidGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SigmoidGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SigmoidGrad {
    /// Creates a new `SigmoidGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sigmoid_grad with default options.
pub fn sigmoid_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    dy: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SigmoidGrad::new();
    sigmoid_grad_with_args(ctx, y, dy, &__args)
}

/// sigmoid_grad with options.
pub fn sigmoid_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    dy: T1,
    __args: &SigmoidGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SigmoidGrad")?;

    // Required input arguments
    op.add_input(&y.to_handle()?)?;
    op.add_input(&dy.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Sign
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sign {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Sign {
    /// Creates a new `Sign`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sign with default options.
pub fn sign<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Sign::new();
    sign_with_args(ctx, x, &__args)
}

/// sign with options.
pub fn sign_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Sign,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Sign")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Sin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sin {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Sin {
    /// Creates a new `Sin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sin with default options.
pub fn sin<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Sin::new();
    sin_with_args(ctx, x, &__args)
}

/// sin with options.
pub fn sin_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Sin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Sin")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Sinh
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sinh {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Sinh {
    /// Creates a new `Sinh`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sinh with default options.
pub fn sinh<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Sinh::new();
    sinh_with_args(ctx, x, &__args)
}

/// sinh with options.
pub fn sinh_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Sinh,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Sinh")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Size
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Size {
    pub T: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl Size {
    /// Creates a new `Size`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// size with default options.
pub fn size<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Size::new();
    size_with_args(ctx, input, &__args)
}

/// size with options.
pub fn size_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Size,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Size")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SkipDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SkipDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl SkipDataset {
    /// Creates a new `SkipDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// skip_dataset with default options.
pub fn skip_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    count: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SkipDataset::new();
    skip_dataset_with_args(ctx, input_dataset, count, &__args)
}

/// skip_dataset with options.
pub fn skip_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    count: T1,
    __args: &SkipDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SkipDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&count.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Skipgram
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Skipgram {
    pub filename: ::std::option::Option<::std::string::String>,
    pub batch_size: ::std::option::Option<i64>,
    pub window_size: ::std::option::Option<i64>,
    pub min_count: ::std::option::Option<i64>,
    pub subsample: ::std::option::Option<f32>,
}

impl Skipgram {
    /// Creates a new `Skipgram`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// skipgram with default options.
pub fn skipgram(ctx: &crate::eager::Context) -> Result<[crate::eager::TensorHandle; 7]> {
    let __args = Skipgram::new();
    skipgram_with_args(ctx, &__args)
}

/// skipgram with options.
pub fn skipgram_with_args(
    ctx: &crate::eager::Context,
    __args: &Skipgram,
) -> Result<[crate::eager::TensorHandle; 7]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Skipgram")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.filename {
        op.set_attr_string("filename", value);
    }
    if let ::std::option::Option::Some(value) = &__args.batch_size {
        op.set_attr_int("batch_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.window_size {
        op.set_attr_int("window_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.min_count {
        op.set_attr_int("min_count", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.subsample {
        op.set_attr_float("subsample", *value);
    }

    // Execute Op
    let mut num_output = 7;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 7];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
                crate::eager::TensorHandle::from_tensor_handle(res[4]),
                crate::eager::TensorHandle::from_tensor_handle(res[5]),
                crate::eager::TensorHandle::from_tensor_handle(res[6]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SleepDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SleepDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl SleepDataset {
    /// Creates a new `SleepDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sleep_dataset with default options.
pub fn sleep_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    sleep_microseconds: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SleepDataset::new();
    sleep_dataset_with_args(ctx, input_dataset, sleep_microseconds, &__args)
}

/// sleep_dataset with options.
pub fn sleep_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    sleep_microseconds: T1,
    __args: &SleepDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SleepDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&sleep_microseconds.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Slice
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Slice {
    pub T: ::std::option::Option<crate::DataType>,
    pub Index: ::std::option::Option<crate::DataType>,
}

impl Slice {
    /// Creates a new `Slice`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// slice with default options.
pub fn slice<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle, T2: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    begin: T1,
    size: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Slice::new();
    slice_with_args(ctx, input, begin, size, &__args)
}

/// slice with options.
pub fn slice_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    begin: T1,
    size: T2,
    __args: &Slice,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Slice")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&begin.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Index {
        op.set_attr_type("Index", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SlidingWindowDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SlidingWindowDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl SlidingWindowDataset {
    /// Creates a new `SlidingWindowDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sliding_window_dataset with default options.
pub fn sliding_window_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    window_size: T1,
    window_shift: T2,
    window_stride: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SlidingWindowDataset::new();
    sliding_window_dataset_with_args(
        ctx,
        input_dataset,
        window_size,
        window_shift,
        window_stride,
        &__args,
    )
}

/// sliding_window_dataset with options.
pub fn sliding_window_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    window_size: T1,
    window_shift: T2,
    window_stride: T3,
    __args: &SlidingWindowDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SlidingWindowDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&window_size.to_handle()?)?;
    op.add_input(&window_shift.to_handle()?)?;
    op.add_input(&window_stride.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Snapshot
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Snapshot {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Snapshot {
    /// Creates a new `Snapshot`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// snapshot with default options.
pub fn snapshot<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Snapshot::new();
    snapshot_with_args(ctx, input, &__args)
}

/// snapshot with options.
pub fn snapshot_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Snapshot,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Snapshot")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SnapshotDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SnapshotDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub compression: ::std::option::Option<::std::string::String>,
    pub reader_path_prefix: ::std::option::Option<::std::string::String>,
    pub writer_path_prefix: ::std::option::Option<::std::string::String>,
    pub shard_size_bytes: ::std::option::Option<i64>,
    pub pending_snapshot_expiry_seconds: ::std::option::Option<i64>,
    pub num_reader_threads: ::std::option::Option<i64>,
    pub reader_buffer_size: ::std::option::Option<i64>,
    pub num_writer_threads: ::std::option::Option<i64>,
    pub writer_buffer_size: ::std::option::Option<i64>,
    pub shuffle_on_read: ::std::option::Option<bool>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub mode: ::std::option::Option<::std::string::String>,
    pub snapshot_name: ::std::option::Option<::std::string::String>,
}

impl SnapshotDataset {
    /// Creates a new `SnapshotDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// snapshot_dataset with default options.
pub fn snapshot_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    path: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SnapshotDataset::new();
    snapshot_dataset_with_args(ctx, input_dataset, path, &__args)
}

/// snapshot_dataset with options.
pub fn snapshot_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    path: T1,
    __args: &SnapshotDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SnapshotDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&path.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.compression {
        op.set_attr_string("compression", value);
    }
    if let ::std::option::Option::Some(value) = &__args.reader_path_prefix {
        op.set_attr_string("reader_path_prefix", value);
    }
    if let ::std::option::Option::Some(value) = &__args.writer_path_prefix {
        op.set_attr_string("writer_path_prefix", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_size_bytes {
        op.set_attr_int("shard_size_bytes", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.pending_snapshot_expiry_seconds {
        op.set_attr_int("pending_snapshot_expiry_seconds", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_reader_threads {
        op.set_attr_int("num_reader_threads", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.reader_buffer_size {
        op.set_attr_int("reader_buffer_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_writer_threads {
        op.set_attr_int("num_writer_threads", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.writer_buffer_size {
        op.set_attr_int("writer_buffer_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shuffle_on_read {
        op.set_attr_bool("shuffle_on_read", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.mode {
        op.set_attr_string("mode", value);
    }
    if let ::std::option::Option::Some(value) = &__args.snapshot_name {
        op.set_attr_string("snapshot_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SnapshotDatasetReader
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SnapshotDatasetReader {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub compression: ::std::option::Option<::std::string::String>,
    pub version: ::std::option::Option<i64>,
}

impl SnapshotDatasetReader {
    /// Creates a new `SnapshotDatasetReader`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// snapshot_dataset_reader with default options.
pub fn snapshot_dataset_reader<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shard_dir: T0,
    start_index: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SnapshotDatasetReader::new();
    snapshot_dataset_reader_with_args(ctx, shard_dir, start_index, &__args)
}

/// snapshot_dataset_reader with options.
pub fn snapshot_dataset_reader_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shard_dir: T0,
    start_index: T1,
    __args: &SnapshotDatasetReader,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SnapshotDatasetReader")?;

    // Required input arguments
    op.add_input(&shard_dir.to_handle()?)?;
    op.add_input(&start_index.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.compression {
        op.set_attr_string("compression", value);
    }
    if let ::std::option::Option::Some(value) = &__args.version {
        op.set_attr_int("version", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SnapshotDatasetV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SnapshotDatasetV2 {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub compression: ::std::option::Option<::std::string::String>,
    pub reader_prefix: ::std::option::Option<::std::string::String>,
    pub writer_prefix: ::std::option::Option<::std::string::String>,
    pub hash_valid: ::std::option::Option<bool>,
    pub hash: ::std::option::Option<i64>,
    pub reader_func: ::std::option::Option<::std::string::String>,
    pub shard_func: ::std::option::Option<::std::string::String>,
    pub Treader_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tshard_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl SnapshotDatasetV2 {
    /// Creates a new `SnapshotDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// snapshot_dataset_v2 with default options.
pub fn snapshot_dataset_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    path: T1,
    reader_func_other_args: T2,
    shard_func_other_args: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SnapshotDatasetV2::new();
    snapshot_dataset_v2_with_args(
        ctx,
        input_dataset,
        path,
        reader_func_other_args,
        shard_func_other_args,
        &__args,
    )
}

/// snapshot_dataset_v2 with options.
pub fn snapshot_dataset_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    path: T1,
    reader_func_other_args: T2,
    shard_func_other_args: T3,
    __args: &SnapshotDatasetV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SnapshotDatasetV2")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&path.to_handle()?)?;
    op.add_input(&reader_func_other_args.to_handle()?)?;
    op.add_input(&shard_func_other_args.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.compression {
        op.set_attr_string("compression", value);
    }
    if let ::std::option::Option::Some(value) = &__args.reader_prefix {
        op.set_attr_string("reader_prefix", value);
    }
    if let ::std::option::Option::Some(value) = &__args.writer_prefix {
        op.set_attr_string("writer_prefix", value);
    }
    if let ::std::option::Option::Some(value) = &__args.hash_valid {
        op.set_attr_bool("hash_valid", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.hash {
        op.set_attr_int("hash", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.reader_func {
        op.set_attr_string("reader_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shard_func {
        op.set_attr_string("shard_func", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Treader_func_args {
        op.set_attr_type_list("Treader_func_args", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshard_func_args {
        op.set_attr_type_list("Tshard_func_args", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SnapshotNestedDatasetReader
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SnapshotNestedDatasetReader {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub N: ::std::option::Option<i64>,
}

impl SnapshotNestedDatasetReader {
    /// Creates a new `SnapshotNestedDatasetReader`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// snapshot_nested_dataset_reader with default options.
pub fn snapshot_nested_dataset_reader<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = SnapshotNestedDatasetReader::new();
    snapshot_nested_dataset_reader_with_args(ctx, inputs, &__args)
}

/// snapshot_nested_dataset_reader with options.
pub fn snapshot_nested_dataset_reader_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &SnapshotNestedDatasetReader,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SnapshotNestedDatasetReader")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SobolSample
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SobolSample {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl SobolSample {
    /// Creates a new `SobolSample`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sobol_sample with default options.
pub fn sobol_sample<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    dim: T0,
    num_results: T1,
    skip: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SobolSample::new();
    sobol_sample_with_args(ctx, dim, num_results, skip, &__args)
}

/// sobol_sample with options.
pub fn sobol_sample_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    dim: T0,
    num_results: T1,
    skip: T2,
    __args: &SobolSample,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SobolSample")?;

    // Required input arguments
    op.add_input(&dim.to_handle()?)?;
    op.add_input(&num_results.to_handle()?)?;
    op.add_input(&skip.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Softmax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Softmax {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Softmax {
    /// Creates a new `Softmax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// softmax with default options.
pub fn softmax<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    logits: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Softmax::new();
    softmax_with_args(ctx, logits, &__args)
}

/// softmax with options.
pub fn softmax_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    logits: T0,
    __args: &Softmax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Softmax")?;

    // Required input arguments
    op.add_input(&logits.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SoftmaxCrossEntropyWithLogits
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SoftmaxCrossEntropyWithLogits {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SoftmaxCrossEntropyWithLogits {
    /// Creates a new `SoftmaxCrossEntropyWithLogits`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// softmax_cross_entropy_with_logits with default options.
pub fn softmax_cross_entropy_with_logits<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
    labels: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = SoftmaxCrossEntropyWithLogits::new();
    softmax_cross_entropy_with_logits_with_args(ctx, features, labels, &__args)
}

/// softmax_cross_entropy_with_logits with options.
pub fn softmax_cross_entropy_with_logits_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    features: T0,
    labels: T1,
    __args: &SoftmaxCrossEntropyWithLogits,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SoftmaxCrossEntropyWithLogits")?;

    // Required input arguments
    op.add_input(&features.to_handle()?)?;
    op.add_input(&labels.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Softplus
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Softplus {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Softplus {
    /// Creates a new `Softplus`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// softplus with default options.
pub fn softplus<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Softplus::new();
    softplus_with_args(ctx, features, &__args)
}

/// softplus with options.
pub fn softplus_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
    __args: &Softplus,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Softplus")?;

    // Required input arguments
    op.add_input(&features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SoftplusGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SoftplusGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SoftplusGrad {
    /// Creates a new `SoftplusGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// softplus_grad with default options.
pub fn softplus_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    features: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SoftplusGrad::new();
    softplus_grad_with_args(ctx, gradients, features, &__args)
}

/// softplus_grad with options.
pub fn softplus_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    features: T1,
    __args: &SoftplusGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SoftplusGrad")?;

    // Required input arguments
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Softsign
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Softsign {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Softsign {
    /// Creates a new `Softsign`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// softsign with default options.
pub fn softsign<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Softsign::new();
    softsign_with_args(ctx, features, &__args)
}

/// softsign with options.
pub fn softsign_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    features: T0,
    __args: &Softsign,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Softsign")?;

    // Required input arguments
    op.add_input(&features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SoftsignGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SoftsignGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SoftsignGrad {
    /// Creates a new `SoftsignGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// softsign_grad with default options.
pub fn softsign_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    features: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SoftsignGrad::new();
    softsign_grad_with_args(ctx, gradients, features, &__args)
}

/// softsign_grad with options.
pub fn softsign_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    gradients: T0,
    features: T1,
    __args: &SoftsignGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SoftsignGrad")?;

    // Required input arguments
    op.add_input(&gradients.to_handle()?)?;
    op.add_input(&features.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SpaceToBatch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SpaceToBatch {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tpaddings: ::std::option::Option<crate::DataType>,
    pub block_size: ::std::option::Option<i64>,
}

impl SpaceToBatch {
    /// Creates a new `SpaceToBatch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// space_to_batch with default options.
pub fn space_to_batch<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SpaceToBatch::new();
    space_to_batch_with_args(ctx, input, paddings, &__args)
}

/// space_to_batch with options.
pub fn space_to_batch_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    paddings: T1,
    __args: &SpaceToBatch,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SpaceToBatch")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&paddings.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tpaddings {
        op.set_attr_type("Tpaddings", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.block_size {
        op.set_attr_int("block_size", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SpaceToBatchND
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SpaceToBatchND {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tblock_shape: ::std::option::Option<crate::DataType>,
    pub Tpaddings: ::std::option::Option<crate::DataType>,
}

impl SpaceToBatchND {
    /// Creates a new `SpaceToBatchND`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// space_to_batch_nd with default options.
pub fn space_to_batch_nd<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    block_shape: T1,
    paddings: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SpaceToBatchND::new();
    space_to_batch_nd_with_args(ctx, input, block_shape, paddings, &__args)
}

/// space_to_batch_nd with options.
pub fn space_to_batch_nd_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    block_shape: T1,
    paddings: T2,
    __args: &SpaceToBatchND,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SpaceToBatchND")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&block_shape.to_handle()?)?;
    op.add_input(&paddings.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tblock_shape {
        op.set_attr_type("Tblock_shape", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tpaddings {
        op.set_attr_type("Tpaddings", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SpaceToDepth
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SpaceToDepth {
    pub T: ::std::option::Option<crate::DataType>,
    pub block_size: ::std::option::Option<i64>,
    pub data_format: ::std::option::Option<::std::string::String>,
}

impl SpaceToDepth {
    /// Creates a new `SpaceToDepth`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// space_to_depth with default options.
pub fn space_to_depth<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = SpaceToDepth::new();
    space_to_depth_with_args(ctx, input, &__args)
}

/// space_to_depth with options.
pub fn space_to_depth_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &SpaceToDepth,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SpaceToDepth")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.block_size {
        op.set_attr_int("block_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.data_format {
        op.set_attr_string("data_format", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseAccumulatorApplyGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseAccumulatorApplyGradient {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub has_known_shape: ::std::option::Option<bool>,
}

impl SparseAccumulatorApplyGradient {
    /// Creates a new `SparseAccumulatorApplyGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_accumulator_apply_gradient with default options.
pub fn sparse_accumulator_apply_gradient<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    local_step: T1,
    gradient_indices: T2,
    gradient_values: T3,
    gradient_shape: T4,
) -> Result<()> {
    let __args = SparseAccumulatorApplyGradient::new();
    sparse_accumulator_apply_gradient_with_args(
        ctx,
        handle,
        local_step,
        gradient_indices,
        gradient_values,
        gradient_shape,
        &__args,
    )
}

/// sparse_accumulator_apply_gradient with options.
pub fn sparse_accumulator_apply_gradient_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    local_step: T1,
    gradient_indices: T2,
    gradient_values: T3,
    gradient_shape: T4,
    __args: &SparseAccumulatorApplyGradient,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseAccumulatorApplyGradient")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&local_step.to_handle()?)?;
    op.add_input(&gradient_indices.to_handle()?)?;
    op.add_input(&gradient_values.to_handle()?)?;
    op.add_input(&gradient_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.has_known_shape {
        op.set_attr_bool("has_known_shape", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// SparseAccumulatorTakeGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseAccumulatorTakeGradient {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl SparseAccumulatorTakeGradient {
    /// Creates a new `SparseAccumulatorTakeGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_accumulator_take_gradient with default options.
pub fn sparse_accumulator_take_gradient<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    num_required: T1,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SparseAccumulatorTakeGradient::new();
    sparse_accumulator_take_gradient_with_args(ctx, handle, num_required, &__args)
}

/// sparse_accumulator_take_gradient with options.
pub fn sparse_accumulator_take_gradient_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    num_required: T1,
    __args: &SparseAccumulatorTakeGradient,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseAccumulatorTakeGradient")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&num_required.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseAdd {
    pub T: ::std::option::Option<crate::DataType>,
    pub Treal: ::std::option::Option<crate::DataType>,
}

impl SparseAdd {
    /// Creates a new `SparseAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_add with default options.
pub fn sparse_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a_indices: T0,
    a_values: T1,
    a_shape: T2,
    b_indices: T3,
    b_values: T4,
    b_shape: T5,
    thresh: T6,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SparseAdd::new();
    sparse_add_with_args(
        ctx, a_indices, a_values, a_shape, b_indices, b_values, b_shape, thresh, &__args,
    )
}

/// sparse_add with options.
pub fn sparse_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a_indices: T0,
    a_values: T1,
    a_shape: T2,
    b_indices: T3,
    b_values: T4,
    b_shape: T5,
    thresh: T6,
    __args: &SparseAdd,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseAdd")?;

    // Required input arguments
    op.add_input(&a_indices.to_handle()?)?;
    op.add_input(&a_values.to_handle()?)?;
    op.add_input(&a_shape.to_handle()?)?;
    op.add_input(&b_indices.to_handle()?)?;
    op.add_input(&b_values.to_handle()?)?;
    op.add_input(&b_shape.to_handle()?)?;
    op.add_input(&thresh.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Treal {
        op.set_attr_type("Treal", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseAddGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseAddGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseAddGrad {
    /// Creates a new `SparseAddGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_add_grad with default options.
pub fn sparse_add_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    backprop_val_grad: T0,
    a_indices: T1,
    b_indices: T2,
    sum_indices: T3,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = SparseAddGrad::new();
    sparse_add_grad_with_args(
        ctx,
        backprop_val_grad,
        a_indices,
        b_indices,
        sum_indices,
        &__args,
    )
}

/// sparse_add_grad with options.
pub fn sparse_add_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    backprop_val_grad: T0,
    a_indices: T1,
    b_indices: T2,
    sum_indices: T3,
    __args: &SparseAddGrad,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseAddGrad")?;

    // Required input arguments
    op.add_input(&backprop_val_grad.to_handle()?)?;
    op.add_input(&a_indices.to_handle()?)?;
    op.add_input(&b_indices.to_handle()?)?;
    op.add_input(&sum_indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseApplyAdadelta
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyAdadelta {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl SparseApplyAdadelta {
    /// Creates a new `SparseApplyAdadelta`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_apply_adadelta with default options.
pub fn sparse_apply_adadelta<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    accum_update: T2,
    lr: T3,
    rho: T4,
    epsilon: T5,
    grad: T6,
    indices: T7,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseApplyAdadelta::new();
    sparse_apply_adadelta_with_args(
        ctx,
        var,
        accum,
        accum_update,
        lr,
        rho,
        epsilon,
        grad,
        indices,
        &__args,
    )
}

/// sparse_apply_adadelta with options.
pub fn sparse_apply_adadelta_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    accum_update: T2,
    lr: T3,
    rho: T4,
    epsilon: T5,
    grad: T6,
    indices: T7,
    __args: &SparseApplyAdadelta,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseApplyAdadelta")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&accum_update.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&rho.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseApplyAdagrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyAdagrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub update_slots: ::std::option::Option<bool>,
}

impl SparseApplyAdagrad {
    /// Creates a new `SparseApplyAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_apply_adagrad with default options.
pub fn sparse_apply_adagrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    indices: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseApplyAdagrad::new();
    sparse_apply_adagrad_with_args(ctx, var, accum, lr, grad, indices, &__args)
}

/// sparse_apply_adagrad with options.
pub fn sparse_apply_adagrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    indices: T4,
    __args: &SparseApplyAdagrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseApplyAdagrad")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.update_slots {
        op.set_attr_bool("update_slots", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseApplyAdagradDA
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyAdagradDA {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl SparseApplyAdagradDA {
    /// Creates a new `SparseApplyAdagradDA`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_apply_adagrad_da with default options.
pub fn sparse_apply_adagrad_da<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    gradient_accumulator: T1,
    gradient_squared_accumulator: T2,
    grad: T3,
    indices: T4,
    lr: T5,
    l1: T6,
    l2: T7,
    global_step: T8,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseApplyAdagradDA::new();
    sparse_apply_adagrad_da_with_args(
        ctx,
        var,
        gradient_accumulator,
        gradient_squared_accumulator,
        grad,
        indices,
        lr,
        l1,
        l2,
        global_step,
        &__args,
    )
}

/// sparse_apply_adagrad_da with options.
pub fn sparse_apply_adagrad_da_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    gradient_accumulator: T1,
    gradient_squared_accumulator: T2,
    grad: T3,
    indices: T4,
    lr: T5,
    l1: T6,
    l2: T7,
    global_step: T8,
    __args: &SparseApplyAdagradDA,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseApplyAdagradDA")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&gradient_accumulator.to_handle()?)?;
    op.add_input(&gradient_squared_accumulator.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&global_step.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseApplyAdagradV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyAdagradV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub update_slots: ::std::option::Option<bool>,
}

impl SparseApplyAdagradV2 {
    /// Creates a new `SparseApplyAdagradV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_apply_adagrad_v2 with default options.
pub fn sparse_apply_adagrad_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    epsilon: T3,
    grad: T4,
    indices: T5,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseApplyAdagradV2::new();
    sparse_apply_adagrad_v2_with_args(ctx, var, accum, lr, epsilon, grad, indices, &__args)
}

/// sparse_apply_adagrad_v2 with options.
pub fn sparse_apply_adagrad_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    epsilon: T3,
    grad: T4,
    indices: T5,
    __args: &SparseApplyAdagradV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseApplyAdagradV2")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.update_slots {
        op.set_attr_bool("update_slots", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseApplyCenteredRMSProp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyCenteredRMSProp {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl SparseApplyCenteredRMSProp {
    /// Creates a new `SparseApplyCenteredRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_apply_centered_rmsprop with default options.
pub fn sparse_apply_centered_rmsprop<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    mg: T1,
    ms: T2,
    mom: T3,
    lr: T4,
    rho: T5,
    momentum: T6,
    epsilon: T7,
    grad: T8,
    indices: T9,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseApplyCenteredRMSProp::new();
    sparse_apply_centered_rmsprop_with_args(
        ctx, var, mg, ms, mom, lr, rho, momentum, epsilon, grad, indices, &__args,
    )
}

/// sparse_apply_centered_rmsprop with options.
pub fn sparse_apply_centered_rmsprop_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    mg: T1,
    ms: T2,
    mom: T3,
    lr: T4,
    rho: T5,
    momentum: T6,
    epsilon: T7,
    grad: T8,
    indices: T9,
    __args: &SparseApplyCenteredRMSProp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseApplyCenteredRMSProp")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&mg.to_handle()?)?;
    op.add_input(&ms.to_handle()?)?;
    op.add_input(&mom.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&rho.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseApplyFtrl
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyFtrl {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub multiply_linear_by_lr: ::std::option::Option<bool>,
}

impl SparseApplyFtrl {
    /// Creates a new `SparseApplyFtrl`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_apply_ftrl with default options.
pub fn sparse_apply_ftrl<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    indices: T4,
    lr: T5,
    l1: T6,
    l2: T7,
    lr_power: T8,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseApplyFtrl::new();
    sparse_apply_ftrl_with_args(
        ctx, var, accum, linear, grad, indices, lr, l1, l2, lr_power, &__args,
    )
}

/// sparse_apply_ftrl with options.
pub fn sparse_apply_ftrl_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    indices: T4,
    lr: T5,
    l1: T6,
    l2: T7,
    lr_power: T8,
    __args: &SparseApplyFtrl,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseApplyFtrl")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&linear.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&lr_power.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.multiply_linear_by_lr {
        op.set_attr_bool("multiply_linear_by_lr", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseApplyFtrlV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyFtrlV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub multiply_linear_by_lr: ::std::option::Option<bool>,
}

impl SparseApplyFtrlV2 {
    /// Creates a new `SparseApplyFtrlV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_apply_ftrl_v2 with default options.
pub fn sparse_apply_ftrl_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    indices: T4,
    lr: T5,
    l1: T6,
    l2: T7,
    l2_shrinkage: T8,
    lr_power: T9,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseApplyFtrlV2::new();
    sparse_apply_ftrl_v2_with_args(
        ctx,
        var,
        accum,
        linear,
        grad,
        indices,
        lr,
        l1,
        l2,
        l2_shrinkage,
        lr_power,
        &__args,
    )
}

/// sparse_apply_ftrl_v2 with options.
pub fn sparse_apply_ftrl_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
    T9: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    linear: T2,
    grad: T3,
    indices: T4,
    lr: T5,
    l1: T6,
    l2: T7,
    l2_shrinkage: T8,
    lr_power: T9,
    __args: &SparseApplyFtrlV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseApplyFtrlV2")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&linear.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&l2_shrinkage.to_handle()?)?;
    op.add_input(&lr_power.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.multiply_linear_by_lr {
        op.set_attr_bool("multiply_linear_by_lr", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseApplyMomentum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyMomentum {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
    pub use_nesterov: ::std::option::Option<bool>,
}

impl SparseApplyMomentum {
    /// Creates a new `SparseApplyMomentum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_apply_momentum with default options.
pub fn sparse_apply_momentum<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    indices: T4,
    momentum: T5,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseApplyMomentum::new();
    sparse_apply_momentum_with_args(ctx, var, accum, lr, grad, indices, momentum, &__args)
}

/// sparse_apply_momentum with options.
pub fn sparse_apply_momentum_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    grad: T3,
    indices: T4,
    momentum: T5,
    __args: &SparseApplyMomentum,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseApplyMomentum")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_nesterov {
        op.set_attr_bool("use_nesterov", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseApplyProximalAdagrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyProximalAdagrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl SparseApplyProximalAdagrad {
    /// Creates a new `SparseApplyProximalAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_apply_proximal_adagrad with default options.
pub fn sparse_apply_proximal_adagrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    l1: T3,
    l2: T4,
    grad: T5,
    indices: T6,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseApplyProximalAdagrad::new();
    sparse_apply_proximal_adagrad_with_args(ctx, var, accum, lr, l1, l2, grad, indices, &__args)
}

/// sparse_apply_proximal_adagrad with options.
pub fn sparse_apply_proximal_adagrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    accum: T1,
    lr: T2,
    l1: T3,
    l2: T4,
    grad: T5,
    indices: T6,
    __args: &SparseApplyProximalAdagrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseApplyProximalAdagrad")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&accum.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseApplyProximalGradientDescent
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyProximalGradientDescent {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl SparseApplyProximalGradientDescent {
    /// Creates a new `SparseApplyProximalGradientDescent`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_apply_proximal_gradient_descent with default options.
pub fn sparse_apply_proximal_gradient_descent<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    alpha: T1,
    l1: T2,
    l2: T3,
    grad: T4,
    indices: T5,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseApplyProximalGradientDescent::new();
    sparse_apply_proximal_gradient_descent_with_args(
        ctx, var, alpha, l1, l2, grad, indices, &__args,
    )
}

/// sparse_apply_proximal_gradient_descent with options.
pub fn sparse_apply_proximal_gradient_descent_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    alpha: T1,
    l1: T2,
    l2: T3,
    grad: T4,
    indices: T5,
    __args: &SparseApplyProximalGradientDescent,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseApplyProximalGradientDescent")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&alpha.to_handle()?)?;
    op.add_input(&l1.to_handle()?)?;
    op.add_input(&l2.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseApplyRMSProp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyRMSProp {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub use_locking: ::std::option::Option<bool>,
}

impl SparseApplyRMSProp {
    /// Creates a new `SparseApplyRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_apply_rmsprop with default options.
pub fn sparse_apply_rmsprop<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    ms: T1,
    mom: T2,
    lr: T3,
    rho: T4,
    momentum: T5,
    epsilon: T6,
    grad: T7,
    indices: T8,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseApplyRMSProp::new();
    sparse_apply_rmsprop_with_args(
        ctx, var, ms, mom, lr, rho, momentum, epsilon, grad, indices, &__args,
    )
}

/// sparse_apply_rmsprop with options.
pub fn sparse_apply_rmsprop_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
    T7: crate::eager::ToHandle,
    T8: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    var: T0,
    ms: T1,
    mom: T2,
    lr: T3,
    rho: T4,
    momentum: T5,
    epsilon: T6,
    grad: T7,
    indices: T8,
    __args: &SparseApplyRMSProp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseApplyRMSProp")?;

    // Required input arguments
    op.add_input(&var.to_handle()?)?;
    op.add_input(&ms.to_handle()?)?;
    op.add_input(&mom.to_handle()?)?;
    op.add_input(&lr.to_handle()?)?;
    op.add_input(&rho.to_handle()?)?;
    op.add_input(&momentum.to_handle()?)?;
    op.add_input(&epsilon.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_locking {
        op.set_attr_bool("use_locking", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseBincount
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseBincount {
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub binary_output: ::std::option::Option<bool>,
}

impl SparseBincount {
    /// Creates a new `SparseBincount`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_bincount with default options.
pub fn sparse_bincount<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    dense_shape: T2,
    size: T3,
    weights: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseBincount::new();
    sparse_bincount_with_args(ctx, indices, values, dense_shape, size, weights, &__args)
}

/// sparse_bincount with options.
pub fn sparse_bincount_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    dense_shape: T2,
    size: T3,
    weights: T4,
    __args: &SparseBincount,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseBincount")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&dense_shape.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;
    op.add_input(&weights.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.binary_output {
        op.set_attr_bool("binary_output", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseConcat
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseConcat {
    pub concat_dim: ::std::option::Option<i64>,
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseConcat {
    /// Creates a new `SparseConcat`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_concat with default options.
pub fn sparse_concat<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    shapes: T2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SparseConcat::new();
    sparse_concat_with_args(ctx, indices, values, shapes, &__args)
}

/// sparse_concat with options.
pub fn sparse_concat_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    shapes: T2,
    __args: &SparseConcat,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseConcat")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&shapes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.concat_dim {
        op.set_attr_int("concat_dim", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseConditionalAccumulator
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseConditionalAccumulator {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub reduction_type: ::std::option::Option<::std::string::String>,
}

impl SparseConditionalAccumulator {
    /// Creates a new `SparseConditionalAccumulator`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_conditional_accumulator with default options.
pub fn sparse_conditional_accumulator(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseConditionalAccumulator::new();
    sparse_conditional_accumulator_with_args(ctx, &__args)
}

/// sparse_conditional_accumulator with options.
pub fn sparse_conditional_accumulator_with_args(
    ctx: &crate::eager::Context,
    __args: &SparseConditionalAccumulator,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseConditionalAccumulator")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.reduction_type {
        op.set_attr_string("reduction_type", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseCountSparseOutput
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseCountSparseOutput {
    pub T: ::std::option::Option<crate::DataType>,
    pub minlength: ::std::option::Option<i64>,
    pub maxlength: ::std::option::Option<i64>,
    pub binary_output: ::std::option::Option<bool>,
    pub output_type: ::std::option::Option<crate::DataType>,
}

impl SparseCountSparseOutput {
    /// Creates a new `SparseCountSparseOutput`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_count_sparse_output with default options.
pub fn sparse_count_sparse_output<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    dense_shape: T2,
    weights: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SparseCountSparseOutput::new();
    sparse_count_sparse_output_with_args(ctx, indices, values, dense_shape, weights, &__args)
}

/// sparse_count_sparse_output with options.
pub fn sparse_count_sparse_output_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    dense_shape: T2,
    weights: T3,
    __args: &SparseCountSparseOutput,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseCountSparseOutput")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&dense_shape.to_handle()?)?;
    op.add_input(&weights.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.minlength {
        op.set_attr_int("minlength", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.maxlength {
        op.set_attr_int("maxlength", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.binary_output {
        op.set_attr_bool("binary_output", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_type {
        op.set_attr_type("output_type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseCross
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseCross {
    pub N: ::std::option::Option<i64>,
    pub hashed_output: ::std::option::Option<bool>,
    pub num_buckets: ::std::option::Option<i64>,
    pub hash_key: ::std::option::Option<i64>,
    pub sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub out_type: ::std::option::Option<crate::DataType>,
    pub internal_type: ::std::option::Option<crate::DataType>,
}

impl SparseCross {
    /// Creates a new `SparseCross`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_cross with default options.
pub fn sparse_cross<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    shapes: T2,
    dense_inputs: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SparseCross::new();
    sparse_cross_with_args(ctx, indices, values, shapes, dense_inputs, &__args)
}

/// sparse_cross with options.
pub fn sparse_cross_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    shapes: T2,
    dense_inputs: T3,
    __args: &SparseCross,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseCross")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&shapes.to_handle()?)?;
    op.add_input(&dense_inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.hashed_output {
        op.set_attr_bool("hashed_output", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_buckets {
        op.set_attr_int("num_buckets", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.hash_key {
        op.set_attr_int("hash_key", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.sparse_types {
        op.set_attr_type_list("sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_types {
        op.set_attr_type_list("dense_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.internal_type {
        op.set_attr_type("internal_type", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseCrossHashed
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseCrossHashed {
    pub N: ::std::option::Option<i64>,
    pub sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl SparseCrossHashed {
    /// Creates a new `SparseCrossHashed`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_cross_hashed with default options.
pub fn sparse_cross_hashed<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    shapes: T2,
    dense_inputs: T3,
    num_buckets: T4,
    strong_hash: T5,
    salt: T6,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SparseCrossHashed::new();
    sparse_cross_hashed_with_args(
        ctx,
        indices,
        values,
        shapes,
        dense_inputs,
        num_buckets,
        strong_hash,
        salt,
        &__args,
    )
}

/// sparse_cross_hashed with options.
pub fn sparse_cross_hashed_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
    T6: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    shapes: T2,
    dense_inputs: T3,
    num_buckets: T4,
    strong_hash: T5,
    salt: T6,
    __args: &SparseCrossHashed,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseCrossHashed")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&shapes.to_handle()?)?;
    op.add_input(&dense_inputs.to_handle()?)?;
    op.add_input(&num_buckets.to_handle()?)?;
    op.add_input(&strong_hash.to_handle()?)?;
    op.add_input(&salt.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.sparse_types {
        op.set_attr_type_list("sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_types {
        op.set_attr_type_list("dense_types", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseCrossV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseCrossV2 {
    pub N: ::std::option::Option<i64>,
    pub sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl SparseCrossV2 {
    /// Creates a new `SparseCrossV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_cross_v2 with default options.
pub fn sparse_cross_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    shapes: T2,
    dense_inputs: T3,
    sep: T4,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SparseCrossV2::new();
    sparse_cross_v2_with_args(ctx, indices, values, shapes, dense_inputs, sep, &__args)
}

/// sparse_cross_v2 with options.
pub fn sparse_cross_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    shapes: T2,
    dense_inputs: T3,
    sep: T4,
    __args: &SparseCrossV2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseCrossV2")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&shapes.to_handle()?)?;
    op.add_input(&dense_inputs.to_handle()?)?;
    op.add_input(&sep.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.sparse_types {
        op.set_attr_type_list("sparse_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dense_types {
        op.set_attr_type_list("dense_types", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseDenseCwiseAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseDenseCwiseAdd {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseDenseCwiseAdd {
    /// Creates a new `SparseDenseCwiseAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_dense_cwise_add with default options.
pub fn sparse_dense_cwise_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sp_indices: T0,
    sp_values: T1,
    sp_shape: T2,
    dense: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseDenseCwiseAdd::new();
    sparse_dense_cwise_add_with_args(ctx, sp_indices, sp_values, sp_shape, dense, &__args)
}

/// sparse_dense_cwise_add with options.
pub fn sparse_dense_cwise_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sp_indices: T0,
    sp_values: T1,
    sp_shape: T2,
    dense: T3,
    __args: &SparseDenseCwiseAdd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseDenseCwiseAdd")?;

    // Required input arguments
    op.add_input(&sp_indices.to_handle()?)?;
    op.add_input(&sp_values.to_handle()?)?;
    op.add_input(&sp_shape.to_handle()?)?;
    op.add_input(&dense.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseDenseCwiseDiv
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseDenseCwiseDiv {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseDenseCwiseDiv {
    /// Creates a new `SparseDenseCwiseDiv`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_dense_cwise_div with default options.
pub fn sparse_dense_cwise_div<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sp_indices: T0,
    sp_values: T1,
    sp_shape: T2,
    dense: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseDenseCwiseDiv::new();
    sparse_dense_cwise_div_with_args(ctx, sp_indices, sp_values, sp_shape, dense, &__args)
}

/// sparse_dense_cwise_div with options.
pub fn sparse_dense_cwise_div_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sp_indices: T0,
    sp_values: T1,
    sp_shape: T2,
    dense: T3,
    __args: &SparseDenseCwiseDiv,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseDenseCwiseDiv")?;

    // Required input arguments
    op.add_input(&sp_indices.to_handle()?)?;
    op.add_input(&sp_values.to_handle()?)?;
    op.add_input(&sp_shape.to_handle()?)?;
    op.add_input(&dense.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseDenseCwiseMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseDenseCwiseMul {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseDenseCwiseMul {
    /// Creates a new `SparseDenseCwiseMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_dense_cwise_mul with default options.
pub fn sparse_dense_cwise_mul<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sp_indices: T0,
    sp_values: T1,
    sp_shape: T2,
    dense: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseDenseCwiseMul::new();
    sparse_dense_cwise_mul_with_args(ctx, sp_indices, sp_values, sp_shape, dense, &__args)
}

/// sparse_dense_cwise_mul with options.
pub fn sparse_dense_cwise_mul_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sp_indices: T0,
    sp_values: T1,
    sp_shape: T2,
    dense: T3,
    __args: &SparseDenseCwiseMul,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseDenseCwiseMul")?;

    // Required input arguments
    op.add_input(&sp_indices.to_handle()?)?;
    op.add_input(&sp_values.to_handle()?)?;
    op.add_input(&sp_shape.to_handle()?)?;
    op.add_input(&dense.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseFillEmptyRows
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseFillEmptyRows {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseFillEmptyRows {
    /// Creates a new `SparseFillEmptyRows`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_fill_empty_rows with default options.
pub fn sparse_fill_empty_rows<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    dense_shape: T2,
    default_value: T3,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let __args = SparseFillEmptyRows::new();
    sparse_fill_empty_rows_with_args(ctx, indices, values, dense_shape, default_value, &__args)
}

/// sparse_fill_empty_rows with options.
pub fn sparse_fill_empty_rows_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    dense_shape: T2,
    default_value: T3,
    __args: &SparseFillEmptyRows,
) -> Result<[crate::eager::TensorHandle; 4]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseFillEmptyRows")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&dense_shape.to_handle()?)?;
    op.add_input(&default_value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 4;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 4];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
                crate::eager::TensorHandle::from_tensor_handle(res[3]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseFillEmptyRowsGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseFillEmptyRowsGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseFillEmptyRowsGrad {
    /// Creates a new `SparseFillEmptyRowsGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_fill_empty_rows_grad with default options.
pub fn sparse_fill_empty_rows_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    reverse_index_map: T0,
    grad_values: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = SparseFillEmptyRowsGrad::new();
    sparse_fill_empty_rows_grad_with_args(ctx, reverse_index_map, grad_values, &__args)
}

/// sparse_fill_empty_rows_grad with options.
pub fn sparse_fill_empty_rows_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    reverse_index_map: T0,
    grad_values: T1,
    __args: &SparseFillEmptyRowsGrad,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseFillEmptyRowsGrad")?;

    // Required input arguments
    op.add_input(&reverse_index_map.to_handle()?)?;
    op.add_input(&grad_values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseMatMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatMul {
    pub transpose_a: ::std::option::Option<bool>,
    pub transpose_b: ::std::option::Option<bool>,
    pub a_is_sparse: ::std::option::Option<bool>,
    pub b_is_sparse: ::std::option::Option<bool>,
    pub Ta: ::std::option::Option<crate::DataType>,
    pub Tb: ::std::option::Option<crate::DataType>,
}

impl SparseMatMul {
    /// Creates a new `SparseMatMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_mat_mul with default options.
pub fn sparse_mat_mul<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseMatMul::new();
    sparse_mat_mul_with_args(ctx, a, b, &__args)
}

/// sparse_mat_mul with options.
pub fn sparse_mat_mul_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    __args: &SparseMatMul,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseMatMul")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.transpose_a {
        op.set_attr_bool("transpose_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_b {
        op.set_attr_bool("transpose_b", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.a_is_sparse {
        op.set_attr_bool("a_is_sparse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.b_is_sparse {
        op.set_attr_bool("b_is_sparse", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Ta {
        op.set_attr_type("Ta", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tb {
        op.set_attr_type("Tb", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseMatrixAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixAdd {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseMatrixAdd {
    /// Creates a new `SparseMatrixAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_matrix_add with default options.
pub fn sparse_matrix_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    alpha: T2,
    beta: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseMatrixAdd::new();
    sparse_matrix_add_with_args(ctx, a, b, alpha, beta, &__args)
}

/// sparse_matrix_add with options.
pub fn sparse_matrix_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    alpha: T2,
    beta: T3,
    __args: &SparseMatrixAdd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseMatrixAdd")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;
    op.add_input(&alpha.to_handle()?)?;
    op.add_input(&beta.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseMatrixMatMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixMatMul {
    pub T: ::std::option::Option<crate::DataType>,
    pub transpose_a: ::std::option::Option<bool>,
    pub transpose_b: ::std::option::Option<bool>,
    pub adjoint_a: ::std::option::Option<bool>,
    pub adjoint_b: ::std::option::Option<bool>,
    pub transpose_output: ::std::option::Option<bool>,
    pub conjugate_output: ::std::option::Option<bool>,
}

impl SparseMatrixMatMul {
    /// Creates a new `SparseMatrixMatMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_matrix_mat_mul with default options.
pub fn sparse_matrix_mat_mul<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseMatrixMatMul::new();
    sparse_matrix_mat_mul_with_args(ctx, a, b, &__args)
}

/// sparse_matrix_mat_mul with options.
pub fn sparse_matrix_mat_mul_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    __args: &SparseMatrixMatMul,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseMatrixMatMul")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_a {
        op.set_attr_bool("transpose_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_b {
        op.set_attr_bool("transpose_b", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adjoint_a {
        op.set_attr_bool("adjoint_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adjoint_b {
        op.set_attr_bool("adjoint_b", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_output {
        op.set_attr_bool("transpose_output", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.conjugate_output {
        op.set_attr_bool("conjugate_output", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseMatrixMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixMul {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseMatrixMul {
    /// Creates a new `SparseMatrixMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_matrix_mul with default options.
pub fn sparse_matrix_mul<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseMatrixMul::new();
    sparse_matrix_mul_with_args(ctx, a, b, &__args)
}

/// sparse_matrix_mul with options.
pub fn sparse_matrix_mul_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    __args: &SparseMatrixMul,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseMatrixMul")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseMatrixNNZ
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixNNZ {}

impl SparseMatrixNNZ {
    /// Creates a new `SparseMatrixNNZ`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_matrix_nnz with default options.
pub fn sparse_matrix_nnz<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sparse_matrix: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseMatrixNNZ::new();
    sparse_matrix_nnz_with_args(ctx, sparse_matrix, &__args)
}

/// sparse_matrix_nnz with options.
pub fn sparse_matrix_nnz_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sparse_matrix: T0,
    __args: &SparseMatrixNNZ,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseMatrixNNZ")?;

    // Required input arguments
    op.add_input(&sparse_matrix.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseMatrixOrderingAMD
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixOrderingAMD {}

impl SparseMatrixOrderingAMD {
    /// Creates a new `SparseMatrixOrderingAMD`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_matrix_ordering_amd with default options.
pub fn sparse_matrix_ordering_amd<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseMatrixOrderingAMD::new();
    sparse_matrix_ordering_amd_with_args(ctx, input, &__args)
}

/// sparse_matrix_ordering_amd with options.
pub fn sparse_matrix_ordering_amd_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &SparseMatrixOrderingAMD,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseMatrixOrderingAMD")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseMatrixSoftmax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixSoftmax {
    pub type_: ::std::option::Option<crate::DataType>,
}

impl SparseMatrixSoftmax {
    /// Creates a new `SparseMatrixSoftmax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_matrix_softmax with default options.
pub fn sparse_matrix_softmax<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    logits: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseMatrixSoftmax::new();
    sparse_matrix_softmax_with_args(ctx, logits, &__args)
}

/// sparse_matrix_softmax with options.
pub fn sparse_matrix_softmax_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    logits: T0,
    __args: &SparseMatrixSoftmax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseMatrixSoftmax")?;

    // Required input arguments
    op.add_input(&logits.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.type_ {
        op.set_attr_type("type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseMatrixSoftmaxGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixSoftmaxGrad {
    pub type_: ::std::option::Option<crate::DataType>,
}

impl SparseMatrixSoftmaxGrad {
    /// Creates a new `SparseMatrixSoftmaxGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_matrix_softmax_grad with default options.
pub fn sparse_matrix_softmax_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    softmax: T0,
    grad_softmax: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseMatrixSoftmaxGrad::new();
    sparse_matrix_softmax_grad_with_args(ctx, softmax, grad_softmax, &__args)
}

/// sparse_matrix_softmax_grad with options.
pub fn sparse_matrix_softmax_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    softmax: T0,
    grad_softmax: T1,
    __args: &SparseMatrixSoftmaxGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseMatrixSoftmaxGrad")?;

    // Required input arguments
    op.add_input(&softmax.to_handle()?)?;
    op.add_input(&grad_softmax.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.type_ {
        op.set_attr_type("type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseMatrixSparseCholesky
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixSparseCholesky {
    pub type_: ::std::option::Option<crate::DataType>,
}

impl SparseMatrixSparseCholesky {
    /// Creates a new `SparseMatrixSparseCholesky`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_matrix_sparse_cholesky with default options.
pub fn sparse_matrix_sparse_cholesky<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    permutation: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseMatrixSparseCholesky::new();
    sparse_matrix_sparse_cholesky_with_args(ctx, input, permutation, &__args)
}

/// sparse_matrix_sparse_cholesky with options.
pub fn sparse_matrix_sparse_cholesky_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    permutation: T1,
    __args: &SparseMatrixSparseCholesky,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseMatrixSparseCholesky")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&permutation.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.type_ {
        op.set_attr_type("type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseMatrixSparseMatMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixSparseMatMul {
    pub type_: ::std::option::Option<crate::DataType>,
    pub transpose_a: ::std::option::Option<bool>,
    pub transpose_b: ::std::option::Option<bool>,
    pub adjoint_a: ::std::option::Option<bool>,
    pub adjoint_b: ::std::option::Option<bool>,
}

impl SparseMatrixSparseMatMul {
    /// Creates a new `SparseMatrixSparseMatMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_matrix_sparse_mat_mul with default options.
pub fn sparse_matrix_sparse_mat_mul<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseMatrixSparseMatMul::new();
    sparse_matrix_sparse_mat_mul_with_args(ctx, a, b, &__args)
}

/// sparse_matrix_sparse_mat_mul with options.
pub fn sparse_matrix_sparse_mat_mul_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a: T0,
    b: T1,
    __args: &SparseMatrixSparseMatMul,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseMatrixSparseMatMul")?;

    // Required input arguments
    op.add_input(&a.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.type_ {
        op.set_attr_type("type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_a {
        op.set_attr_bool("transpose_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.transpose_b {
        op.set_attr_bool("transpose_b", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adjoint_a {
        op.set_attr_bool("adjoint_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adjoint_b {
        op.set_attr_bool("adjoint_b", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseMatrixTranspose
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixTranspose {
    pub conjugate: ::std::option::Option<bool>,
    pub type_: ::std::option::Option<crate::DataType>,
}

impl SparseMatrixTranspose {
    /// Creates a new `SparseMatrixTranspose`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_matrix_transpose with default options.
pub fn sparse_matrix_transpose<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseMatrixTranspose::new();
    sparse_matrix_transpose_with_args(ctx, input, &__args)
}

/// sparse_matrix_transpose with options.
pub fn sparse_matrix_transpose_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &SparseMatrixTranspose,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseMatrixTranspose")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.conjugate {
        op.set_attr_bool("conjugate", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.type_ {
        op.set_attr_type("type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseMatrixZeros
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixZeros {
    pub type_: ::std::option::Option<crate::DataType>,
}

impl SparseMatrixZeros {
    /// Creates a new `SparseMatrixZeros`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_matrix_zeros with default options.
pub fn sparse_matrix_zeros<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    dense_shape: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseMatrixZeros::new();
    sparse_matrix_zeros_with_args(ctx, dense_shape, &__args)
}

/// sparse_matrix_zeros with options.
pub fn sparse_matrix_zeros_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    dense_shape: T0,
    __args: &SparseMatrixZeros,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseMatrixZeros")?;

    // Required input arguments
    op.add_input(&dense_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.type_ {
        op.set_attr_type("type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseReduceMax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseReduceMax {
    pub keep_dims: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseReduceMax {
    /// Creates a new `SparseReduceMax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_reduce_max with default options.
pub fn sparse_reduce_max<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_indices: T0,
    input_values: T1,
    input_shape: T2,
    reduction_axes: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseReduceMax::new();
    sparse_reduce_max_with_args(
        ctx,
        input_indices,
        input_values,
        input_shape,
        reduction_axes,
        &__args,
    )
}

/// sparse_reduce_max with options.
pub fn sparse_reduce_max_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_indices: T0,
    input_values: T1,
    input_shape: T2,
    reduction_axes: T3,
    __args: &SparseReduceMax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseReduceMax")?;

    // Required input arguments
    op.add_input(&input_indices.to_handle()?)?;
    op.add_input(&input_values.to_handle()?)?;
    op.add_input(&input_shape.to_handle()?)?;
    op.add_input(&reduction_axes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseReduceMaxSparse
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseReduceMaxSparse {
    pub keep_dims: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseReduceMaxSparse {
    /// Creates a new `SparseReduceMaxSparse`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_reduce_max_sparse with default options.
pub fn sparse_reduce_max_sparse<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_indices: T0,
    input_values: T1,
    input_shape: T2,
    reduction_axes: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SparseReduceMaxSparse::new();
    sparse_reduce_max_sparse_with_args(
        ctx,
        input_indices,
        input_values,
        input_shape,
        reduction_axes,
        &__args,
    )
}

/// sparse_reduce_max_sparse with options.
pub fn sparse_reduce_max_sparse_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_indices: T0,
    input_values: T1,
    input_shape: T2,
    reduction_axes: T3,
    __args: &SparseReduceMaxSparse,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseReduceMaxSparse")?;

    // Required input arguments
    op.add_input(&input_indices.to_handle()?)?;
    op.add_input(&input_values.to_handle()?)?;
    op.add_input(&input_shape.to_handle()?)?;
    op.add_input(&reduction_axes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseReduceSum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseReduceSum {
    pub keep_dims: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseReduceSum {
    /// Creates a new `SparseReduceSum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_reduce_sum with default options.
pub fn sparse_reduce_sum<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_indices: T0,
    input_values: T1,
    input_shape: T2,
    reduction_axes: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseReduceSum::new();
    sparse_reduce_sum_with_args(
        ctx,
        input_indices,
        input_values,
        input_shape,
        reduction_axes,
        &__args,
    )
}

/// sparse_reduce_sum with options.
pub fn sparse_reduce_sum_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_indices: T0,
    input_values: T1,
    input_shape: T2,
    reduction_axes: T3,
    __args: &SparseReduceSum,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseReduceSum")?;

    // Required input arguments
    op.add_input(&input_indices.to_handle()?)?;
    op.add_input(&input_values.to_handle()?)?;
    op.add_input(&input_shape.to_handle()?)?;
    op.add_input(&reduction_axes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseReduceSumSparse
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseReduceSumSparse {
    pub keep_dims: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseReduceSumSparse {
    /// Creates a new `SparseReduceSumSparse`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_reduce_sum_sparse with default options.
pub fn sparse_reduce_sum_sparse<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_indices: T0,
    input_values: T1,
    input_shape: T2,
    reduction_axes: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SparseReduceSumSparse::new();
    sparse_reduce_sum_sparse_with_args(
        ctx,
        input_indices,
        input_values,
        input_shape,
        reduction_axes,
        &__args,
    )
}

/// sparse_reduce_sum_sparse with options.
pub fn sparse_reduce_sum_sparse_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_indices: T0,
    input_values: T1,
    input_shape: T2,
    reduction_axes: T3,
    __args: &SparseReduceSumSparse,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseReduceSumSparse")?;

    // Required input arguments
    op.add_input(&input_indices.to_handle()?)?;
    op.add_input(&input_values.to_handle()?)?;
    op.add_input(&input_shape.to_handle()?)?;
    op.add_input(&reduction_axes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseReorder
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseReorder {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseReorder {
    /// Creates a new `SparseReorder`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_reorder with default options.
pub fn sparse_reorder<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_indices: T0,
    input_values: T1,
    input_shape: T2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = SparseReorder::new();
    sparse_reorder_with_args(ctx, input_indices, input_values, input_shape, &__args)
}

/// sparse_reorder with options.
pub fn sparse_reorder_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_indices: T0,
    input_values: T1,
    input_shape: T2,
    __args: &SparseReorder,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseReorder")?;

    // Required input arguments
    op.add_input(&input_indices.to_handle()?)?;
    op.add_input(&input_values.to_handle()?)?;
    op.add_input(&input_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseReshape
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseReshape {}

impl SparseReshape {
    /// Creates a new `SparseReshape`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_reshape with default options.
pub fn sparse_reshape<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_indices: T0,
    input_shape: T1,
    new_shape: T2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = SparseReshape::new();
    sparse_reshape_with_args(ctx, input_indices, input_shape, new_shape, &__args)
}

/// sparse_reshape with options.
pub fn sparse_reshape_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_indices: T0,
    input_shape: T1,
    new_shape: T2,
    __args: &SparseReshape,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseReshape")?;

    // Required input arguments
    op.add_input(&input_indices.to_handle()?)?;
    op.add_input(&input_shape.to_handle()?)?;
    op.add_input(&new_shape.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSegmentMean
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentMean {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub Tsegmentids: ::std::option::Option<crate::DataType>,
}

impl SparseSegmentMean {
    /// Creates a new `SparseSegmentMean`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_segment_mean with default options.
pub fn sparse_segment_mean<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    indices: T1,
    segment_ids: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseSegmentMean::new();
    sparse_segment_mean_with_args(ctx, data, indices, segment_ids, &__args)
}

/// sparse_segment_mean with options.
pub fn sparse_segment_mean_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    indices: T1,
    segment_ids: T2,
    __args: &SparseSegmentMean,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSegmentMean")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsegmentids {
        op.set_attr_type("Tsegmentids", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSegmentMeanGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentMeanGrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub Tsegmentids: ::std::option::Option<crate::DataType>,
}

impl SparseSegmentMeanGrad {
    /// Creates a new `SparseSegmentMeanGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_segment_mean_grad with default options.
pub fn sparse_segment_mean_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grad: T0,
    indices: T1,
    segment_ids: T2,
    output_dim0: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseSegmentMeanGrad::new();
    sparse_segment_mean_grad_with_args(ctx, grad, indices, segment_ids, output_dim0, &__args)
}

/// sparse_segment_mean_grad with options.
pub fn sparse_segment_mean_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grad: T0,
    indices: T1,
    segment_ids: T2,
    output_dim0: T3,
    __args: &SparseSegmentMeanGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSegmentMeanGrad")?;

    // Required input arguments
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;
    op.add_input(&output_dim0.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsegmentids {
        op.set_attr_type("Tsegmentids", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSegmentMeanWithNumSegments
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentMeanWithNumSegments {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub Tnumsegments: ::std::option::Option<crate::DataType>,
    pub Tsegmentids: ::std::option::Option<crate::DataType>,
}

impl SparseSegmentMeanWithNumSegments {
    /// Creates a new `SparseSegmentMeanWithNumSegments`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_segment_mean_with_num_segments with default options.
pub fn sparse_segment_mean_with_num_segments<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    indices: T1,
    segment_ids: T2,
    num_segments: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseSegmentMeanWithNumSegments::new();
    sparse_segment_mean_with_num_segments_with_args(
        ctx,
        data,
        indices,
        segment_ids,
        num_segments,
        &__args,
    )
}

/// sparse_segment_mean_with_num_segments with options.
pub fn sparse_segment_mean_with_num_segments_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    indices: T1,
    segment_ids: T2,
    num_segments: T3,
    __args: &SparseSegmentMeanWithNumSegments,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSegmentMeanWithNumSegments")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;
    op.add_input(&num_segments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tnumsegments {
        op.set_attr_type("Tnumsegments", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsegmentids {
        op.set_attr_type("Tsegmentids", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSegmentSqrtN
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentSqrtN {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub Tsegmentids: ::std::option::Option<crate::DataType>,
}

impl SparseSegmentSqrtN {
    /// Creates a new `SparseSegmentSqrtN`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_segment_sqrt_n with default options.
pub fn sparse_segment_sqrt_n<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    indices: T1,
    segment_ids: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseSegmentSqrtN::new();
    sparse_segment_sqrt_n_with_args(ctx, data, indices, segment_ids, &__args)
}

/// sparse_segment_sqrt_n with options.
pub fn sparse_segment_sqrt_n_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    indices: T1,
    segment_ids: T2,
    __args: &SparseSegmentSqrtN,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSegmentSqrtN")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsegmentids {
        op.set_attr_type("Tsegmentids", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSegmentSqrtNGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentSqrtNGrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub Tsegmentids: ::std::option::Option<crate::DataType>,
}

impl SparseSegmentSqrtNGrad {
    /// Creates a new `SparseSegmentSqrtNGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_segment_sqrt_ngrad with default options.
pub fn sparse_segment_sqrt_ngrad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grad: T0,
    indices: T1,
    segment_ids: T2,
    output_dim0: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseSegmentSqrtNGrad::new();
    sparse_segment_sqrt_ngrad_with_args(ctx, grad, indices, segment_ids, output_dim0, &__args)
}

/// sparse_segment_sqrt_ngrad with options.
pub fn sparse_segment_sqrt_ngrad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grad: T0,
    indices: T1,
    segment_ids: T2,
    output_dim0: T3,
    __args: &SparseSegmentSqrtNGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSegmentSqrtNGrad")?;

    // Required input arguments
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;
    op.add_input(&output_dim0.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsegmentids {
        op.set_attr_type("Tsegmentids", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSegmentSqrtNWithNumSegments
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentSqrtNWithNumSegments {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub Tnumsegments: ::std::option::Option<crate::DataType>,
    pub Tsegmentids: ::std::option::Option<crate::DataType>,
}

impl SparseSegmentSqrtNWithNumSegments {
    /// Creates a new `SparseSegmentSqrtNWithNumSegments`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_segment_sqrt_nwith_num_segments with default options.
pub fn sparse_segment_sqrt_nwith_num_segments<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    indices: T1,
    segment_ids: T2,
    num_segments: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseSegmentSqrtNWithNumSegments::new();
    sparse_segment_sqrt_nwith_num_segments_with_args(
        ctx,
        data,
        indices,
        segment_ids,
        num_segments,
        &__args,
    )
}

/// sparse_segment_sqrt_nwith_num_segments with options.
pub fn sparse_segment_sqrt_nwith_num_segments_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    indices: T1,
    segment_ids: T2,
    num_segments: T3,
    __args: &SparseSegmentSqrtNWithNumSegments,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSegmentSqrtNWithNumSegments")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;
    op.add_input(&num_segments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tnumsegments {
        op.set_attr_type("Tnumsegments", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsegmentids {
        op.set_attr_type("Tsegmentids", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSegmentSum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentSum {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub Tsegmentids: ::std::option::Option<crate::DataType>,
}

impl SparseSegmentSum {
    /// Creates a new `SparseSegmentSum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_segment_sum with default options.
pub fn sparse_segment_sum<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    indices: T1,
    segment_ids: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseSegmentSum::new();
    sparse_segment_sum_with_args(ctx, data, indices, segment_ids, &__args)
}

/// sparse_segment_sum with options.
pub fn sparse_segment_sum_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    indices: T1,
    segment_ids: T2,
    __args: &SparseSegmentSum,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSegmentSum")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsegmentids {
        op.set_attr_type("Tsegmentids", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSegmentSumGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentSumGrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub Tsegmentids: ::std::option::Option<crate::DataType>,
}

impl SparseSegmentSumGrad {
    /// Creates a new `SparseSegmentSumGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_segment_sum_grad with default options.
pub fn sparse_segment_sum_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grad: T0,
    indices: T1,
    segment_ids: T2,
    output_dim0: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseSegmentSumGrad::new();
    sparse_segment_sum_grad_with_args(ctx, grad, indices, segment_ids, output_dim0, &__args)
}

/// sparse_segment_sum_grad with options.
pub fn sparse_segment_sum_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    grad: T0,
    indices: T1,
    segment_ids: T2,
    output_dim0: T3,
    __args: &SparseSegmentSumGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSegmentSumGrad")?;

    // Required input arguments
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;
    op.add_input(&output_dim0.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsegmentids {
        op.set_attr_type("Tsegmentids", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSegmentSumWithNumSegments
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentSumWithNumSegments {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
    pub Tnumsegments: ::std::option::Option<crate::DataType>,
    pub Tsegmentids: ::std::option::Option<crate::DataType>,
}

impl SparseSegmentSumWithNumSegments {
    /// Creates a new `SparseSegmentSumWithNumSegments`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_segment_sum_with_num_segments with default options.
pub fn sparse_segment_sum_with_num_segments<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    indices: T1,
    segment_ids: T2,
    num_segments: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseSegmentSumWithNumSegments::new();
    sparse_segment_sum_with_num_segments_with_args(
        ctx,
        data,
        indices,
        segment_ids,
        num_segments,
        &__args,
    )
}

/// sparse_segment_sum_with_num_segments with options.
pub fn sparse_segment_sum_with_num_segments_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    indices: T1,
    segment_ids: T2,
    num_segments: T3,
    __args: &SparseSegmentSumWithNumSegments,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSegmentSumWithNumSegments")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;
    op.add_input(&num_segments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tnumsegments {
        op.set_attr_type("Tnumsegments", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsegmentids {
        op.set_attr_type("Tsegmentids", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSlice
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSlice {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseSlice {
    /// Creates a new `SparseSlice`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_slice with default options.
pub fn sparse_slice<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    shape: T2,
    start: T3,
    size: T4,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SparseSlice::new();
    sparse_slice_with_args(ctx, indices, values, shape, start, size, &__args)
}

/// sparse_slice with options.
pub fn sparse_slice_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    shape: T2,
    start: T3,
    size: T4,
    __args: &SparseSlice,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSlice")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&start.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSliceGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSliceGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseSliceGrad {
    /// Creates a new `SparseSliceGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_slice_grad with default options.
pub fn sparse_slice_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    backprop_val_grad: T0,
    input_indices: T1,
    input_start: T2,
    output_indices: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseSliceGrad::new();
    sparse_slice_grad_with_args(
        ctx,
        backprop_val_grad,
        input_indices,
        input_start,
        output_indices,
        &__args,
    )
}

/// sparse_slice_grad with options.
pub fn sparse_slice_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    backprop_val_grad: T0,
    input_indices: T1,
    input_start: T2,
    output_indices: T3,
    __args: &SparseSliceGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSliceGrad")?;

    // Required input arguments
    op.add_input(&backprop_val_grad.to_handle()?)?;
    op.add_input(&input_indices.to_handle()?)?;
    op.add_input(&input_start.to_handle()?)?;
    op.add_input(&output_indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSoftmax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSoftmax {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseSoftmax {
    /// Creates a new `SparseSoftmax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_softmax with default options.
pub fn sparse_softmax<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sp_indices: T0,
    sp_values: T1,
    sp_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseSoftmax::new();
    sparse_softmax_with_args(ctx, sp_indices, sp_values, sp_shape, &__args)
}

/// sparse_softmax with options.
pub fn sparse_softmax_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sp_indices: T0,
    sp_values: T1,
    sp_shape: T2,
    __args: &SparseSoftmax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSoftmax")?;

    // Required input arguments
    op.add_input(&sp_indices.to_handle()?)?;
    op.add_input(&sp_values.to_handle()?)?;
    op.add_input(&sp_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSoftmaxCrossEntropyWithLogits
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSoftmaxCrossEntropyWithLogits {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tlabels: ::std::option::Option<crate::DataType>,
}

impl SparseSoftmaxCrossEntropyWithLogits {
    /// Creates a new `SparseSoftmaxCrossEntropyWithLogits`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_softmax_cross_entropy_with_logits with default options.
pub fn sparse_softmax_cross_entropy_with_logits<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    features: T0,
    labels: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = SparseSoftmaxCrossEntropyWithLogits::new();
    sparse_softmax_cross_entropy_with_logits_with_args(ctx, features, labels, &__args)
}

/// sparse_softmax_cross_entropy_with_logits with options.
pub fn sparse_softmax_cross_entropy_with_logits_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    features: T0,
    labels: T1,
    __args: &SparseSoftmaxCrossEntropyWithLogits,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSoftmaxCrossEntropyWithLogits")?;

    // Required input arguments
    op.add_input(&features.to_handle()?)?;
    op.add_input(&labels.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tlabels {
        op.set_attr_type("Tlabels", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSparseMaximum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSparseMaximum {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseSparseMaximum {
    /// Creates a new `SparseSparseMaximum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_sparse_maximum with default options.
pub fn sparse_sparse_maximum<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a_indices: T0,
    a_values: T1,
    a_shape: T2,
    b_indices: T3,
    b_values: T4,
    b_shape: T5,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = SparseSparseMaximum::new();
    sparse_sparse_maximum_with_args(
        ctx, a_indices, a_values, a_shape, b_indices, b_values, b_shape, &__args,
    )
}

/// sparse_sparse_maximum with options.
pub fn sparse_sparse_maximum_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a_indices: T0,
    a_values: T1,
    a_shape: T2,
    b_indices: T3,
    b_values: T4,
    b_shape: T5,
    __args: &SparseSparseMaximum,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSparseMaximum")?;

    // Required input arguments
    op.add_input(&a_indices.to_handle()?)?;
    op.add_input(&a_values.to_handle()?)?;
    op.add_input(&a_shape.to_handle()?)?;
    op.add_input(&b_indices.to_handle()?)?;
    op.add_input(&b_values.to_handle()?)?;
    op.add_input(&b_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSparseMinimum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSparseMinimum {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseSparseMinimum {
    /// Creates a new `SparseSparseMinimum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_sparse_minimum with default options.
pub fn sparse_sparse_minimum<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a_indices: T0,
    a_values: T1,
    a_shape: T2,
    b_indices: T3,
    b_values: T4,
    b_shape: T5,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = SparseSparseMinimum::new();
    sparse_sparse_minimum_with_args(
        ctx, a_indices, a_values, a_shape, b_indices, b_values, b_shape, &__args,
    )
}

/// sparse_sparse_minimum with options.
pub fn sparse_sparse_minimum_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a_indices: T0,
    a_values: T1,
    a_shape: T2,
    b_indices: T3,
    b_values: T4,
    b_shape: T5,
    __args: &SparseSparseMinimum,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSparseMinimum")?;

    // Required input arguments
    op.add_input(&a_indices.to_handle()?)?;
    op.add_input(&a_values.to_handle()?)?;
    op.add_input(&a_shape.to_handle()?)?;
    op.add_input(&b_indices.to_handle()?)?;
    op.add_input(&b_values.to_handle()?)?;
    op.add_input(&b_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseSplit
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSplit {
    pub num_split: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseSplit {
    /// Creates a new `SparseSplit`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_split with default options.
pub fn sparse_split<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    split_dim: T0,
    indices: T1,
    values: T2,
    shape: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SparseSplit::new();
    sparse_split_with_args(ctx, split_dim, indices, values, shape, &__args)
}

/// sparse_split with options.
pub fn sparse_split_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    split_dim: T0,
    indices: T1,
    values: T2,
    shape: T3,
    __args: &SparseSplit,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseSplit")?;

    // Required input arguments
    op.add_input(&split_dim.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_split {
        op.set_attr_int("num_split", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SparseTensorDenseAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseTensorDenseAdd {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl SparseTensorDenseAdd {
    /// Creates a new `SparseTensorDenseAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_tensor_dense_add with default options.
pub fn sparse_tensor_dense_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a_indices: T0,
    a_values: T1,
    a_shape: T2,
    b: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseTensorDenseAdd::new();
    sparse_tensor_dense_add_with_args(ctx, a_indices, a_values, a_shape, b, &__args)
}

/// sparse_tensor_dense_add with options.
pub fn sparse_tensor_dense_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a_indices: T0,
    a_values: T1,
    a_shape: T2,
    b: T3,
    __args: &SparseTensorDenseAdd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseTensorDenseAdd")?;

    // Required input arguments
    op.add_input(&a_indices.to_handle()?)?;
    op.add_input(&a_values.to_handle()?)?;
    op.add_input(&a_shape.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseTensorDenseMatMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseTensorDenseMatMul {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub adjoint_a: ::std::option::Option<bool>,
    pub adjoint_b: ::std::option::Option<bool>,
}

impl SparseTensorDenseMatMul {
    /// Creates a new `SparseTensorDenseMatMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_tensor_dense_mat_mul with default options.
pub fn sparse_tensor_dense_mat_mul<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a_indices: T0,
    a_values: T1,
    a_shape: T2,
    b: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseTensorDenseMatMul::new();
    sparse_tensor_dense_mat_mul_with_args(ctx, a_indices, a_values, a_shape, b, &__args)
}

/// sparse_tensor_dense_mat_mul with options.
pub fn sparse_tensor_dense_mat_mul_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    a_indices: T0,
    a_values: T1,
    a_shape: T2,
    b: T3,
    __args: &SparseTensorDenseMatMul,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseTensorDenseMatMul")?;

    // Required input arguments
    op.add_input(&a_indices.to_handle()?)?;
    op.add_input(&a_values.to_handle()?)?;
    op.add_input(&a_shape.to_handle()?)?;
    op.add_input(&b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adjoint_a {
        op.set_attr_bool("adjoint_a", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.adjoint_b {
        op.set_attr_bool("adjoint_b", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseTensorSliceDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseTensorSliceDataset {
    pub Tvalues: ::std::option::Option<crate::DataType>,
}

impl SparseTensorSliceDataset {
    /// Creates a new `SparseTensorSliceDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_tensor_slice_dataset with default options.
pub fn sparse_tensor_slice_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    dense_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseTensorSliceDataset::new();
    sparse_tensor_slice_dataset_with_args(ctx, indices, values, dense_shape, &__args)
}

/// sparse_tensor_slice_dataset with options.
pub fn sparse_tensor_slice_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    dense_shape: T2,
    __args: &SparseTensorSliceDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseTensorSliceDataset")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&dense_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tvalues {
        op.set_attr_type("Tvalues", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseTensorToCSRSparseMatrix
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseTensorToCSRSparseMatrix {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseTensorToCSRSparseMatrix {
    /// Creates a new `SparseTensorToCSRSparseMatrix`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_tensor_to_csrsparse_matrix with default options.
pub fn sparse_tensor_to_csrsparse_matrix<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    dense_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseTensorToCSRSparseMatrix::new();
    sparse_tensor_to_csrsparse_matrix_with_args(ctx, indices, values, dense_shape, &__args)
}

/// sparse_tensor_to_csrsparse_matrix with options.
pub fn sparse_tensor_to_csrsparse_matrix_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    indices: T0,
    values: T1,
    dense_shape: T2,
    __args: &SparseTensorToCSRSparseMatrix,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseTensorToCSRSparseMatrix")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;
    op.add_input(&dense_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseToDense
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseToDense {
    pub validate_indices: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl SparseToDense {
    /// Creates a new `SparseToDense`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_to_dense with default options.
pub fn sparse_to_dense<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_indices: T0,
    output_shape: T1,
    sparse_values: T2,
    default_value: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = SparseToDense::new();
    sparse_to_dense_with_args(
        ctx,
        sparse_indices,
        output_shape,
        sparse_values,
        default_value,
        &__args,
    )
}

/// sparse_to_dense with options.
pub fn sparse_to_dense_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    sparse_indices: T0,
    output_shape: T1,
    sparse_values: T2,
    default_value: T3,
    __args: &SparseToDense,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseToDense")?;

    // Required input arguments
    op.add_input(&sparse_indices.to_handle()?)?;
    op.add_input(&output_shape.to_handle()?)?;
    op.add_input(&sparse_values.to_handle()?)?;
    op.add_input(&default_value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.validate_indices {
        op.set_attr_bool("validate_indices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SparseToSparseSetOperation
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseToSparseSetOperation {
    pub set_operation: ::std::option::Option<::std::string::String>,
    pub validate_indices: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl SparseToSparseSetOperation {
    /// Creates a new `SparseToSparseSetOperation`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sparse_to_sparse_set_operation with default options.
pub fn sparse_to_sparse_set_operation<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    set1_indices: T0,
    set1_values: T1,
    set1_shape: T2,
    set2_indices: T3,
    set2_values: T4,
    set2_shape: T5,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = SparseToSparseSetOperation::new();
    sparse_to_sparse_set_operation_with_args(
        ctx,
        set1_indices,
        set1_values,
        set1_shape,
        set2_indices,
        set2_values,
        set2_shape,
        &__args,
    )
}

/// sparse_to_sparse_set_operation with options.
pub fn sparse_to_sparse_set_operation_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    set1_indices: T0,
    set1_values: T1,
    set1_shape: T2,
    set2_indices: T3,
    set2_values: T4,
    set2_shape: T5,
    __args: &SparseToSparseSetOperation,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SparseToSparseSetOperation")?;

    // Required input arguments
    op.add_input(&set1_indices.to_handle()?)?;
    op.add_input(&set1_values.to_handle()?)?;
    op.add_input(&set1_shape.to_handle()?)?;
    op.add_input(&set2_indices.to_handle()?)?;
    op.add_input(&set2_values.to_handle()?)?;
    op.add_input(&set2_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.set_operation {
        op.set_attr_string("set_operation", value);
    }
    if let ::std::option::Option::Some(value) = &__args.validate_indices {
        op.set_attr_bool("validate_indices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Spence
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Spence {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Spence {
    /// Creates a new `Spence`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// spence with default options.
pub fn spence<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Spence::new();
    spence_with_args(ctx, x, &__args)
}

/// spence with options.
pub fn spence_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Spence,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Spence")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Split
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Split {
    pub num_split: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl Split {
    /// Creates a new `Split`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// split with default options.
pub fn split<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    split_dim: T0,
    value: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Split::new();
    split_with_args(ctx, split_dim, value, &__args)
}

/// split with options.
pub fn split_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    split_dim: T0,
    value: T1,
    __args: &Split,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Split")?;

    // Required input arguments
    op.add_input(&split_dim.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_split {
        op.set_attr_int("num_split", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SplitV
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SplitV {
    pub num_split: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tlen: ::std::option::Option<crate::DataType>,
}

impl SplitV {
    /// Creates a new `SplitV`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// split_v with default options.
pub fn split_v<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    value: T0,
    size_splits: T1,
    split_dim: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SplitV::new();
    split_v_with_args(ctx, value, size_splits, split_dim, &__args)
}

/// split_v with options.
pub fn split_v_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    value: T0,
    size_splits: T1,
    split_dim: T2,
    __args: &SplitV,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SplitV")?;

    // Required input arguments
    op.add_input(&value.to_handle()?)?;
    op.add_input(&size_splits.to_handle()?)?;
    op.add_input(&split_dim.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_split {
        op.set_attr_int("num_split", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tlen {
        op.set_attr_type("Tlen", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SqlDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SqlDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl SqlDataset {
    /// Creates a new `SqlDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sql_dataset with default options.
pub fn sql_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    driver_name: T0,
    data_source_name: T1,
    query: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = SqlDataset::new();
    sql_dataset_with_args(ctx, driver_name, data_source_name, query, &__args)
}

/// sql_dataset with options.
pub fn sql_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    driver_name: T0,
    data_source_name: T1,
    query: T2,
    __args: &SqlDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SqlDataset")?;

    // Required input arguments
    op.add_input(&driver_name.to_handle()?)?;
    op.add_input(&data_source_name.to_handle()?)?;
    op.add_input(&query.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Sqrt
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sqrt {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Sqrt {
    /// Creates a new `Sqrt`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sqrt with default options.
pub fn sqrt<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Sqrt::new();
    sqrt_with_args(ctx, x, &__args)
}

/// sqrt with options.
pub fn sqrt_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Sqrt,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Sqrt")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SqrtGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SqrtGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SqrtGrad {
    /// Creates a new `SqrtGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sqrt_grad with default options.
pub fn sqrt_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    dy: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SqrtGrad::new();
    sqrt_grad_with_args(ctx, y, dy, &__args)
}

/// sqrt_grad with options.
pub fn sqrt_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    dy: T1,
    __args: &SqrtGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SqrtGrad")?;

    // Required input arguments
    op.add_input(&y.to_handle()?)?;
    op.add_input(&dy.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Square
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Square {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Square {
    /// Creates a new `Square`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// square with default options.
pub fn square<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Square::new();
    square_with_args(ctx, x, &__args)
}

/// square with options.
pub fn square_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Square,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Square")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SquaredDifference
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SquaredDifference {
    pub T: ::std::option::Option<crate::DataType>,
}

impl SquaredDifference {
    /// Creates a new `SquaredDifference`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// squared_difference with default options.
pub fn squared_difference<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = SquaredDifference::new();
    squared_difference_with_args(ctx, x, y, &__args)
}

/// squared_difference with options.
pub fn squared_difference_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &SquaredDifference,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SquaredDifference")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Squeeze
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Squeeze {
    pub T: ::std::option::Option<crate::DataType>,
    pub squeeze_dims: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl Squeeze {
    /// Creates a new `Squeeze`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// squeeze with default options.
pub fn squeeze<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Squeeze::new();
    squeeze_with_args(ctx, input, &__args)
}

/// squeeze with options.
pub fn squeeze_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Squeeze,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Squeeze")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.squeeze_dims {
        op.set_attr_int_list("squeeze_dims", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Stack
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Stack {
    pub elem_type: ::std::option::Option<crate::DataType>,
    pub stack_name: ::std::option::Option<::std::string::String>,
}

impl Stack {
    /// Creates a new `Stack`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stack with default options.
pub fn stack(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = Stack::new();
    stack_with_args(ctx, &__args)
}

/// stack with options.
pub fn stack_with_args(
    ctx: &crate::eager::Context,
    __args: &Stack,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Stack")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.elem_type {
        op.set_attr_type("elem_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.stack_name {
        op.set_attr_string("stack_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StackClose
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackClose {}

impl StackClose {
    /// Creates a new `StackClose`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stack_close with default options.
pub fn stack_close<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<()> {
    let __args = StackClose::new();
    stack_close_with_args(ctx, handle, &__args)
}

/// stack_close with options.
pub fn stack_close_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &StackClose,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StackClose")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// StackCloseV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackCloseV2 {}

impl StackCloseV2 {
    /// Creates a new `StackCloseV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stack_close_v2 with default options.
pub fn stack_close_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<()> {
    let __args = StackCloseV2::new();
    stack_close_v2_with_args(ctx, handle, &__args)
}

/// stack_close_v2 with options.
pub fn stack_close_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &StackCloseV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StackCloseV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// StackPop
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackPop {
    pub elem_type: ::std::option::Option<crate::DataType>,
}

impl StackPop {
    /// Creates a new `StackPop`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stack_pop with default options.
pub fn stack_pop<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StackPop::new();
    stack_pop_with_args(ctx, handle, &__args)
}

/// stack_pop with options.
pub fn stack_pop_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &StackPop,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StackPop")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.elem_type {
        op.set_attr_type("elem_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StackPopV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackPopV2 {
    pub elem_type: ::std::option::Option<crate::DataType>,
}

impl StackPopV2 {
    /// Creates a new `StackPopV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stack_pop_v2 with default options.
pub fn stack_pop_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StackPopV2::new();
    stack_pop_v2_with_args(ctx, handle, &__args)
}

/// stack_pop_v2 with options.
pub fn stack_pop_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &StackPopV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StackPopV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.elem_type {
        op.set_attr_type("elem_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StackPush
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackPush {
    pub T: ::std::option::Option<crate::DataType>,
    pub swap_memory: ::std::option::Option<bool>,
}

impl StackPush {
    /// Creates a new `StackPush`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stack_push with default options.
pub fn stack_push<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    elem: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = StackPush::new();
    stack_push_with_args(ctx, handle, elem, &__args)
}

/// stack_push with options.
pub fn stack_push_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    elem: T1,
    __args: &StackPush,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StackPush")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&elem.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.swap_memory {
        op.set_attr_bool("swap_memory", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StackPushV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackPushV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub swap_memory: ::std::option::Option<bool>,
}

impl StackPushV2 {
    /// Creates a new `StackPushV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stack_push_v2 with default options.
pub fn stack_push_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    elem: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = StackPushV2::new();
    stack_push_v2_with_args(ctx, handle, elem, &__args)
}

/// stack_push_v2 with options.
pub fn stack_push_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    elem: T1,
    __args: &StackPushV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StackPushV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&elem.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.swap_memory {
        op.set_attr_bool("swap_memory", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StackV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackV2 {
    pub elem_type: ::std::option::Option<crate::DataType>,
    pub stack_name: ::std::option::Option<::std::string::String>,
}

impl StackV2 {
    /// Creates a new `StackV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stack_v2 with default options.
pub fn stack_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    max_size: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StackV2::new();
    stack_v2_with_args(ctx, max_size, &__args)
}

/// stack_v2 with options.
pub fn stack_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    max_size: T0,
    __args: &StackV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StackV2")?;

    // Required input arguments
    op.add_input(&max_size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.elem_type {
        op.set_attr_type("elem_type", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.stack_name {
        op.set_attr_string("stack_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Stage
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Stage {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl Stage {
    /// Creates a new `Stage`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stage with default options.
pub fn stage<T0: crate::eager::ToHandle>(ctx: &crate::eager::Context, values: T0) -> Result<()> {
    let __args = Stage::new();
    stage_with_args(ctx, values, &__args)
}

/// stage with options.
pub fn stage_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    values: T0,
    __args: &Stage,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Stage")?;

    // Required input arguments
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// StageClear
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StageClear {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl StageClear {
    /// Creates a new `StageClear`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stage_clear with default options.
pub fn stage_clear(ctx: &crate::eager::Context) -> Result<()> {
    let __args = StageClear::new();
    stage_clear_with_args(ctx, &__args)
}

/// stage_clear with options.
pub fn stage_clear_with_args(ctx: &crate::eager::Context, __args: &StageClear) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StageClear")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// StagePeek
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StagePeek {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl StagePeek {
    /// Creates a new `StagePeek`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stage_peek with default options.
pub fn stage_peek<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    index: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StagePeek::new();
    stage_peek_with_args(ctx, index, &__args)
}

/// stage_peek with options.
pub fn stage_peek_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    index: T0,
    __args: &StagePeek,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StagePeek")?;

    // Required input arguments
    op.add_input(&index.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StageSize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StageSize {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl StageSize {
    /// Creates a new `StageSize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stage_size with default options.
pub fn stage_size(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = StageSize::new();
    stage_size_with_args(ctx, &__args)
}

/// stage_size with options.
pub fn stage_size_with_args(
    ctx: &crate::eager::Context,
    __args: &StageSize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StageSize")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatefulPartitionedCall
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulPartitionedCall {
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub f: ::std::option::Option<::std::string::String>,
    pub config: ::std::option::Option<::std::string::String>,
    pub config_proto: ::std::option::Option<::std::string::String>,
    pub executor_type: ::std::option::Option<::std::string::String>,
}

impl StatefulPartitionedCall {
    /// Creates a new `StatefulPartitionedCall`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateful_partitioned_call with default options.
pub fn stateful_partitioned_call<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    args: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatefulPartitionedCall::new();
    stateful_partitioned_call_with_args(ctx, args, &__args)
}

/// stateful_partitioned_call with options.
pub fn stateful_partitioned_call_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    args: T0,
    __args: &StatefulPartitionedCall,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatefulPartitionedCall")?;

    // Required input arguments
    op.add_input(&args.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.config {
        op.set_attr_string("config", value);
    }
    if let ::std::option::Option::Some(value) = &__args.config_proto {
        op.set_attr_string("config_proto", value);
    }
    if let ::std::option::Option::Some(value) = &__args.executor_type {
        op.set_attr_string("executor_type", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatefulRandomBinomial
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulRandomBinomial {
    pub S: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl StatefulRandomBinomial {
    /// Creates a new `StatefulRandomBinomial`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateful_random_binomial with default options.
pub fn stateful_random_binomial<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    shape: T2,
    counts: T3,
    probs: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatefulRandomBinomial::new();
    stateful_random_binomial_with_args(ctx, resource, algorithm, shape, counts, probs, &__args)
}

/// stateful_random_binomial with options.
pub fn stateful_random_binomial_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    shape: T2,
    counts: T3,
    probs: T4,
    __args: &StatefulRandomBinomial,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatefulRandomBinomial")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&algorithm.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&counts.to_handle()?)?;
    op.add_input(&probs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.S {
        op.set_attr_type("S", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatefulStandardNormal
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulStandardNormal {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape_dtype: ::std::option::Option<crate::DataType>,
}

impl StatefulStandardNormal {
    /// Creates a new `StatefulStandardNormal`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateful_standard_normal with default options.
pub fn stateful_standard_normal<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    shape: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatefulStandardNormal::new();
    stateful_standard_normal_with_args(ctx, resource, shape, &__args)
}

/// stateful_standard_normal with options.
pub fn stateful_standard_normal_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    shape: T1,
    __args: &StatefulStandardNormal,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatefulStandardNormal")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_dtype {
        op.set_attr_type("shape_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatefulStandardNormalV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulStandardNormalV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape_dtype: ::std::option::Option<crate::DataType>,
}

impl StatefulStandardNormalV2 {
    /// Creates a new `StatefulStandardNormalV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateful_standard_normal_v2 with default options.
pub fn stateful_standard_normal_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatefulStandardNormalV2::new();
    stateful_standard_normal_v2_with_args(ctx, resource, algorithm, shape, &__args)
}

/// stateful_standard_normal_v2 with options.
pub fn stateful_standard_normal_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    shape: T2,
    __args: &StatefulStandardNormalV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatefulStandardNormalV2")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&algorithm.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_dtype {
        op.set_attr_type("shape_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatefulTruncatedNormal
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulTruncatedNormal {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape_dtype: ::std::option::Option<crate::DataType>,
}

impl StatefulTruncatedNormal {
    /// Creates a new `StatefulTruncatedNormal`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateful_truncated_normal with default options.
pub fn stateful_truncated_normal<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatefulTruncatedNormal::new();
    stateful_truncated_normal_with_args(ctx, resource, algorithm, shape, &__args)
}

/// stateful_truncated_normal with options.
pub fn stateful_truncated_normal_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    shape: T2,
    __args: &StatefulTruncatedNormal,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatefulTruncatedNormal")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&algorithm.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_dtype {
        op.set_attr_type("shape_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatefulUniform
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulUniform {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape_dtype: ::std::option::Option<crate::DataType>,
}

impl StatefulUniform {
    /// Creates a new `StatefulUniform`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateful_uniform with default options.
pub fn stateful_uniform<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatefulUniform::new();
    stateful_uniform_with_args(ctx, resource, algorithm, shape, &__args)
}

/// stateful_uniform with options.
pub fn stateful_uniform_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    shape: T2,
    __args: &StatefulUniform,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatefulUniform")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&algorithm.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_dtype {
        op.set_attr_type("shape_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatefulUniformFullInt
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulUniformFullInt {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape_dtype: ::std::option::Option<crate::DataType>,
}

impl StatefulUniformFullInt {
    /// Creates a new `StatefulUniformFullInt`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateful_uniform_full_int with default options.
pub fn stateful_uniform_full_int<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatefulUniformFullInt::new();
    stateful_uniform_full_int_with_args(ctx, resource, algorithm, shape, &__args)
}

/// stateful_uniform_full_int with options.
pub fn stateful_uniform_full_int_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    shape: T2,
    __args: &StatefulUniformFullInt,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatefulUniformFullInt")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&algorithm.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_dtype {
        op.set_attr_type("shape_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatefulUniformInt
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulUniformInt {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape_dtype: ::std::option::Option<crate::DataType>,
}

impl StatefulUniformInt {
    /// Creates a new `StatefulUniformInt`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateful_uniform_int with default options.
pub fn stateful_uniform_int<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    shape: T2,
    minval: T3,
    maxval: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatefulUniformInt::new();
    stateful_uniform_int_with_args(ctx, resource, algorithm, shape, minval, maxval, &__args)
}

/// stateful_uniform_int with options.
pub fn stateful_uniform_int_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    resource: T0,
    algorithm: T1,
    shape: T2,
    minval: T3,
    maxval: T4,
    __args: &StatefulUniformInt,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatefulUniformInt")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;
    op.add_input(&algorithm.to_handle()?)?;
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&minval.to_handle()?)?;
    op.add_input(&maxval.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_dtype {
        op.set_attr_type("shape_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessCase
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessCase {
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub branches: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl StatelessCase {
    /// Creates a new `StatelessCase`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_case with default options.
pub fn stateless_case<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    branch_index: T0,
    input: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessCase::new();
    stateless_case_with_args(ctx, branch_index, input, &__args)
}

/// stateless_case with options.
pub fn stateless_case_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    branch_index: T0,
    input: T1,
    __args: &StatelessCase,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessCase")?;

    // Required input arguments
    op.add_input(&branch_index.to_handle()?)?;
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }
    if let ::std::option::Option::Some(value) = &__args.branches {
        op.set_attr_string_list("branches", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessIf
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessIf {
    pub Tcond: ::std::option::Option<crate::DataType>,
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub then_branch: ::std::option::Option<::std::string::String>,
    pub else_branch: ::std::option::Option<::std::string::String>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl StatelessIf {
    /// Creates a new `StatelessIf`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_if with default options.
pub fn stateless_if<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    cond: T0,
    input: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessIf::new();
    stateless_if_with_args(ctx, cond, input, &__args)
}

/// stateless_if with options.
pub fn stateless_if_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    cond: T0,
    input: T1,
    __args: &StatelessIf,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessIf")?;

    // Required input arguments
    op.add_input(&cond.to_handle()?)?;
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tcond {
        op.set_attr_type("Tcond", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }
    if let ::std::option::Option::Some(value) = &__args.then_branch {
        op.set_attr_string("then_branch", value);
    }
    if let ::std::option::Option::Some(value) = &__args.else_branch {
        op.set_attr_string("else_branch", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessMultinomial
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessMultinomial {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tseed: ::std::option::Option<crate::DataType>,
    pub output_dtype: ::std::option::Option<crate::DataType>,
}

impl StatelessMultinomial {
    /// Creates a new `StatelessMultinomial`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_multinomial with default options.
pub fn stateless_multinomial<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    logits: T0,
    num_samples: T1,
    seed: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessMultinomial::new();
    stateless_multinomial_with_args(ctx, logits, num_samples, seed, &__args)
}

/// stateless_multinomial with options.
pub fn stateless_multinomial_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    logits: T0,
    num_samples: T1,
    seed: T2,
    __args: &StatelessMultinomial,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessMultinomial")?;

    // Required input arguments
    op.add_input(&logits.to_handle()?)?;
    op.add_input(&num_samples.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_dtype {
        op.set_attr_type("output_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessParameterizedTruncatedNormal
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessParameterizedTruncatedNormal {
    pub S: ::std::option::Option<crate::DataType>,
    pub Tseed: ::std::option::Option<crate::DataType>,
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl StatelessParameterizedTruncatedNormal {
    /// Creates a new `StatelessParameterizedTruncatedNormal`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_parameterized_truncated_normal with default options.
pub fn stateless_parameterized_truncated_normal<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    means: T2,
    stddevs: T3,
    minvals: T4,
    maxvals: T5,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessParameterizedTruncatedNormal::new();
    stateless_parameterized_truncated_normal_with_args(
        ctx, shape, seed, means, stddevs, minvals, maxvals, &__args,
    )
}

/// stateless_parameterized_truncated_normal with options.
pub fn stateless_parameterized_truncated_normal_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    means: T2,
    stddevs: T3,
    minvals: T4,
    maxvals: T5,
    __args: &StatelessParameterizedTruncatedNormal,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessParameterizedTruncatedNormal")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&means.to_handle()?)?;
    op.add_input(&stddevs.to_handle()?)?;
    op.add_input(&minvals.to_handle()?)?;
    op.add_input(&maxvals.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.S {
        op.set_attr_type("S", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomBinomial
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomBinomial {
    pub S: ::std::option::Option<crate::DataType>,
    pub Tseed: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomBinomial {
    /// Creates a new `StatelessRandomBinomial`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_binomial with default options.
pub fn stateless_random_binomial<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    counts: T2,
    probs: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessRandomBinomial::new();
    stateless_random_binomial_with_args(ctx, shape, seed, counts, probs, &__args)
}

/// stateless_random_binomial with options.
pub fn stateless_random_binomial_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    counts: T2,
    probs: T3,
    __args: &StatelessRandomBinomial,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomBinomial")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&counts.to_handle()?)?;
    op.add_input(&probs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.S {
        op.set_attr_type("S", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomGammaV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomGammaV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tseed: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomGammaV2 {
    /// Creates a new `StatelessRandomGammaV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_gamma_v2 with default options.
pub fn stateless_random_gamma_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    alpha: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessRandomGammaV2::new();
    stateless_random_gamma_v2_with_args(ctx, shape, seed, alpha, &__args)
}

/// stateless_random_gamma_v2 with options.
pub fn stateless_random_gamma_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    alpha: T2,
    __args: &StatelessRandomGammaV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomGammaV2")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&alpha.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomGetAlg
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomGetAlg {}

impl StatelessRandomGetAlg {
    /// Creates a new `StatelessRandomGetAlg`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_get_alg with default options.
pub fn stateless_random_get_alg(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessRandomGetAlg::new();
    stateless_random_get_alg_with_args(ctx, &__args)
}

/// stateless_random_get_alg with options.
pub fn stateless_random_get_alg_with_args(
    ctx: &crate::eager::Context,
    __args: &StatelessRandomGetAlg,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomGetAlg")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomGetKeyCounter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomGetKeyCounter {
    pub Tseed: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomGetKeyCounter {
    /// Creates a new `StatelessRandomGetKeyCounter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_get_key_counter with default options.
pub fn stateless_random_get_key_counter<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    seed: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = StatelessRandomGetKeyCounter::new();
    stateless_random_get_key_counter_with_args(ctx, seed, &__args)
}

/// stateless_random_get_key_counter with options.
pub fn stateless_random_get_key_counter_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    seed: T0,
    __args: &StatelessRandomGetKeyCounter,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomGetKeyCounter")?;

    // Required input arguments
    op.add_input(&seed.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomGetKeyCounterAlg
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomGetKeyCounterAlg {
    pub Tseed: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomGetKeyCounterAlg {
    /// Creates a new `StatelessRandomGetKeyCounterAlg`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_get_key_counter_alg with default options.
pub fn stateless_random_get_key_counter_alg<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    seed: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = StatelessRandomGetKeyCounterAlg::new();
    stateless_random_get_key_counter_alg_with_args(ctx, seed, &__args)
}

/// stateless_random_get_key_counter_alg with options.
pub fn stateless_random_get_key_counter_alg_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    seed: T0,
    __args: &StatelessRandomGetKeyCounterAlg,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomGetKeyCounterAlg")?;

    // Required input arguments
    op.add_input(&seed.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomNormal
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomNormal {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tseed: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomNormal {
    /// Creates a new `StatelessRandomNormal`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_normal with default options.
pub fn stateless_random_normal<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessRandomNormal::new();
    stateless_random_normal_with_args(ctx, shape, seed, &__args)
}

/// stateless_random_normal with options.
pub fn stateless_random_normal_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    __args: &StatelessRandomNormal,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomNormal")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomNormalV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomNormalV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tshape: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomNormalV2 {
    /// Creates a new `StatelessRandomNormalV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_normal_v2 with default options.
pub fn stateless_random_normal_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    key: T1,
    counter: T2,
    alg: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessRandomNormalV2::new();
    stateless_random_normal_v2_with_args(ctx, shape, key, counter, alg, &__args)
}

/// stateless_random_normal_v2 with options.
pub fn stateless_random_normal_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    key: T1,
    counter: T2,
    alg: T3,
    __args: &StatelessRandomNormalV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomNormalV2")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&key.to_handle()?)?;
    op.add_input(&counter.to_handle()?)?;
    op.add_input(&alg.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshape {
        op.set_attr_type("Tshape", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomPoisson
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomPoisson {
    pub Rtype: ::std::option::Option<crate::DataType>,
    pub dtype: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tseed: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomPoisson {
    /// Creates a new `StatelessRandomPoisson`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_poisson with default options.
pub fn stateless_random_poisson<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    lam: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessRandomPoisson::new();
    stateless_random_poisson_with_args(ctx, shape, seed, lam, &__args)
}

/// stateless_random_poisson with options.
pub fn stateless_random_poisson_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    lam: T2,
    __args: &StatelessRandomPoisson,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomPoisson")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&lam.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Rtype {
        op.set_attr_type("Rtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomUniform
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomUniform {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tseed: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomUniform {
    /// Creates a new `StatelessRandomUniform`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_uniform with default options.
pub fn stateless_random_uniform<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessRandomUniform::new();
    stateless_random_uniform_with_args(ctx, shape, seed, &__args)
}

/// stateless_random_uniform with options.
pub fn stateless_random_uniform_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    __args: &StatelessRandomUniform,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomUniform")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomUniformFullInt
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomUniformFullInt {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tseed: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomUniformFullInt {
    /// Creates a new `StatelessRandomUniformFullInt`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_uniform_full_int with default options.
pub fn stateless_random_uniform_full_int<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessRandomUniformFullInt::new();
    stateless_random_uniform_full_int_with_args(ctx, shape, seed, &__args)
}

/// stateless_random_uniform_full_int with options.
pub fn stateless_random_uniform_full_int_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    __args: &StatelessRandomUniformFullInt,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomUniformFullInt")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomUniformFullIntV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomUniformFullIntV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tshape: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomUniformFullIntV2 {
    /// Creates a new `StatelessRandomUniformFullIntV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_uniform_full_int_v2 with default options.
pub fn stateless_random_uniform_full_int_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    key: T1,
    counter: T2,
    alg: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessRandomUniformFullIntV2::new();
    stateless_random_uniform_full_int_v2_with_args(ctx, shape, key, counter, alg, &__args)
}

/// stateless_random_uniform_full_int_v2 with options.
pub fn stateless_random_uniform_full_int_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    key: T1,
    counter: T2,
    alg: T3,
    __args: &StatelessRandomUniformFullIntV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomUniformFullIntV2")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&key.to_handle()?)?;
    op.add_input(&counter.to_handle()?)?;
    op.add_input(&alg.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshape {
        op.set_attr_type("Tshape", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomUniformInt
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomUniformInt {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tseed: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomUniformInt {
    /// Creates a new `StatelessRandomUniformInt`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_uniform_int with default options.
pub fn stateless_random_uniform_int<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    minval: T2,
    maxval: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessRandomUniformInt::new();
    stateless_random_uniform_int_with_args(ctx, shape, seed, minval, maxval, &__args)
}

/// stateless_random_uniform_int with options.
pub fn stateless_random_uniform_int_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    minval: T2,
    maxval: T3,
    __args: &StatelessRandomUniformInt,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomUniformInt")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;
    op.add_input(&minval.to_handle()?)?;
    op.add_input(&maxval.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomUniformIntV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomUniformIntV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tshape: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomUniformIntV2 {
    /// Creates a new `StatelessRandomUniformIntV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_uniform_int_v2 with default options.
pub fn stateless_random_uniform_int_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    key: T1,
    counter: T2,
    alg: T3,
    minval: T4,
    maxval: T5,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessRandomUniformIntV2::new();
    stateless_random_uniform_int_v2_with_args(
        ctx, shape, key, counter, alg, minval, maxval, &__args,
    )
}

/// stateless_random_uniform_int_v2 with options.
pub fn stateless_random_uniform_int_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
    T5: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    key: T1,
    counter: T2,
    alg: T3,
    minval: T4,
    maxval: T5,
    __args: &StatelessRandomUniformIntV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomUniformIntV2")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&key.to_handle()?)?;
    op.add_input(&counter.to_handle()?)?;
    op.add_input(&alg.to_handle()?)?;
    op.add_input(&minval.to_handle()?)?;
    op.add_input(&maxval.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshape {
        op.set_attr_type("Tshape", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessRandomUniformV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomUniformV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tshape: ::std::option::Option<crate::DataType>,
}

impl StatelessRandomUniformV2 {
    /// Creates a new `StatelessRandomUniformV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_random_uniform_v2 with default options.
pub fn stateless_random_uniform_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    key: T1,
    counter: T2,
    alg: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessRandomUniformV2::new();
    stateless_random_uniform_v2_with_args(ctx, shape, key, counter, alg, &__args)
}

/// stateless_random_uniform_v2 with options.
pub fn stateless_random_uniform_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    key: T1,
    counter: T2,
    alg: T3,
    __args: &StatelessRandomUniformV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessRandomUniformV2")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&key.to_handle()?)?;
    op.add_input(&counter.to_handle()?)?;
    op.add_input(&alg.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshape {
        op.set_attr_type("Tshape", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessSampleDistortedBoundingBox
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessSampleDistortedBoundingBox {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tseed: ::std::option::Option<crate::DataType>,
    pub aspect_ratio_range: ::std::option::Option<::std::vec::Vec<f32>>,
    pub area_range: ::std::option::Option<::std::vec::Vec<f32>>,
    pub max_attempts: ::std::option::Option<i64>,
    pub use_image_if_no_bounding_boxes: ::std::option::Option<bool>,
}

impl StatelessSampleDistortedBoundingBox {
    /// Creates a new `StatelessSampleDistortedBoundingBox`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_sample_distorted_bounding_box with default options.
pub fn stateless_sample_distorted_bounding_box<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    image_size: T0,
    bounding_boxes: T1,
    min_object_covered: T2,
    seed: T3,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = StatelessSampleDistortedBoundingBox::new();
    stateless_sample_distorted_bounding_box_with_args(
        ctx,
        image_size,
        bounding_boxes,
        min_object_covered,
        seed,
        &__args,
    )
}

/// stateless_sample_distorted_bounding_box with options.
pub fn stateless_sample_distorted_bounding_box_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    image_size: T0,
    bounding_boxes: T1,
    min_object_covered: T2,
    seed: T3,
    __args: &StatelessSampleDistortedBoundingBox,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessSampleDistortedBoundingBox")?;

    // Required input arguments
    op.add_input(&image_size.to_handle()?)?;
    op.add_input(&bounding_boxes.to_handle()?)?;
    op.add_input(&min_object_covered.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.aspect_ratio_range {
        op.set_attr_float_list("aspect_ratio_range", value);
    }
    if let ::std::option::Option::Some(value) = &__args.area_range {
        op.set_attr_float_list("area_range", value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_attempts {
        op.set_attr_int("max_attempts", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_image_if_no_bounding_boxes {
        op.set_attr_bool("use_image_if_no_bounding_boxes", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessTruncatedNormal
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessTruncatedNormal {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tseed: ::std::option::Option<crate::DataType>,
}

impl StatelessTruncatedNormal {
    /// Creates a new `StatelessTruncatedNormal`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_truncated_normal with default options.
pub fn stateless_truncated_normal<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessTruncatedNormal::new();
    stateless_truncated_normal_with_args(ctx, shape, seed, &__args)
}

/// stateless_truncated_normal with options.
pub fn stateless_truncated_normal_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    seed: T1,
    __args: &StatelessTruncatedNormal,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessTruncatedNormal")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&seed.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tseed {
        op.set_attr_type("Tseed", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessTruncatedNormalV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessTruncatedNormalV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub Tshape: ::std::option::Option<crate::DataType>,
}

impl StatelessTruncatedNormalV2 {
    /// Creates a new `StatelessTruncatedNormalV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_truncated_normal_v2 with default options.
pub fn stateless_truncated_normal_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    key: T1,
    counter: T2,
    alg: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessTruncatedNormalV2::new();
    stateless_truncated_normal_v2_with_args(ctx, shape, key, counter, alg, &__args)
}

/// stateless_truncated_normal_v2 with options.
pub fn stateless_truncated_normal_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    key: T1,
    counter: T2,
    alg: T3,
    __args: &StatelessTruncatedNormalV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessTruncatedNormalV2")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&key.to_handle()?)?;
    op.add_input(&counter.to_handle()?)?;
    op.add_input(&alg.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tshape {
        op.set_attr_type("Tshape", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatelessWhile
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessWhile {
    pub T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub cond: ::std::option::Option<::std::string::String>,
    pub body: ::std::option::Option<::std::string::String>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub parallel_iterations: ::std::option::Option<i64>,
}

impl StatelessWhile {
    /// Creates a new `StatelessWhile`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stateless_while with default options.
pub fn stateless_while<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatelessWhile::new();
    stateless_while_with_args(ctx, input, &__args)
}

/// stateless_while with options.
pub fn stateless_while_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &StatelessWhile,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatelessWhile")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type_list("T", value);
    }
    if let ::std::option::Option::Some(value) = &__args.cond {
        op.set_attr_string("cond", value);
    }
    if let ::std::option::Option::Some(value) = &__args.body {
        op.set_attr_string("body", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.parallel_iterations {
        op.set_attr_int("parallel_iterations", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StaticRegexFullMatch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StaticRegexFullMatch {
    pub pattern: ::std::option::Option<::std::string::String>,
}

impl StaticRegexFullMatch {
    /// Creates a new `StaticRegexFullMatch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// static_regex_full_match with default options.
pub fn static_regex_full_match<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StaticRegexFullMatch::new();
    static_regex_full_match_with_args(ctx, input, &__args)
}

/// static_regex_full_match with options.
pub fn static_regex_full_match_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &StaticRegexFullMatch,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StaticRegexFullMatch")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.pattern {
        op.set_attr_string("pattern", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StaticRegexReplace
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StaticRegexReplace {
    pub pattern: ::std::option::Option<::std::string::String>,
    pub rewrite: ::std::option::Option<::std::string::String>,
    pub replace_global: ::std::option::Option<bool>,
}

impl StaticRegexReplace {
    /// Creates a new `StaticRegexReplace`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// static_regex_replace with default options.
pub fn static_regex_replace<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StaticRegexReplace::new();
    static_regex_replace_with_args(ctx, input, &__args)
}

/// static_regex_replace with options.
pub fn static_regex_replace_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &StaticRegexReplace,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StaticRegexReplace")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.pattern {
        op.set_attr_string("pattern", value);
    }
    if let ::std::option::Option::Some(value) = &__args.rewrite {
        op.set_attr_string("rewrite", value);
    }
    if let ::std::option::Option::Some(value) = &__args.replace_global {
        op.set_attr_bool("replace_global", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatsAggregatorHandle
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatsAggregatorHandle {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl StatsAggregatorHandle {
    /// Creates a new `StatsAggregatorHandle`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stats_aggregator_handle with default options.
pub fn stats_aggregator_handle(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = StatsAggregatorHandle::new();
    stats_aggregator_handle_with_args(ctx, &__args)
}

/// stats_aggregator_handle with options.
pub fn stats_aggregator_handle_with_args(
    ctx: &crate::eager::Context,
    __args: &StatsAggregatorHandle,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatsAggregatorHandle")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatsAggregatorHandleV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatsAggregatorHandleV2 {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl StatsAggregatorHandleV2 {
    /// Creates a new `StatsAggregatorHandleV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stats_aggregator_handle_v2 with default options.
pub fn stats_aggregator_handle_v2(
    ctx: &crate::eager::Context,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatsAggregatorHandleV2::new();
    stats_aggregator_handle_v2_with_args(ctx, &__args)
}

/// stats_aggregator_handle_v2 with options.
pub fn stats_aggregator_handle_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &StatsAggregatorHandleV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatsAggregatorHandleV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StatsAggregatorSetSummaryWriter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatsAggregatorSetSummaryWriter {}

impl StatsAggregatorSetSummaryWriter {
    /// Creates a new `StatsAggregatorSetSummaryWriter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stats_aggregator_set_summary_writer with default options.
pub fn stats_aggregator_set_summary_writer<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    stats_aggregator: T0,
    summary: T1,
) -> Result<()> {
    let __args = StatsAggregatorSetSummaryWriter::new();
    stats_aggregator_set_summary_writer_with_args(ctx, stats_aggregator, summary, &__args)
}

/// stats_aggregator_set_summary_writer with options.
pub fn stats_aggregator_set_summary_writer_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    stats_aggregator: T0,
    summary: T1,
    __args: &StatsAggregatorSetSummaryWriter,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatsAggregatorSetSummaryWriter")?;

    // Required input arguments
    op.add_input(&stats_aggregator.to_handle()?)?;
    op.add_input(&summary.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// StatsAggregatorSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatsAggregatorSummary {}

impl StatsAggregatorSummary {
    /// Creates a new `StatsAggregatorSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stats_aggregator_summary with default options.
pub fn stats_aggregator_summary<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    iterator: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StatsAggregatorSummary::new();
    stats_aggregator_summary_with_args(ctx, iterator, &__args)
}

/// stats_aggregator_summary with options.
pub fn stats_aggregator_summary_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    iterator: T0,
    __args: &StatsAggregatorSummary,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StatsAggregatorSummary")?;

    // Required input arguments
    op.add_input(&iterator.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StopGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StopGradient {
    pub T: ::std::option::Option<crate::DataType>,
}

impl StopGradient {
    /// Creates a new `StopGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// stop_gradient with default options.
pub fn stop_gradient<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StopGradient::new();
    stop_gradient_with_args(ctx, input, &__args)
}

/// stop_gradient with options.
pub fn stop_gradient_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &StopGradient,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StopGradient")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StridedSlice
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StridedSlice {
    pub T: ::std::option::Option<crate::DataType>,
    pub Index: ::std::option::Option<crate::DataType>,
    pub begin_mask: ::std::option::Option<i64>,
    pub end_mask: ::std::option::Option<i64>,
    pub ellipsis_mask: ::std::option::Option<i64>,
    pub new_axis_mask: ::std::option::Option<i64>,
    pub shrink_axis_mask: ::std::option::Option<i64>,
}

impl StridedSlice {
    /// Creates a new `StridedSlice`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// strided_slice with default options.
pub fn strided_slice<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    begin: T1,
    end: T2,
    strides: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = StridedSlice::new();
    strided_slice_with_args(ctx, input, begin, end, strides, &__args)
}

/// strided_slice with options.
pub fn strided_slice_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    begin: T1,
    end: T2,
    strides: T3,
    __args: &StridedSlice,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StridedSlice")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&begin.to_handle()?)?;
    op.add_input(&end.to_handle()?)?;
    op.add_input(&strides.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Index {
        op.set_attr_type("Index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.begin_mask {
        op.set_attr_int("begin_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.end_mask {
        op.set_attr_int("end_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ellipsis_mask {
        op.set_attr_int("ellipsis_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.new_axis_mask {
        op.set_attr_int("new_axis_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shrink_axis_mask {
        op.set_attr_int("shrink_axis_mask", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StridedSliceAssign
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StridedSliceAssign {
    pub T: ::std::option::Option<crate::DataType>,
    pub Index: ::std::option::Option<crate::DataType>,
    pub begin_mask: ::std::option::Option<i64>,
    pub end_mask: ::std::option::Option<i64>,
    pub ellipsis_mask: ::std::option::Option<i64>,
    pub new_axis_mask: ::std::option::Option<i64>,
    pub shrink_axis_mask: ::std::option::Option<i64>,
}

impl StridedSliceAssign {
    /// Creates a new `StridedSliceAssign`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// strided_slice_assign with default options.
pub fn strided_slice_assign<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    begin: T1,
    end: T2,
    strides: T3,
    value: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = StridedSliceAssign::new();
    strided_slice_assign_with_args(ctx, ref_, begin, end, strides, value, &__args)
}

/// strided_slice_assign with options.
pub fn strided_slice_assign_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    ref_: T0,
    begin: T1,
    end: T2,
    strides: T3,
    value: T4,
    __args: &StridedSliceAssign,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StridedSliceAssign")?;

    // Required input arguments
    op.add_input(&ref_.to_handle()?)?;
    op.add_input(&begin.to_handle()?)?;
    op.add_input(&end.to_handle()?)?;
    op.add_input(&strides.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Index {
        op.set_attr_type("Index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.begin_mask {
        op.set_attr_int("begin_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.end_mask {
        op.set_attr_int("end_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ellipsis_mask {
        op.set_attr_int("ellipsis_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.new_axis_mask {
        op.set_attr_int("new_axis_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shrink_axis_mask {
        op.set_attr_int("shrink_axis_mask", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StridedSliceGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StridedSliceGrad {
    pub T: ::std::option::Option<crate::DataType>,
    pub Index: ::std::option::Option<crate::DataType>,
    pub begin_mask: ::std::option::Option<i64>,
    pub end_mask: ::std::option::Option<i64>,
    pub ellipsis_mask: ::std::option::Option<i64>,
    pub new_axis_mask: ::std::option::Option<i64>,
    pub shrink_axis_mask: ::std::option::Option<i64>,
}

impl StridedSliceGrad {
    /// Creates a new `StridedSliceGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// strided_slice_grad with default options.
pub fn strided_slice_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    begin: T1,
    end: T2,
    strides: T3,
    dy: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = StridedSliceGrad::new();
    strided_slice_grad_with_args(ctx, shape, begin, end, strides, dy, &__args)
}

/// strided_slice_grad with options.
pub fn strided_slice_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    shape: T0,
    begin: T1,
    end: T2,
    strides: T3,
    dy: T4,
    __args: &StridedSliceGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StridedSliceGrad")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;
    op.add_input(&begin.to_handle()?)?;
    op.add_input(&end.to_handle()?)?;
    op.add_input(&strides.to_handle()?)?;
    op.add_input(&dy.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Index {
        op.set_attr_type("Index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.begin_mask {
        op.set_attr_int("begin_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.end_mask {
        op.set_attr_int("end_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ellipsis_mask {
        op.set_attr_int("ellipsis_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.new_axis_mask {
        op.set_attr_int("new_axis_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shrink_axis_mask {
        op.set_attr_int("shrink_axis_mask", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StringFormat
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringFormat {
    pub T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub template: ::std::option::Option<::std::string::String>,
    pub placeholder: ::std::option::Option<::std::string::String>,
    pub summarize: ::std::option::Option<i64>,
}

impl StringFormat {
    /// Creates a new `StringFormat`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_format with default options.
pub fn string_format<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StringFormat::new();
    string_format_with_args(ctx, inputs, &__args)
}

/// string_format with options.
pub fn string_format_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &StringFormat,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringFormat")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type_list("T", value);
    }
    if let ::std::option::Option::Some(value) = &__args.template {
        op.set_attr_string("template", value);
    }
    if let ::std::option::Option::Some(value) = &__args.placeholder {
        op.set_attr_string("placeholder", value);
    }
    if let ::std::option::Option::Some(value) = &__args.summarize {
        op.set_attr_int("summarize", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StringJoin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringJoin {
    pub N: ::std::option::Option<i64>,
    pub separator: ::std::option::Option<::std::string::String>,
}

impl StringJoin {
    /// Creates a new `StringJoin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_join with default options.
pub fn string_join<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StringJoin::new();
    string_join_with_args(ctx, inputs, &__args)
}

/// string_join with options.
pub fn string_join_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &StringJoin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringJoin")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.separator {
        op.set_attr_string("separator", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StringLength
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringLength {
    pub unit: ::std::option::Option<::std::string::String>,
}

impl StringLength {
    /// Creates a new `StringLength`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_length with default options.
pub fn string_length<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StringLength::new();
    string_length_with_args(ctx, input, &__args)
}

/// string_length with options.
pub fn string_length_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &StringLength,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringLength")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.unit {
        op.set_attr_string("unit", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StringLower
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringLower {
    pub encoding: ::std::option::Option<::std::string::String>,
}

impl StringLower {
    /// Creates a new `StringLower`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_lower with default options.
pub fn string_lower<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StringLower::new();
    string_lower_with_args(ctx, input, &__args)
}

/// string_lower with options.
pub fn string_lower_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &StringLower,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringLower")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.encoding {
        op.set_attr_string("encoding", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StringNGrams
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringNGrams {
    pub separator: ::std::option::Option<::std::string::String>,
    pub ngram_widths: ::std::option::Option<::std::vec::Vec<i64>>,
    pub left_pad: ::std::option::Option<::std::string::String>,
    pub right_pad: ::std::option::Option<::std::string::String>,
    pub pad_width: ::std::option::Option<i64>,
    pub preserve_short_sequences: ::std::option::Option<bool>,
    pub Tsplits: ::std::option::Option<crate::DataType>,
}

impl StringNGrams {
    /// Creates a new `StringNGrams`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_ngrams with default options.
pub fn string_ngrams<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    data_splits: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = StringNGrams::new();
    string_ngrams_with_args(ctx, data, data_splits, &__args)
}

/// string_ngrams with options.
pub fn string_ngrams_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    data_splits: T1,
    __args: &StringNGrams,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringNGrams")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&data_splits.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.separator {
        op.set_attr_string("separator", value);
    }
    if let ::std::option::Option::Some(value) = &__args.ngram_widths {
        op.set_attr_int_list("ngram_widths", value);
    }
    if let ::std::option::Option::Some(value) = &__args.left_pad {
        op.set_attr_string("left_pad", value);
    }
    if let ::std::option::Option::Some(value) = &__args.right_pad {
        op.set_attr_string("right_pad", value);
    }
    if let ::std::option::Option::Some(value) = &__args.pad_width {
        op.set_attr_int("pad_width", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.preserve_short_sequences {
        op.set_attr_bool("preserve_short_sequences", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsplits {
        op.set_attr_type("Tsplits", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// StringSplit
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringSplit {
    pub skip_empty: ::std::option::Option<bool>,
}

impl StringSplit {
    /// Creates a new `StringSplit`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_split with default options.
pub fn string_split<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    delimiter: T1,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = StringSplit::new();
    string_split_with_args(ctx, input, delimiter, &__args)
}

/// string_split with options.
pub fn string_split_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    delimiter: T1,
    __args: &StringSplit,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringSplit")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&delimiter.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.skip_empty {
        op.set_attr_bool("skip_empty", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// StringSplitV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringSplitV2 {
    pub maxsplit: ::std::option::Option<i64>,
}

impl StringSplitV2 {
    /// Creates a new `StringSplitV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_split_v2 with default options.
pub fn string_split_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    sep: T1,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = StringSplitV2::new();
    string_split_v2_with_args(ctx, input, sep, &__args)
}

/// string_split_v2 with options.
pub fn string_split_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    sep: T1,
    __args: &StringSplitV2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringSplitV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&sep.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.maxsplit {
        op.set_attr_int("maxsplit", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// StringStrip
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringStrip {}

impl StringStrip {
    /// Creates a new `StringStrip`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_strip with default options.
pub fn string_strip<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StringStrip::new();
    string_strip_with_args(ctx, input, &__args)
}

/// string_strip with options.
pub fn string_strip_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &StringStrip,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringStrip")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StringToHashBucket
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringToHashBucket {
    pub num_buckets: ::std::option::Option<i64>,
}

impl StringToHashBucket {
    /// Creates a new `StringToHashBucket`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_to_hash_bucket with default options.
pub fn string_to_hash_bucket<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    string_tensor: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StringToHashBucket::new();
    string_to_hash_bucket_with_args(ctx, string_tensor, &__args)
}

/// string_to_hash_bucket with options.
pub fn string_to_hash_bucket_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    string_tensor: T0,
    __args: &StringToHashBucket,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringToHashBucket")?;

    // Required input arguments
    op.add_input(&string_tensor.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_buckets {
        op.set_attr_int("num_buckets", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StringToHashBucketFast
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringToHashBucketFast {
    pub num_buckets: ::std::option::Option<i64>,
}

impl StringToHashBucketFast {
    /// Creates a new `StringToHashBucketFast`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_to_hash_bucket_fast with default options.
pub fn string_to_hash_bucket_fast<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StringToHashBucketFast::new();
    string_to_hash_bucket_fast_with_args(ctx, input, &__args)
}

/// string_to_hash_bucket_fast with options.
pub fn string_to_hash_bucket_fast_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &StringToHashBucketFast,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringToHashBucketFast")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_buckets {
        op.set_attr_int("num_buckets", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StringToHashBucketStrong
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringToHashBucketStrong {
    pub num_buckets: ::std::option::Option<i64>,
    pub key: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl StringToHashBucketStrong {
    /// Creates a new `StringToHashBucketStrong`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_to_hash_bucket_strong with default options.
pub fn string_to_hash_bucket_strong<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StringToHashBucketStrong::new();
    string_to_hash_bucket_strong_with_args(ctx, input, &__args)
}

/// string_to_hash_bucket_strong with options.
pub fn string_to_hash_bucket_strong_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &StringToHashBucketStrong,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringToHashBucketStrong")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_buckets {
        op.set_attr_int("num_buckets", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.key {
        op.set_attr_int_list("key", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StringToNumber
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringToNumber {
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl StringToNumber {
    /// Creates a new `StringToNumber`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_to_number with default options.
pub fn string_to_number<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    string_tensor: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StringToNumber::new();
    string_to_number_with_args(ctx, string_tensor, &__args)
}

/// string_to_number with options.
pub fn string_to_number_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    string_tensor: T0,
    __args: &StringToNumber,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringToNumber")?;

    // Required input arguments
    op.add_input(&string_tensor.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// StringUpper
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringUpper {
    pub encoding: ::std::option::Option<::std::string::String>,
}

impl StringUpper {
    /// Creates a new `StringUpper`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// string_upper with default options.
pub fn string_upper<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = StringUpper::new();
    string_upper_with_args(ctx, input, &__args)
}

/// string_upper with options.
pub fn string_upper_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &StringUpper,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "StringUpper")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.encoding {
        op.set_attr_string("encoding", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Sub
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sub {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Sub {
    /// Creates a new `Sub`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sub with default options.
pub fn sub<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Sub::new();
    sub_with_args(ctx, x, y, &__args)
}

/// sub with options.
pub fn sub_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Sub,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Sub")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Substr
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Substr {
    pub T: ::std::option::Option<crate::DataType>,
    pub unit: ::std::option::Option<::std::string::String>,
}

impl Substr {
    /// Creates a new `Substr`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// substr with default options.
pub fn substr<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    pos: T1,
    len: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Substr::new();
    substr_with_args(ctx, input, pos, len, &__args)
}

/// substr with options.
pub fn substr_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    pos: T1,
    len: T2,
    __args: &Substr,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Substr")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&pos.to_handle()?)?;
    op.add_input(&len.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.unit {
        op.set_attr_string("unit", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Sum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sum {
    pub keep_dims: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl Sum {
    /// Creates a new `Sum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// sum with default options.
pub fn sum<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Sum::new();
    sum_with_args(ctx, input, reduction_indices, &__args)
}

/// sum with options.
pub fn sum_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    reduction_indices: T1,
    __args: &Sum,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Sum")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&reduction_indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.keep_dims {
        op.set_attr_bool("keep_dims", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// SummaryWriter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SummaryWriter {
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub container: ::std::option::Option<::std::string::String>,
}

impl SummaryWriter {
    /// Creates a new `SummaryWriter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// summary_writer with default options.
pub fn summary_writer(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = SummaryWriter::new();
    summary_writer_with_args(ctx, &__args)
}

/// summary_writer with options.
pub fn summary_writer_with_args(
    ctx: &crate::eager::Context,
    __args: &SummaryWriter,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SummaryWriter")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Svd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Svd {
    pub compute_uv: ::std::option::Option<bool>,
    pub full_matrices: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl Svd {
    /// Creates a new `Svd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// svd with default options.
pub fn svd<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = Svd::new();
    svd_with_args(ctx, input, &__args)
}

/// svd with options.
pub fn svd_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Svd,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Svd")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.compute_uv {
        op.set_attr_bool("compute_uv", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.full_matrices {
        op.set_attr_bool("full_matrices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Switch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Switch {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Switch {
    /// Creates a new `Switch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// switch with default options.
pub fn switch<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    pred: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = Switch::new();
    switch_with_args(ctx, data, pred, &__args)
}

/// switch with options.
pub fn switch_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    data: T0,
    pred: T1,
    __args: &Switch,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Switch")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&pred.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// SymbolicGradient
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SymbolicGradient {
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub f: ::std::option::Option<::std::string::String>,
}

impl SymbolicGradient {
    /// Creates a new `SymbolicGradient`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// symbolic_gradient with default options.
pub fn symbolic_gradient<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = SymbolicGradient::new();
    symbolic_gradient_with_args(ctx, input, &__args)
}

/// symbolic_gradient with options.
pub fn symbolic_gradient_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &SymbolicGradient,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "SymbolicGradient")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TFRecordDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TFRecordDataset {}

impl TFRecordDataset {
    /// Creates a new `TFRecordDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tfrecord_dataset with default options.
pub fn tfrecord_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    compression_type: T1,
    buffer_size: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TFRecordDataset::new();
    tfrecord_dataset_with_args(ctx, filenames, compression_type, buffer_size, &__args)
}

/// tfrecord_dataset with options.
pub fn tfrecord_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    compression_type: T1,
    buffer_size: T2,
    __args: &TFRecordDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TFRecordDataset")?;

    // Required input arguments
    op.add_input(&filenames.to_handle()?)?;
    op.add_input(&compression_type.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TFRecordReader
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TFRecordReader {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub compression_type: ::std::option::Option<::std::string::String>,
}

impl TFRecordReader {
    /// Creates a new `TFRecordReader`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tfrecord_reader with default options.
pub fn tfrecord_reader(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = TFRecordReader::new();
    tfrecord_reader_with_args(ctx, &__args)
}

/// tfrecord_reader with options.
pub fn tfrecord_reader_with_args(
    ctx: &crate::eager::Context,
    __args: &TFRecordReader,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TFRecordReader")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.compression_type {
        op.set_attr_string("compression_type", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TFRecordReaderV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TFRecordReaderV2 {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub compression_type: ::std::option::Option<::std::string::String>,
}

impl TFRecordReaderV2 {
    /// Creates a new `TFRecordReaderV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tfrecord_reader_v2 with default options.
pub fn tfrecord_reader_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = TFRecordReaderV2::new();
    tfrecord_reader_v2_with_args(ctx, &__args)
}

/// tfrecord_reader_v2 with options.
pub fn tfrecord_reader_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &TFRecordReaderV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TFRecordReaderV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.compression_type {
        op.set_attr_string("compression_type", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TPUCompilationResult
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUCompilationResult {}

impl TPUCompilationResult {
    /// Creates a new `TPUCompilationResult`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpucompilation_result with default options.
pub fn tpucompilation_result(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = TPUCompilationResult::new();
    tpucompilation_result_with_args(ctx, &__args)
}

/// tpucompilation_result with options.
pub fn tpucompilation_result_with_args(
    ctx: &crate::eager::Context,
    __args: &TPUCompilationResult,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUCompilationResult")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TPUCompile
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUCompile {
    pub num_computations: ::std::option::Option<i64>,
    pub function: ::std::option::Option<::std::string::String>,
    pub metadata: ::std::option::Option<::std::string::String>,
    pub NumDynamicShapes: ::std::option::Option<i64>,
    pub Tguaranteed_constants: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl TPUCompile {
    /// Creates a new `TPUCompile`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpucompile with default options.
pub fn tpucompile<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    dynamic_shapes: T0,
    guaranteed_constants: T1,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = TPUCompile::new();
    tpucompile_with_args(ctx, dynamic_shapes, guaranteed_constants, &__args)
}

/// tpucompile with options.
pub fn tpucompile_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    dynamic_shapes: T0,
    guaranteed_constants: T1,
    __args: &TPUCompile,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUCompile")?;

    // Required input arguments
    op.add_input(&dynamic_shapes.to_handle()?)?;
    op.add_input(&guaranteed_constants.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_computations {
        op.set_attr_int("num_computations", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.function {
        op.set_attr_string("function", value);
    }
    if let ::std::option::Option::Some(value) = &__args.metadata {
        op.set_attr_string("metadata", value);
    }
    if let ::std::option::Option::Some(value) = &__args.NumDynamicShapes {
        op.set_attr_int("NumDynamicShapes", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tguaranteed_constants {
        op.set_attr_type_list("Tguaranteed_constants", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TPUCompileSucceededAssert
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUCompileSucceededAssert {}

impl TPUCompileSucceededAssert {
    /// Creates a new `TPUCompileSucceededAssert`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpucompile_succeeded_assert with default options.
pub fn tpucompile_succeeded_assert<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    compilation_status: T0,
) -> Result<()> {
    let __args = TPUCompileSucceededAssert::new();
    tpucompile_succeeded_assert_with_args(ctx, compilation_status, &__args)
}

/// tpucompile_succeeded_assert with options.
pub fn tpucompile_succeeded_assert_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    compilation_status: T0,
    __args: &TPUCompileSucceededAssert,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUCompileSucceededAssert")?;

    // Required input arguments
    op.add_input(&compilation_status.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// TPUEmbeddingActivations
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUEmbeddingActivations {
    pub table_id: ::std::option::Option<i64>,
    pub lookup_id: ::std::option::Option<i64>,
}

impl TPUEmbeddingActivations {
    /// Creates a new `TPUEmbeddingActivations`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpuembedding_activations with default options.
pub fn tpuembedding_activations<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    embedding_variable: T0,
    sliced_activations: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TPUEmbeddingActivations::new();
    tpuembedding_activations_with_args(ctx, embedding_variable, sliced_activations, &__args)
}

/// tpuembedding_activations with options.
pub fn tpuembedding_activations_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    embedding_variable: T0,
    sliced_activations: T1,
    __args: &TPUEmbeddingActivations,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUEmbeddingActivations")?;

    // Required input arguments
    op.add_input(&embedding_variable.to_handle()?)?;
    op.add_input(&sliced_activations.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.table_id {
        op.set_attr_int("table_id", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.lookup_id {
        op.set_attr_int("lookup_id", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TPUExecute
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUExecute {
    pub Targs: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tresults: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl TPUExecute {
    /// Creates a new `TPUExecute`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpuexecute with default options.
pub fn tpuexecute<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    args: T0,
    key: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TPUExecute::new();
    tpuexecute_with_args(ctx, args, key, &__args)
}

/// tpuexecute with options.
pub fn tpuexecute_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    args: T0,
    key: T1,
    __args: &TPUExecute,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUExecute")?;

    // Required input arguments
    op.add_input(&args.to_handle()?)?;
    op.add_input(&key.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Targs {
        op.set_attr_type_list("Targs", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tresults {
        op.set_attr_type_list("Tresults", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TPUExecuteAndUpdateVariables
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUExecuteAndUpdateVariables {
    pub Targs: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tresults: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub device_var_reads_indices: ::std::option::Option<::std::vec::Vec<i64>>,
    pub device_var_updates_indices: ::std::option::Option<::std::vec::Vec<i64>>,
}

impl TPUExecuteAndUpdateVariables {
    /// Creates a new `TPUExecuteAndUpdateVariables`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpuexecute_and_update_variables with default options.
pub fn tpuexecute_and_update_variables<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    args: T0,
    key: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TPUExecuteAndUpdateVariables::new();
    tpuexecute_and_update_variables_with_args(ctx, args, key, &__args)
}

/// tpuexecute_and_update_variables with options.
pub fn tpuexecute_and_update_variables_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    args: T0,
    key: T1,
    __args: &TPUExecuteAndUpdateVariables,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUExecuteAndUpdateVariables")?;

    // Required input arguments
    op.add_input(&args.to_handle()?)?;
    op.add_input(&key.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Targs {
        op.set_attr_type_list("Targs", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tresults {
        op.set_attr_type_list("Tresults", value);
    }
    if let ::std::option::Option::Some(value) = &__args.device_var_reads_indices {
        op.set_attr_int_list("device_var_reads_indices", value);
    }
    if let ::std::option::Option::Some(value) = &__args.device_var_updates_indices {
        op.set_attr_int_list("device_var_updates_indices", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TPUOrdinalSelector
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUOrdinalSelector {}

impl TPUOrdinalSelector {
    /// Creates a new `TPUOrdinalSelector`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpuordinal_selector with default options.
pub fn tpuordinal_selector(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = TPUOrdinalSelector::new();
    tpuordinal_selector_with_args(ctx, &__args)
}

/// tpuordinal_selector with options.
pub fn tpuordinal_selector_with_args(
    ctx: &crate::eager::Context,
    __args: &TPUOrdinalSelector,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUOrdinalSelector")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TPUPartitionedCall
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUPartitionedCall {
    pub Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub f: ::std::option::Option<::std::string::String>,
    pub autotuner_thresh: ::std::option::Option<i64>,
}

impl TPUPartitionedCall {
    /// Creates a new `TPUPartitionedCall`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpupartitioned_call with default options.
pub fn tpupartitioned_call<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    args: T0,
    device_ordinal: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TPUPartitionedCall::new();
    tpupartitioned_call_with_args(ctx, args, device_ordinal, &__args)
}

/// tpupartitioned_call with options.
pub fn tpupartitioned_call_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    args: T0,
    device_ordinal: T1,
    __args: &TPUPartitionedCall,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUPartitionedCall")?;

    // Required input arguments
    op.add_input(&args.to_handle()?)?;
    op.add_input(&device_ordinal.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tin {
        op.set_attr_type_list("Tin", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tout {
        op.set_attr_type_list("Tout", value);
    }
    if let ::std::option::Option::Some(value) = &__args.f {
        op.set_attr_string("f", value);
    }
    if let ::std::option::Option::Some(value) = &__args.autotuner_thresh {
        op.set_attr_int("autotuner_thresh", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TPUPartitionedInput
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUPartitionedInput {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub partition_dim: ::std::option::Option<i64>,
}

impl TPUPartitionedInput {
    /// Creates a new `TPUPartitionedInput`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpupartitioned_input with default options.
pub fn tpupartitioned_input<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TPUPartitionedInput::new();
    tpupartitioned_input_with_args(ctx, inputs, &__args)
}

/// tpupartitioned_input with options.
pub fn tpupartitioned_input_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &TPUPartitionedInput,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUPartitionedInput")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.partition_dim {
        op.set_attr_int("partition_dim", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TPUPartitionedOutput
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUPartitionedOutput {
    pub T: ::std::option::Option<crate::DataType>,
    pub num_splits: ::std::option::Option<i64>,
    pub partition_dim: ::std::option::Option<i64>,
}

impl TPUPartitionedOutput {
    /// Creates a new `TPUPartitionedOutput`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpupartitioned_output with default options.
pub fn tpupartitioned_output<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TPUPartitionedOutput::new();
    tpupartitioned_output_with_args(ctx, inputs, &__args)
}

/// tpupartitioned_output with options.
pub fn tpupartitioned_output_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &TPUPartitionedOutput,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUPartitionedOutput")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_splits {
        op.set_attr_int("num_splits", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.partition_dim {
        op.set_attr_int("partition_dim", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TPUReplicateMetadata
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUReplicateMetadata {
    pub num_replicas: ::std::option::Option<i64>,
    pub num_cores_per_replica: ::std::option::Option<i64>,
    pub topology: ::std::option::Option<::std::string::String>,
    pub use_tpu: ::std::option::Option<bool>,
    pub device_assignment: ::std::option::Option<::std::vec::Vec<i64>>,
    pub computation_shape: ::std::option::Option<::std::vec::Vec<i64>>,
    pub host_compute_core: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub padding_map: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub step_marker_location: ::std::option::Option<::std::string::String>,
    pub allow_soft_placement: ::std::option::Option<bool>,
    pub use_spmd_for_xla_partitioning: ::std::option::Option<bool>,
}

impl TPUReplicateMetadata {
    /// Creates a new `TPUReplicateMetadata`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpureplicate_metadata with default options.
pub fn tpureplicate_metadata(ctx: &crate::eager::Context) -> Result<()> {
    let __args = TPUReplicateMetadata::new();
    tpureplicate_metadata_with_args(ctx, &__args)
}

/// tpureplicate_metadata with options.
pub fn tpureplicate_metadata_with_args(
    ctx: &crate::eager::Context,
    __args: &TPUReplicateMetadata,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUReplicateMetadata")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_replicas {
        op.set_attr_int("num_replicas", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_cores_per_replica {
        op.set_attr_int("num_cores_per_replica", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.topology {
        op.set_attr_string("topology", value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_tpu {
        op.set_attr_bool("use_tpu", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.device_assignment {
        op.set_attr_int_list("device_assignment", value);
    }
    if let ::std::option::Option::Some(value) = &__args.computation_shape {
        op.set_attr_int_list("computation_shape", value);
    }
    if let ::std::option::Option::Some(value) = &__args.host_compute_core {
        op.set_attr_string_list("host_compute_core", value);
    }
    if let ::std::option::Option::Some(value) = &__args.padding_map {
        op.set_attr_string_list("padding_map", value);
    }
    if let ::std::option::Option::Some(value) = &__args.step_marker_location {
        op.set_attr_string("step_marker_location", value);
    }
    if let ::std::option::Option::Some(value) = &__args.allow_soft_placement {
        op.set_attr_bool("allow_soft_placement", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.use_spmd_for_xla_partitioning {
        op.set_attr_bool("use_spmd_for_xla_partitioning", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// TPUReplicatedInput
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUReplicatedInput {
    pub N: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub is_mirrored_variable: ::std::option::Option<bool>,
    pub index: ::std::option::Option<i64>,
    pub is_packed: ::std::option::Option<bool>,
}

impl TPUReplicatedInput {
    /// Creates a new `TPUReplicatedInput`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpureplicated_input with default options.
pub fn tpureplicated_input<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TPUReplicatedInput::new();
    tpureplicated_input_with_args(ctx, inputs, &__args)
}

/// tpureplicated_input with options.
pub fn tpureplicated_input_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &TPUReplicatedInput,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUReplicatedInput")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_mirrored_variable {
        op.set_attr_bool("is_mirrored_variable", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.index {
        op.set_attr_int("index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.is_packed {
        op.set_attr_bool("is_packed", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TPUReplicatedOutput
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUReplicatedOutput {
    pub num_replicas: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl TPUReplicatedOutput {
    /// Creates a new `TPUReplicatedOutput`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpureplicated_output with default options.
pub fn tpureplicated_output<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TPUReplicatedOutput::new();
    tpureplicated_output_with_args(ctx, input, &__args)
}

/// tpureplicated_output with options.
pub fn tpureplicated_output_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &TPUReplicatedOutput,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUReplicatedOutput")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_replicas {
        op.set_attr_int("num_replicas", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TPUReshardVariables
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUReshardVariables {
    pub N: ::std::option::Option<i64>,
}

impl TPUReshardVariables {
    /// Creates a new `TPUReshardVariables`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tpureshard_variables with default options.
pub fn tpureshard_variables<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    vars: T0,
    new_format_key: T1,
    format_state_var: T2,
) -> Result<()> {
    let __args = TPUReshardVariables::new();
    tpureshard_variables_with_args(ctx, vars, new_format_key, format_state_var, &__args)
}

/// tpureshard_variables with options.
pub fn tpureshard_variables_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    vars: T0,
    new_format_key: T1,
    format_state_var: T2,
    __args: &TPUReshardVariables,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TPUReshardVariables")?;

    // Required input arguments
    op.add_input(&vars.to_handle()?)?;
    op.add_input(&new_format_key.to_handle()?)?;
    op.add_input(&format_state_var.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// TakeDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TakeDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl TakeDataset {
    /// Creates a new `TakeDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// take_dataset with default options.
pub fn take_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    count: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TakeDataset::new();
    take_dataset_with_args(ctx, input_dataset, count, &__args)
}

/// take_dataset with options.
pub fn take_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    count: T1,
    __args: &TakeDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TakeDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&count.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TakeManySparseFromTensorsMap
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TakeManySparseFromTensorsMap {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl TakeManySparseFromTensorsMap {
    /// Creates a new `TakeManySparseFromTensorsMap`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// take_many_sparse_from_tensors_map with default options.
pub fn take_many_sparse_from_tensors_map<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sparse_handles: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = TakeManySparseFromTensorsMap::new();
    take_many_sparse_from_tensors_map_with_args(ctx, sparse_handles, &__args)
}

/// take_many_sparse_from_tensors_map with options.
pub fn take_many_sparse_from_tensors_map_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sparse_handles: T0,
    __args: &TakeManySparseFromTensorsMap,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TakeManySparseFromTensorsMap")?;

    // Required input arguments
    op.add_input(&sparse_handles.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TakeWhileDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TakeWhileDataset {
    pub predicate: ::std::option::Option<::std::string::String>,
    pub Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl TakeWhileDataset {
    /// Creates a new `TakeWhileDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// take_while_dataset with default options.
pub fn take_while_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TakeWhileDataset::new();
    take_while_dataset_with_args(ctx, input_dataset, other_arguments, &__args)
}

/// take_while_dataset with options.
pub fn take_while_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    other_arguments: T1,
    __args: &TakeWhileDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TakeWhileDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&other_arguments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.predicate {
        op.set_attr_string("predicate", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Targuments {
        op.set_attr_type_list("Targuments", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Tan
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Tan {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Tan {
    /// Creates a new `Tan`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tan with default options.
pub fn tan<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Tan::new();
    tan_with_args(ctx, x, &__args)
}

/// tan with options.
pub fn tan_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Tan,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Tan")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Tanh
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Tanh {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Tanh {
    /// Creates a new `Tanh`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tanh with default options.
pub fn tanh<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Tanh::new();
    tanh_with_args(ctx, x, &__args)
}

/// tanh with options.
pub fn tanh_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Tanh,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Tanh")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TanhGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TanhGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TanhGrad {
    /// Creates a new `TanhGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tanh_grad with default options.
pub fn tanh_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    dy: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TanhGrad::new();
    tanh_grad_with_args(ctx, y, dy, &__args)
}

/// tanh_grad with options.
pub fn tanh_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    y: T0,
    dy: T1,
    __args: &TanhGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TanhGrad")?;

    // Required input arguments
    op.add_input(&y.to_handle()?)?;
    op.add_input(&dy.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TemporaryVariable
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TemporaryVariable {
    pub shape: ::std::option::Option<crate::Shape>,
    pub dtype: ::std::option::Option<crate::DataType>,
    pub var_name: ::std::option::Option<::std::string::String>,
}

impl TemporaryVariable {
    /// Creates a new `TemporaryVariable`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// temporary_variable with default options.
pub fn temporary_variable(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = TemporaryVariable::new();
    temporary_variable_with_args(ctx, &__args)
}

/// temporary_variable with options.
pub fn temporary_variable_with_args(
    ctx: &crate::eager::Context,
    __args: &TemporaryVariable,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TemporaryVariable")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.var_name {
        op.set_attr_string("var_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArray
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArray {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub dynamic_size: ::std::option::Option<bool>,
    pub clear_after_read: ::std::option::Option<bool>,
    pub tensor_array_name: ::std::option::Option<::std::string::String>,
    pub element_shape: ::std::option::Option<crate::Shape>,
}

impl TensorArray {
    /// Creates a new `TensorArray`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array with default options.
pub fn tensor_array<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    size: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArray::new();
    tensor_array_with_args(ctx, size, &__args)
}

/// tensor_array with options.
pub fn tensor_array_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    size: T0,
    __args: &TensorArray,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArray")?;

    // Required input arguments
    op.add_input(&size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dynamic_size {
        op.set_attr_bool("dynamic_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.clear_after_read {
        op.set_attr_bool("clear_after_read", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_array_name {
        op.set_attr_string("tensor_array_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.element_shape {
        op.set_attr_shape("element_shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayClose
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayClose {}

impl TensorArrayClose {
    /// Creates a new `TensorArrayClose`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_close with default options.
pub fn tensor_array_close<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<()> {
    let __args = TensorArrayClose::new();
    tensor_array_close_with_args(ctx, handle, &__args)
}

/// tensor_array_close with options.
pub fn tensor_array_close_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &TensorArrayClose,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayClose")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// TensorArrayCloseV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayCloseV2 {}

impl TensorArrayCloseV2 {
    /// Creates a new `TensorArrayCloseV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_close_v2 with default options.
pub fn tensor_array_close_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<()> {
    let __args = TensorArrayCloseV2::new();
    tensor_array_close_v2_with_args(ctx, handle, &__args)
}

/// tensor_array_close_v2 with options.
pub fn tensor_array_close_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &TensorArrayCloseV2,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayCloseV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// TensorArrayCloseV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayCloseV3 {}

impl TensorArrayCloseV3 {
    /// Creates a new `TensorArrayCloseV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_close_v3 with default options.
pub fn tensor_array_close_v3<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
) -> Result<()> {
    let __args = TensorArrayCloseV3::new();
    tensor_array_close_v3_with_args(ctx, handle, &__args)
}

/// tensor_array_close_v3 with options.
pub fn tensor_array_close_v3_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    __args: &TensorArrayCloseV3,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayCloseV3")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// TensorArrayConcat
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayConcat {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub element_shape_except0: ::std::option::Option<crate::Shape>,
}

impl TensorArrayConcat {
    /// Creates a new `TensorArrayConcat`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_concat with default options.
pub fn tensor_array_concat<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TensorArrayConcat::new();
    tensor_array_concat_with_args(ctx, handle, flow_in, &__args)
}

/// tensor_array_concat with options.
pub fn tensor_array_concat_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
    __args: &TensorArrayConcat,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayConcat")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.element_shape_except0 {
        op.set_attr_shape("element_shape_except0", value)?;
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayConcatV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayConcatV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub element_shape_except0: ::std::option::Option<crate::Shape>,
}

impl TensorArrayConcatV2 {
    /// Creates a new `TensorArrayConcatV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_concat_v2 with default options.
pub fn tensor_array_concat_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TensorArrayConcatV2::new();
    tensor_array_concat_v2_with_args(ctx, handle, flow_in, &__args)
}

/// tensor_array_concat_v2 with options.
pub fn tensor_array_concat_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
    __args: &TensorArrayConcatV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayConcatV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.element_shape_except0 {
        op.set_attr_shape("element_shape_except0", value)?;
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayConcatV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayConcatV3 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub element_shape_except0: ::std::option::Option<crate::Shape>,
}

impl TensorArrayConcatV3 {
    /// Creates a new `TensorArrayConcatV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_concat_v3 with default options.
pub fn tensor_array_concat_v3<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TensorArrayConcatV3::new();
    tensor_array_concat_v3_with_args(ctx, handle, flow_in, &__args)
}

/// tensor_array_concat_v3 with options.
pub fn tensor_array_concat_v3_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
    __args: &TensorArrayConcatV3,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayConcatV3")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.element_shape_except0 {
        op.set_attr_shape("element_shape_except0", value)?;
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayGather
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGather {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub element_shape: ::std::option::Option<crate::Shape>,
}

impl TensorArrayGather {
    /// Creates a new `TensorArrayGather`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_gather with default options.
pub fn tensor_array_gather<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    indices: T1,
    flow_in: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayGather::new();
    tensor_array_gather_with_args(ctx, handle, indices, flow_in, &__args)
}

/// tensor_array_gather with options.
pub fn tensor_array_gather_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    indices: T1,
    flow_in: T2,
    __args: &TensorArrayGather,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayGather")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.element_shape {
        op.set_attr_shape("element_shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayGatherV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGatherV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub element_shape: ::std::option::Option<crate::Shape>,
}

impl TensorArrayGatherV2 {
    /// Creates a new `TensorArrayGatherV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_gather_v2 with default options.
pub fn tensor_array_gather_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    indices: T1,
    flow_in: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayGatherV2::new();
    tensor_array_gather_v2_with_args(ctx, handle, indices, flow_in, &__args)
}

/// tensor_array_gather_v2 with options.
pub fn tensor_array_gather_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    indices: T1,
    flow_in: T2,
    __args: &TensorArrayGatherV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayGatherV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.element_shape {
        op.set_attr_shape("element_shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayGatherV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGatherV3 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub element_shape: ::std::option::Option<crate::Shape>,
}

impl TensorArrayGatherV3 {
    /// Creates a new `TensorArrayGatherV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_gather_v3 with default options.
pub fn tensor_array_gather_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    indices: T1,
    flow_in: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayGatherV3::new();
    tensor_array_gather_v3_with_args(ctx, handle, indices, flow_in, &__args)
}

/// tensor_array_gather_v3 with options.
pub fn tensor_array_gather_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    indices: T1,
    flow_in: T2,
    __args: &TensorArrayGatherV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayGatherV3")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.element_shape {
        op.set_attr_shape("element_shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGrad {
    pub source: ::std::option::Option<::std::string::String>,
}

impl TensorArrayGrad {
    /// Creates a new `TensorArrayGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_grad with default options.
pub fn tensor_array_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayGrad::new();
    tensor_array_grad_with_args(ctx, handle, flow_in, &__args)
}

/// tensor_array_grad with options.
pub fn tensor_array_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
    __args: &TensorArrayGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayGrad")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.source {
        op.set_attr_string("source", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayGradV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGradV2 {
    pub source: ::std::option::Option<::std::string::String>,
}

impl TensorArrayGradV2 {
    /// Creates a new `TensorArrayGradV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_grad_v2 with default options.
pub fn tensor_array_grad_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayGradV2::new();
    tensor_array_grad_v2_with_args(ctx, handle, flow_in, &__args)
}

/// tensor_array_grad_v2 with options.
pub fn tensor_array_grad_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
    __args: &TensorArrayGradV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayGradV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.source {
        op.set_attr_string("source", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayGradV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGradV3 {
    pub source: ::std::option::Option<::std::string::String>,
}

impl TensorArrayGradV3 {
    /// Creates a new `TensorArrayGradV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_grad_v3 with default options.
pub fn tensor_array_grad_v3<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TensorArrayGradV3::new();
    tensor_array_grad_v3_with_args(ctx, handle, flow_in, &__args)
}

/// tensor_array_grad_v3 with options.
pub fn tensor_array_grad_v3_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
    __args: &TensorArrayGradV3,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayGradV3")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.source {
        op.set_attr_string("source", value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayGradWithShape
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGradWithShape {
    pub source: ::std::option::Option<::std::string::String>,
}

impl TensorArrayGradWithShape {
    /// Creates a new `TensorArrayGradWithShape`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_grad_with_shape with default options.
pub fn tensor_array_grad_with_shape<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
    shape_to_prepend: T2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TensorArrayGradWithShape::new();
    tensor_array_grad_with_shape_with_args(ctx, handle, flow_in, shape_to_prepend, &__args)
}

/// tensor_array_grad_with_shape with options.
pub fn tensor_array_grad_with_shape_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
    shape_to_prepend: T2,
    __args: &TensorArrayGradWithShape,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayGradWithShape")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;
    op.add_input(&shape_to_prepend.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.source {
        op.set_attr_string("source", value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayPack
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayPack {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub element_shape: ::std::option::Option<crate::Shape>,
}

impl TensorArrayPack {
    /// Creates a new `TensorArrayPack`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_pack with default options.
pub fn tensor_array_pack<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayPack::new();
    tensor_array_pack_with_args(ctx, handle, flow_in, &__args)
}

/// tensor_array_pack with options.
pub fn tensor_array_pack_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
    __args: &TensorArrayPack,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayPack")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.element_shape {
        op.set_attr_shape("element_shape", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayRead
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayRead {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl TensorArrayRead {
    /// Creates a new `TensorArrayRead`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_read with default options.
pub fn tensor_array_read<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    index: T1,
    flow_in: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayRead::new();
    tensor_array_read_with_args(ctx, handle, index, flow_in, &__args)
}

/// tensor_array_read with options.
pub fn tensor_array_read_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    index: T1,
    flow_in: T2,
    __args: &TensorArrayRead,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayRead")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&index.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayReadV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayReadV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl TensorArrayReadV2 {
    /// Creates a new `TensorArrayReadV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_read_v2 with default options.
pub fn tensor_array_read_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    index: T1,
    flow_in: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayReadV2::new();
    tensor_array_read_v2_with_args(ctx, handle, index, flow_in, &__args)
}

/// tensor_array_read_v2 with options.
pub fn tensor_array_read_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    index: T1,
    flow_in: T2,
    __args: &TensorArrayReadV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayReadV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&index.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayReadV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayReadV3 {
    pub dtype: ::std::option::Option<crate::DataType>,
}

impl TensorArrayReadV3 {
    /// Creates a new `TensorArrayReadV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_read_v3 with default options.
pub fn tensor_array_read_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    index: T1,
    flow_in: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayReadV3::new();
    tensor_array_read_v3_with_args(ctx, handle, index, flow_in, &__args)
}

/// tensor_array_read_v3 with options.
pub fn tensor_array_read_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    index: T1,
    flow_in: T2,
    __args: &TensorArrayReadV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayReadV3")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&index.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayScatter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayScatter {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TensorArrayScatter {
    /// Creates a new `TensorArrayScatter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_scatter with default options.
pub fn tensor_array_scatter<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    indices: T1,
    value: T2,
    flow_in: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayScatter::new();
    tensor_array_scatter_with_args(ctx, handle, indices, value, flow_in, &__args)
}

/// tensor_array_scatter with options.
pub fn tensor_array_scatter_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    indices: T1,
    value: T2,
    flow_in: T3,
    __args: &TensorArrayScatter,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayScatter")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayScatterV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayScatterV2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TensorArrayScatterV2 {
    /// Creates a new `TensorArrayScatterV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_scatter_v2 with default options.
pub fn tensor_array_scatter_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    indices: T1,
    value: T2,
    flow_in: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayScatterV2::new();
    tensor_array_scatter_v2_with_args(ctx, handle, indices, value, flow_in, &__args)
}

/// tensor_array_scatter_v2 with options.
pub fn tensor_array_scatter_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    indices: T1,
    value: T2,
    flow_in: T3,
    __args: &TensorArrayScatterV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayScatterV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayScatterV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayScatterV3 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TensorArrayScatterV3 {
    /// Creates a new `TensorArrayScatterV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_scatter_v3 with default options.
pub fn tensor_array_scatter_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    indices: T1,
    value: T2,
    flow_in: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayScatterV3::new();
    tensor_array_scatter_v3_with_args(ctx, handle, indices, value, flow_in, &__args)
}

/// tensor_array_scatter_v3 with options.
pub fn tensor_array_scatter_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    indices: T1,
    value: T2,
    flow_in: T3,
    __args: &TensorArrayScatterV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayScatterV3")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArraySize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArraySize {}

impl TensorArraySize {
    /// Creates a new `TensorArraySize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_size with default options.
pub fn tensor_array_size<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArraySize::new();
    tensor_array_size_with_args(ctx, handle, flow_in, &__args)
}

/// tensor_array_size with options.
pub fn tensor_array_size_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
    __args: &TensorArraySize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArraySize")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArraySizeV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArraySizeV2 {}

impl TensorArraySizeV2 {
    /// Creates a new `TensorArraySizeV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_size_v2 with default options.
pub fn tensor_array_size_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArraySizeV2::new();
    tensor_array_size_v2_with_args(ctx, handle, flow_in, &__args)
}

/// tensor_array_size_v2 with options.
pub fn tensor_array_size_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
    __args: &TensorArraySizeV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArraySizeV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArraySizeV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArraySizeV3 {}

impl TensorArraySizeV3 {
    /// Creates a new `TensorArraySizeV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_size_v3 with default options.
pub fn tensor_array_size_v3<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArraySizeV3::new();
    tensor_array_size_v3_with_args(ctx, handle, flow_in, &__args)
}

/// tensor_array_size_v3 with options.
pub fn tensor_array_size_v3_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    handle: T0,
    flow_in: T1,
    __args: &TensorArraySizeV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArraySizeV3")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArraySplit
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArraySplit {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TensorArraySplit {
    /// Creates a new `TensorArraySplit`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_split with default options.
pub fn tensor_array_split<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    value: T1,
    lengths: T2,
    flow_in: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArraySplit::new();
    tensor_array_split_with_args(ctx, handle, value, lengths, flow_in, &__args)
}

/// tensor_array_split with options.
pub fn tensor_array_split_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    value: T1,
    lengths: T2,
    flow_in: T3,
    __args: &TensorArraySplit,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArraySplit")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;
    op.add_input(&lengths.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArraySplitV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArraySplitV2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TensorArraySplitV2 {
    /// Creates a new `TensorArraySplitV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_split_v2 with default options.
pub fn tensor_array_split_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    value: T1,
    lengths: T2,
    flow_in: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArraySplitV2::new();
    tensor_array_split_v2_with_args(ctx, handle, value, lengths, flow_in, &__args)
}

/// tensor_array_split_v2 with options.
pub fn tensor_array_split_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    value: T1,
    lengths: T2,
    flow_in: T3,
    __args: &TensorArraySplitV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArraySplitV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;
    op.add_input(&lengths.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArraySplitV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArraySplitV3 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TensorArraySplitV3 {
    /// Creates a new `TensorArraySplitV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_split_v3 with default options.
pub fn tensor_array_split_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    value: T1,
    lengths: T2,
    flow_in: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArraySplitV3::new();
    tensor_array_split_v3_with_args(ctx, handle, value, lengths, flow_in, &__args)
}

/// tensor_array_split_v3 with options.
pub fn tensor_array_split_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    value: T1,
    lengths: T2,
    flow_in: T3,
    __args: &TensorArraySplitV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArraySplitV3")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;
    op.add_input(&lengths.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayUnpack
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayUnpack {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TensorArrayUnpack {
    /// Creates a new `TensorArrayUnpack`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_unpack with default options.
pub fn tensor_array_unpack<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    value: T1,
    flow_in: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayUnpack::new();
    tensor_array_unpack_with_args(ctx, handle, value, flow_in, &__args)
}

/// tensor_array_unpack with options.
pub fn tensor_array_unpack_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    value: T1,
    flow_in: T2,
    __args: &TensorArrayUnpack,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayUnpack")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayV2 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub element_shape: ::std::option::Option<crate::Shape>,
    pub dynamic_size: ::std::option::Option<bool>,
    pub clear_after_read: ::std::option::Option<bool>,
    pub tensor_array_name: ::std::option::Option<::std::string::String>,
}

impl TensorArrayV2 {
    /// Creates a new `TensorArrayV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_v2 with default options.
pub fn tensor_array_v2<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    size: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayV2::new();
    tensor_array_v2_with_args(ctx, size, &__args)
}

/// tensor_array_v2 with options.
pub fn tensor_array_v2_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    size: T0,
    __args: &TensorArrayV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayV2")?;

    // Required input arguments
    op.add_input(&size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.element_shape {
        op.set_attr_shape("element_shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.dynamic_size {
        op.set_attr_bool("dynamic_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.clear_after_read {
        op.set_attr_bool("clear_after_read", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_array_name {
        op.set_attr_string("tensor_array_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayV3 {
    pub dtype: ::std::option::Option<crate::DataType>,
    pub element_shape: ::std::option::Option<crate::Shape>,
    pub dynamic_size: ::std::option::Option<bool>,
    pub clear_after_read: ::std::option::Option<bool>,
    pub identical_element_shapes: ::std::option::Option<bool>,
    pub tensor_array_name: ::std::option::Option<::std::string::String>,
}

impl TensorArrayV3 {
    /// Creates a new `TensorArrayV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_v3 with default options.
pub fn tensor_array_v3<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    size: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TensorArrayV3::new();
    tensor_array_v3_with_args(ctx, size, &__args)
}

/// tensor_array_v3 with options.
pub fn tensor_array_v3_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    size: T0,
    __args: &TensorArrayV3,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayV3")?;

    // Required input arguments
    op.add_input(&size.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.element_shape {
        op.set_attr_shape("element_shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.dynamic_size {
        op.set_attr_bool("dynamic_size", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.clear_after_read {
        op.set_attr_bool("clear_after_read", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.identical_element_shapes {
        op.set_attr_bool("identical_element_shapes", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tensor_array_name {
        op.set_attr_string("tensor_array_name", value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayWrite
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayWrite {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TensorArrayWrite {
    /// Creates a new `TensorArrayWrite`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_write with default options.
pub fn tensor_array_write<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    index: T1,
    value: T2,
    flow_in: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayWrite::new();
    tensor_array_write_with_args(ctx, handle, index, value, flow_in, &__args)
}

/// tensor_array_write with options.
pub fn tensor_array_write_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    index: T1,
    value: T2,
    flow_in: T3,
    __args: &TensorArrayWrite,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayWrite")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&index.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayWriteV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayWriteV2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TensorArrayWriteV2 {
    /// Creates a new `TensorArrayWriteV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_write_v2 with default options.
pub fn tensor_array_write_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    index: T1,
    value: T2,
    flow_in: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayWriteV2::new();
    tensor_array_write_v2_with_args(ctx, handle, index, value, flow_in, &__args)
}

/// tensor_array_write_v2 with options.
pub fn tensor_array_write_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    index: T1,
    value: T2,
    flow_in: T3,
    __args: &TensorArrayWriteV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayWriteV2")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&index.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorArrayWriteV3
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayWriteV3 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TensorArrayWriteV3 {
    /// Creates a new `TensorArrayWriteV3`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_array_write_v3 with default options.
pub fn tensor_array_write_v3<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    index: T1,
    value: T2,
    flow_in: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorArrayWriteV3::new();
    tensor_array_write_v3_with_args(ctx, handle, index, value, flow_in, &__args)
}

/// tensor_array_write_v3 with options.
pub fn tensor_array_write_v3_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    handle: T0,
    index: T1,
    value: T2,
    flow_in: T3,
    __args: &TensorArrayWriteV3,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorArrayWriteV3")?;

    // Required input arguments
    op.add_input(&handle.to_handle()?)?;
    op.add_input(&index.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;
    op.add_input(&flow_in.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorDataset {
    pub Toutput_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl TensorDataset {
    /// Creates a new `TensorDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_dataset with default options.
pub fn tensor_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    components: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorDataset::new();
    tensor_dataset_with_args(ctx, components, &__args)
}

/// tensor_dataset with options.
pub fn tensor_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    components: T0,
    __args: &TensorDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorDataset")?;

    // Required input arguments
    op.add_input(&components.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Toutput_types {
        op.set_attr_type_list("Toutput_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListConcat
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListConcat {
    pub element_dtype: ::std::option::Option<crate::DataType>,
    pub element_shape: ::std::option::Option<crate::Shape>,
}

impl TensorListConcat {
    /// Creates a new `TensorListConcat`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_concat with default options.
pub fn tensor_list_concat<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TensorListConcat::new();
    tensor_list_concat_with_args(ctx, input_handle, &__args)
}

/// tensor_list_concat with options.
pub fn tensor_list_concat_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    __args: &TensorListConcat,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListConcat")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.element_shape {
        op.set_attr_shape("element_shape", value)?;
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListConcatLists
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListConcatLists {
    pub element_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorListConcatLists {
    /// Creates a new `TensorListConcatLists`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_concat_lists with default options.
pub fn tensor_list_concat_lists<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_a: T0,
    input_b: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListConcatLists::new();
    tensor_list_concat_lists_with_args(ctx, input_a, input_b, &__args)
}

/// tensor_list_concat_lists with options.
pub fn tensor_list_concat_lists_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_a: T0,
    input_b: T1,
    __args: &TensorListConcatLists,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListConcatLists")?;

    // Required input arguments
    op.add_input(&input_a.to_handle()?)?;
    op.add_input(&input_b.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListConcatV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListConcatV2 {
    pub element_dtype: ::std::option::Option<crate::DataType>,
    pub shape_type: ::std::option::Option<crate::DataType>,
}

impl TensorListConcatV2 {
    /// Creates a new `TensorListConcatV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_concat_v2 with default options.
pub fn tensor_list_concat_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    element_shape: T1,
    leading_dims: T2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TensorListConcatV2::new();
    tensor_list_concat_v2_with_args(ctx, input_handle, element_shape, leading_dims, &__args)
}

/// tensor_list_concat_v2 with options.
pub fn tensor_list_concat_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    element_shape: T1,
    leading_dims: T2,
    __args: &TensorListConcatV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListConcatV2")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&element_shape.to_handle()?)?;
    op.add_input(&leading_dims.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_type {
        op.set_attr_type("shape_type", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListElementShape
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListElementShape {
    pub shape_type: ::std::option::Option<crate::DataType>,
}

impl TensorListElementShape {
    /// Creates a new `TensorListElementShape`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_element_shape with default options.
pub fn tensor_list_element_shape<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListElementShape::new();
    tensor_list_element_shape_with_args(ctx, input_handle, &__args)
}

/// tensor_list_element_shape with options.
pub fn tensor_list_element_shape_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    __args: &TensorListElementShape,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListElementShape")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.shape_type {
        op.set_attr_type("shape_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListFromTensor
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListFromTensor {
    pub element_dtype: ::std::option::Option<crate::DataType>,
    pub shape_type: ::std::option::Option<crate::DataType>,
}

impl TensorListFromTensor {
    /// Creates a new `TensorListFromTensor`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_from_tensor with default options.
pub fn tensor_list_from_tensor<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    element_shape: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListFromTensor::new();
    tensor_list_from_tensor_with_args(ctx, tensor, element_shape, &__args)
}

/// tensor_list_from_tensor with options.
pub fn tensor_list_from_tensor_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    element_shape: T1,
    __args: &TensorListFromTensor,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListFromTensor")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&element_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_type {
        op.set_attr_type("shape_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListGather
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListGather {
    pub element_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorListGather {
    /// Creates a new `TensorListGather`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_gather with default options.
pub fn tensor_list_gather<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    indices: T1,
    element_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListGather::new();
    tensor_list_gather_with_args(ctx, input_handle, indices, element_shape, &__args)
}

/// tensor_list_gather with options.
pub fn tensor_list_gather_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    indices: T1,
    element_shape: T2,
    __args: &TensorListGather,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListGather")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&element_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListGetItem
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListGetItem {
    pub element_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorListGetItem {
    /// Creates a new `TensorListGetItem`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_get_item with default options.
pub fn tensor_list_get_item<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    index: T1,
    element_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListGetItem::new();
    tensor_list_get_item_with_args(ctx, input_handle, index, element_shape, &__args)
}

/// tensor_list_get_item with options.
pub fn tensor_list_get_item_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    index: T1,
    element_shape: T2,
    __args: &TensorListGetItem,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListGetItem")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&index.to_handle()?)?;
    op.add_input(&element_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListLength
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListLength {}

impl TensorListLength {
    /// Creates a new `TensorListLength`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_length with default options.
pub fn tensor_list_length<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListLength::new();
    tensor_list_length_with_args(ctx, input_handle, &__args)
}

/// tensor_list_length with options.
pub fn tensor_list_length_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    __args: &TensorListLength,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListLength")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListPopBack
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListPopBack {
    pub element_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorListPopBack {
    /// Creates a new `TensorListPopBack`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_pop_back with default options.
pub fn tensor_list_pop_back<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    element_shape: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TensorListPopBack::new();
    tensor_list_pop_back_with_args(ctx, input_handle, element_shape, &__args)
}

/// tensor_list_pop_back with options.
pub fn tensor_list_pop_back_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    element_shape: T1,
    __args: &TensorListPopBack,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListPopBack")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&element_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListPushBack
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListPushBack {
    pub element_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorListPushBack {
    /// Creates a new `TensorListPushBack`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_push_back with default options.
pub fn tensor_list_push_back<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    tensor: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListPushBack::new();
    tensor_list_push_back_with_args(ctx, input_handle, tensor, &__args)
}

/// tensor_list_push_back with options.
pub fn tensor_list_push_back_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    tensor: T1,
    __args: &TensorListPushBack,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListPushBack")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&tensor.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListPushBackBatch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListPushBackBatch {
    pub element_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorListPushBackBatch {
    /// Creates a new `TensorListPushBackBatch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_push_back_batch with default options.
pub fn tensor_list_push_back_batch<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handles: T0,
    tensor: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListPushBackBatch::new();
    tensor_list_push_back_batch_with_args(ctx, input_handles, tensor, &__args)
}

/// tensor_list_push_back_batch with options.
pub fn tensor_list_push_back_batch_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handles: T0,
    tensor: T1,
    __args: &TensorListPushBackBatch,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListPushBackBatch")?;

    // Required input arguments
    op.add_input(&input_handles.to_handle()?)?;
    op.add_input(&tensor.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListReserve
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListReserve {
    pub element_dtype: ::std::option::Option<crate::DataType>,
    pub shape_type: ::std::option::Option<crate::DataType>,
}

impl TensorListReserve {
    /// Creates a new `TensorListReserve`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_reserve with default options.
pub fn tensor_list_reserve<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    element_shape: T0,
    num_elements: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListReserve::new();
    tensor_list_reserve_with_args(ctx, element_shape, num_elements, &__args)
}

/// tensor_list_reserve with options.
pub fn tensor_list_reserve_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    element_shape: T0,
    num_elements: T1,
    __args: &TensorListReserve,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListReserve")?;

    // Required input arguments
    op.add_input(&element_shape.to_handle()?)?;
    op.add_input(&num_elements.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_type {
        op.set_attr_type("shape_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListResize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListResize {}

impl TensorListResize {
    /// Creates a new `TensorListResize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_resize with default options.
pub fn tensor_list_resize<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    size: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListResize::new();
    tensor_list_resize_with_args(ctx, input_handle, size, &__args)
}

/// tensor_list_resize with options.
pub fn tensor_list_resize_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    size: T1,
    __args: &TensorListResize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListResize")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListScatter
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListScatter {
    pub element_dtype: ::std::option::Option<crate::DataType>,
    pub shape_type: ::std::option::Option<crate::DataType>,
}

impl TensorListScatter {
    /// Creates a new `TensorListScatter`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_scatter with default options.
pub fn tensor_list_scatter<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    element_shape: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListScatter::new();
    tensor_list_scatter_with_args(ctx, tensor, indices, element_shape, &__args)
}

/// tensor_list_scatter with options.
pub fn tensor_list_scatter_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    element_shape: T2,
    __args: &TensorListScatter,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListScatter")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&element_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_type {
        op.set_attr_type("shape_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListScatterIntoExistingList
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListScatterIntoExistingList {
    pub element_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorListScatterIntoExistingList {
    /// Creates a new `TensorListScatterIntoExistingList`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_scatter_into_existing_list with default options.
pub fn tensor_list_scatter_into_existing_list<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    tensor: T1,
    indices: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListScatterIntoExistingList::new();
    tensor_list_scatter_into_existing_list_with_args(ctx, input_handle, tensor, indices, &__args)
}

/// tensor_list_scatter_into_existing_list with options.
pub fn tensor_list_scatter_into_existing_list_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    tensor: T1,
    indices: T2,
    __args: &TensorListScatterIntoExistingList,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListScatterIntoExistingList")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListScatterV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListScatterV2 {
    pub element_dtype: ::std::option::Option<crate::DataType>,
    pub shape_type: ::std::option::Option<crate::DataType>,
}

impl TensorListScatterV2 {
    /// Creates a new `TensorListScatterV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_scatter_v2 with default options.
pub fn tensor_list_scatter_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    element_shape: T2,
    num_elements: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListScatterV2::new();
    tensor_list_scatter_v2_with_args(ctx, tensor, indices, element_shape, num_elements, &__args)
}

/// tensor_list_scatter_v2 with options.
pub fn tensor_list_scatter_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    element_shape: T2,
    num_elements: T3,
    __args: &TensorListScatterV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListScatterV2")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&element_shape.to_handle()?)?;
    op.add_input(&num_elements.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_type {
        op.set_attr_type("shape_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListSetItem
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListSetItem {
    pub element_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorListSetItem {
    /// Creates a new `TensorListSetItem`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_set_item with default options.
pub fn tensor_list_set_item<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    index: T1,
    item: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListSetItem::new();
    tensor_list_set_item_with_args(ctx, input_handle, index, item, &__args)
}

/// tensor_list_set_item with options.
pub fn tensor_list_set_item_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    index: T1,
    item: T2,
    __args: &TensorListSetItem,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListSetItem")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&index.to_handle()?)?;
    op.add_input(&item.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListSplit
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListSplit {
    pub element_dtype: ::std::option::Option<crate::DataType>,
    pub shape_type: ::std::option::Option<crate::DataType>,
}

impl TensorListSplit {
    /// Creates a new `TensorListSplit`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_split with default options.
pub fn tensor_list_split<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    element_shape: T1,
    lengths: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListSplit::new();
    tensor_list_split_with_args(ctx, tensor, element_shape, lengths, &__args)
}

/// tensor_list_split with options.
pub fn tensor_list_split_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    element_shape: T1,
    lengths: T2,
    __args: &TensorListSplit,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListSplit")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&element_shape.to_handle()?)?;
    op.add_input(&lengths.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape_type {
        op.set_attr_type("shape_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorListStack
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListStack {
    pub element_dtype: ::std::option::Option<crate::DataType>,
    pub num_elements: ::std::option::Option<i64>,
}

impl TensorListStack {
    /// Creates a new `TensorListStack`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_list_stack with default options.
pub fn tensor_list_stack<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    element_shape: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorListStack::new();
    tensor_list_stack_with_args(ctx, input_handle, element_shape, &__args)
}

/// tensor_list_stack with options.
pub fn tensor_list_stack_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    element_shape: T1,
    __args: &TensorListStack,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorListStack")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&element_shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.element_dtype {
        op.set_attr_type("element_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_elements {
        op.set_attr_int("num_elements", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorMapErase
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorMapErase {
    pub key_dtype: ::std::option::Option<crate::DataType>,
    pub value_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorMapErase {
    /// Creates a new `TensorMapErase`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_map_erase with default options.
pub fn tensor_map_erase<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    key: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorMapErase::new();
    tensor_map_erase_with_args(ctx, input_handle, key, &__args)
}

/// tensor_map_erase with options.
pub fn tensor_map_erase_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    key: T1,
    __args: &TensorMapErase,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorMapErase")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&key.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_dtype {
        op.set_attr_type("value_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorMapHasKey
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorMapHasKey {
    pub key_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorMapHasKey {
    /// Creates a new `TensorMapHasKey`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_map_has_key with default options.
pub fn tensor_map_has_key<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    key: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorMapHasKey::new();
    tensor_map_has_key_with_args(ctx, input_handle, key, &__args)
}

/// tensor_map_has_key with options.
pub fn tensor_map_has_key_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    key: T1,
    __args: &TensorMapHasKey,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorMapHasKey")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&key.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorMapInsert
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorMapInsert {
    pub key_dtype: ::std::option::Option<crate::DataType>,
    pub value_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorMapInsert {
    /// Creates a new `TensorMapInsert`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_map_insert with default options.
pub fn tensor_map_insert<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    key: T1,
    value: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorMapInsert::new();
    tensor_map_insert_with_args(ctx, input_handle, key, value, &__args)
}

/// tensor_map_insert with options.
pub fn tensor_map_insert_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    key: T1,
    value: T2,
    __args: &TensorMapInsert,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorMapInsert")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&key.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_dtype {
        op.set_attr_type("value_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorMapLookup
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorMapLookup {
    pub key_dtype: ::std::option::Option<crate::DataType>,
    pub value_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorMapLookup {
    /// Creates a new `TensorMapLookup`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_map_lookup with default options.
pub fn tensor_map_lookup<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    key: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorMapLookup::new();
    tensor_map_lookup_with_args(ctx, input_handle, key, &__args)
}

/// tensor_map_lookup with options.
pub fn tensor_map_lookup_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    key: T1,
    __args: &TensorMapLookup,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorMapLookup")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;
    op.add_input(&key.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.value_dtype {
        op.set_attr_type("value_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorMapSize
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorMapSize {}

impl TensorMapSize {
    /// Creates a new `TensorMapSize`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_map_size with default options.
pub fn tensor_map_size<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorMapSize::new();
    tensor_map_size_with_args(ctx, input_handle, &__args)
}

/// tensor_map_size with options.
pub fn tensor_map_size_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    __args: &TensorMapSize,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorMapSize")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorMapStackKeys
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorMapStackKeys {
    pub key_dtype: ::std::option::Option<crate::DataType>,
}

impl TensorMapStackKeys {
    /// Creates a new `TensorMapStackKeys`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_map_stack_keys with default options.
pub fn tensor_map_stack_keys<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorMapStackKeys::new();
    tensor_map_stack_keys_with_args(ctx, input_handle, &__args)
}

/// tensor_map_stack_keys with options.
pub fn tensor_map_stack_keys_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    __args: &TensorMapStackKeys,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorMapStackKeys")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.key_dtype {
        op.set_attr_type("key_dtype", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorScatterAdd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorScatterAdd {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl TensorScatterAdd {
    /// Creates a new `TensorScatterAdd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_scatter_add with default options.
pub fn tensor_scatter_add<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorScatterAdd::new();
    tensor_scatter_add_with_args(ctx, tensor, indices, updates, &__args)
}

/// tensor_scatter_add with options.
pub fn tensor_scatter_add_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    updates: T2,
    __args: &TensorScatterAdd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorScatterAdd")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorScatterMax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorScatterMax {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl TensorScatterMax {
    /// Creates a new `TensorScatterMax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_scatter_max with default options.
pub fn tensor_scatter_max<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorScatterMax::new();
    tensor_scatter_max_with_args(ctx, tensor, indices, updates, &__args)
}

/// tensor_scatter_max with options.
pub fn tensor_scatter_max_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    updates: T2,
    __args: &TensorScatterMax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorScatterMax")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorScatterMin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorScatterMin {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl TensorScatterMin {
    /// Creates a new `TensorScatterMin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_scatter_min with default options.
pub fn tensor_scatter_min<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorScatterMin::new();
    tensor_scatter_min_with_args(ctx, tensor, indices, updates, &__args)
}

/// tensor_scatter_min with options.
pub fn tensor_scatter_min_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    updates: T2,
    __args: &TensorScatterMin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorScatterMin")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorScatterSub
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorScatterSub {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl TensorScatterSub {
    /// Creates a new `TensorScatterSub`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_scatter_sub with default options.
pub fn tensor_scatter_sub<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorScatterSub::new();
    tensor_scatter_sub_with_args(ctx, tensor, indices, updates, &__args)
}

/// tensor_scatter_sub with options.
pub fn tensor_scatter_sub_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    updates: T2,
    __args: &TensorScatterSub,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorScatterSub")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorScatterUpdate
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorScatterUpdate {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
}

impl TensorScatterUpdate {
    /// Creates a new `TensorScatterUpdate`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_scatter_update with default options.
pub fn tensor_scatter_update<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    updates: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorScatterUpdate::new();
    tensor_scatter_update_with_args(ctx, tensor, indices, updates, &__args)
}

/// tensor_scatter_update with options.
pub fn tensor_scatter_update_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tensor: T0,
    indices: T1,
    updates: T2,
    __args: &TensorScatterUpdate,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorScatterUpdate")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&updates.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorSliceDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorSliceDataset {
    pub Toutput_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl TensorSliceDataset {
    /// Creates a new `TensorSliceDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_slice_dataset with default options.
pub fn tensor_slice_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    components: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorSliceDataset::new();
    tensor_slice_dataset_with_args(ctx, components, &__args)
}

/// tensor_slice_dataset with options.
pub fn tensor_slice_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    components: T0,
    __args: &TensorSliceDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorSliceDataset")?;

    // Required input arguments
    op.add_input(&components.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Toutput_types {
        op.set_attr_type_list("Toutput_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorStridedSliceUpdate
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorStridedSliceUpdate {
    pub T: ::std::option::Option<crate::DataType>,
    pub Index: ::std::option::Option<crate::DataType>,
    pub begin_mask: ::std::option::Option<i64>,
    pub end_mask: ::std::option::Option<i64>,
    pub ellipsis_mask: ::std::option::Option<i64>,
    pub new_axis_mask: ::std::option::Option<i64>,
    pub shrink_axis_mask: ::std::option::Option<i64>,
}

impl TensorStridedSliceUpdate {
    /// Creates a new `TensorStridedSliceUpdate`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_strided_slice_update with default options.
pub fn tensor_strided_slice_update<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    begin: T1,
    end: T2,
    strides: T3,
    value: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorStridedSliceUpdate::new();
    tensor_strided_slice_update_with_args(ctx, input, begin, end, strides, value, &__args)
}

/// tensor_strided_slice_update with options.
pub fn tensor_strided_slice_update_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input: T0,
    begin: T1,
    end: T2,
    strides: T3,
    value: T4,
    __args: &TensorStridedSliceUpdate,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorStridedSliceUpdate")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&begin.to_handle()?)?;
    op.add_input(&end.to_handle()?)?;
    op.add_input(&strides.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Index {
        op.set_attr_type("Index", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.begin_mask {
        op.set_attr_int("begin_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.end_mask {
        op.set_attr_int("end_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.ellipsis_mask {
        op.set_attr_int("ellipsis_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.new_axis_mask {
        op.set_attr_int("new_axis_mask", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shrink_axis_mask {
        op.set_attr_int("shrink_axis_mask", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorSummary {
    pub T: ::std::option::Option<crate::DataType>,
    pub description: ::std::option::Option<::std::string::String>,
    pub labels: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub display_name: ::std::option::Option<::std::string::String>,
}

impl TensorSummary {
    /// Creates a new `TensorSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_summary with default options.
pub fn tensor_summary<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorSummary::new();
    tensor_summary_with_args(ctx, tensor, &__args)
}

/// tensor_summary with options.
pub fn tensor_summary_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    tensor: T0,
    __args: &TensorSummary,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorSummary")?;

    // Required input arguments
    op.add_input(&tensor.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.description {
        op.set_attr_string("description", value);
    }
    if let ::std::option::Option::Some(value) = &__args.labels {
        op.set_attr_string_list("labels", value);
    }
    if let ::std::option::Option::Some(value) = &__args.display_name {
        op.set_attr_string("display_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TensorSummaryV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorSummaryV2 {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TensorSummaryV2 {
    /// Creates a new `TensorSummaryV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tensor_summary_v2 with default options.
pub fn tensor_summary_v2<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tag: T0,
    tensor: T1,
    serialized_summary_metadata: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TensorSummaryV2::new();
    tensor_summary_v2_with_args(ctx, tag, tensor, serialized_summary_metadata, &__args)
}

/// tensor_summary_v2 with options.
pub fn tensor_summary_v2_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    tag: T0,
    tensor: T1,
    serialized_summary_metadata: T2,
    __args: &TensorSummaryV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TensorSummaryV2")?;

    // Required input arguments
    op.add_input(&tag.to_handle()?)?;
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&serialized_summary_metadata.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TextLineDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TextLineDataset {}

impl TextLineDataset {
    /// Creates a new `TextLineDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// text_line_dataset with default options.
pub fn text_line_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    compression_type: T1,
    buffer_size: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = TextLineDataset::new();
    text_line_dataset_with_args(ctx, filenames, compression_type, buffer_size, &__args)
}

/// text_line_dataset with options.
pub fn text_line_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    filenames: T0,
    compression_type: T1,
    buffer_size: T2,
    __args: &TextLineDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TextLineDataset")?;

    // Required input arguments
    op.add_input(&filenames.to_handle()?)?;
    op.add_input(&compression_type.to_handle()?)?;
    op.add_input(&buffer_size.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TextLineReader
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TextLineReader {
    pub skip_header_lines: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl TextLineReader {
    /// Creates a new `TextLineReader`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// text_line_reader with default options.
pub fn text_line_reader(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = TextLineReader::new();
    text_line_reader_with_args(ctx, &__args)
}

/// text_line_reader with options.
pub fn text_line_reader_with_args(
    ctx: &crate::eager::Context,
    __args: &TextLineReader,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TextLineReader")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.skip_header_lines {
        op.set_attr_int("skip_header_lines", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TextLineReaderV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TextLineReaderV2 {
    pub skip_header_lines: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl TextLineReaderV2 {
    /// Creates a new `TextLineReaderV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// text_line_reader_v2 with default options.
pub fn text_line_reader_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = TextLineReaderV2::new();
    text_line_reader_v2_with_args(ctx, &__args)
}

/// text_line_reader_v2 with options.
pub fn text_line_reader_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &TextLineReaderV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TextLineReaderV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.skip_header_lines {
        op.set_attr_int("skip_header_lines", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ThreadPoolDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ThreadPoolDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl ThreadPoolDataset {
    /// Creates a new `ThreadPoolDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// thread_pool_dataset with default options.
pub fn thread_pool_dataset<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    thread_pool: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = ThreadPoolDataset::new();
    thread_pool_dataset_with_args(ctx, input_dataset, thread_pool, &__args)
}

/// thread_pool_dataset with options.
pub fn thread_pool_dataset_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    thread_pool: T1,
    __args: &ThreadPoolDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ThreadPoolDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&thread_pool.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ThreadPoolHandle
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ThreadPoolHandle {
    pub num_threads: ::std::option::Option<i64>,
    pub max_intra_op_parallelism: ::std::option::Option<i64>,
    pub display_name: ::std::option::Option<::std::string::String>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl ThreadPoolHandle {
    /// Creates a new `ThreadPoolHandle`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// thread_pool_handle with default options.
pub fn thread_pool_handle(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = ThreadPoolHandle::new();
    thread_pool_handle_with_args(ctx, &__args)
}

/// thread_pool_handle with options.
pub fn thread_pool_handle_with_args(
    ctx: &crate::eager::Context,
    __args: &ThreadPoolHandle,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ThreadPoolHandle")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_threads {
        op.set_attr_int("num_threads", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.max_intra_op_parallelism {
        op.set_attr_int("max_intra_op_parallelism", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.display_name {
        op.set_attr_string("display_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ThreadUnsafeUnigramCandidateSampler
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ThreadUnsafeUnigramCandidateSampler {
    pub num_true: ::std::option::Option<i64>,
    pub num_sampled: ::std::option::Option<i64>,
    pub unique: ::std::option::Option<bool>,
    pub range_max: ::std::option::Option<i64>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
}

impl ThreadUnsafeUnigramCandidateSampler {
    /// Creates a new `ThreadUnsafeUnigramCandidateSampler`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// thread_unsafe_unigram_candidate_sampler with default options.
pub fn thread_unsafe_unigram_candidate_sampler<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = ThreadUnsafeUnigramCandidateSampler::new();
    thread_unsafe_unigram_candidate_sampler_with_args(ctx, true_classes, &__args)
}

/// thread_unsafe_unigram_candidate_sampler with options.
pub fn thread_unsafe_unigram_candidate_sampler_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
    __args: &ThreadUnsafeUnigramCandidateSampler,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ThreadUnsafeUnigramCandidateSampler")?;

    // Required input arguments
    op.add_input(&true_classes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_true {
        op.set_attr_int("num_true", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_sampled {
        op.set_attr_int("num_sampled", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.unique {
        op.set_attr_bool("unique", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.range_max {
        op.set_attr_int("range_max", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Tile
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Tile {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tmultiples: ::std::option::Option<crate::DataType>,
}

impl Tile {
    /// Creates a new `Tile`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tile with default options.
pub fn tile<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    multiples: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Tile::new();
    tile_with_args(ctx, input, multiples, &__args)
}

/// tile with options.
pub fn tile_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    multiples: T1,
    __args: &Tile,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Tile")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&multiples.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tmultiples {
        op.set_attr_type("Tmultiples", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TileGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TileGrad {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TileGrad {
    /// Creates a new `TileGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tile_grad with default options.
pub fn tile_grad<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    multiples: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TileGrad::new();
    tile_grad_with_args(ctx, input, multiples, &__args)
}

/// tile_grad with options.
pub fn tile_grad_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    multiples: T1,
    __args: &TileGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TileGrad")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&multiples.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Timestamp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Timestamp {}

impl Timestamp {
    /// Creates a new `Timestamp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// timestamp with default options.
pub fn timestamp(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = Timestamp::new();
    timestamp_with_args(ctx, &__args)
}

/// timestamp with options.
pub fn timestamp_with_args(
    ctx: &crate::eager::Context,
    __args: &Timestamp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Timestamp")?;

    // Required input arguments

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ToBool
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ToBool {
    pub T: ::std::option::Option<crate::DataType>,
}

impl ToBool {
    /// Creates a new `ToBool`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// to_bool with default options.
pub fn to_bool<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ToBool::new();
    to_bool_with_args(ctx, input, &__args)
}

/// to_bool with options.
pub fn to_bool_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &ToBool,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ToBool")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TopK
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TopK {
    pub k: ::std::option::Option<i64>,
    pub sorted: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl TopK {
    /// Creates a new `TopK`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// top_k with default options.
pub fn top_k<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TopK::new();
    top_k_with_args(ctx, input, &__args)
}

/// top_k with options.
pub fn top_k_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &TopK,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TopK")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.k {
        op.set_attr_int("k", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.sorted {
        op.set_attr_bool("sorted", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TopKUnique
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TopKUnique {
    pub k: ::std::option::Option<i64>,
}

impl TopKUnique {
    /// Creates a new `TopKUnique`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// top_kunique with default options.
pub fn top_kunique<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TopKUnique::new();
    top_kunique_with_args(ctx, input, &__args)
}

/// top_kunique with options.
pub fn top_kunique_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &TopKUnique,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TopKUnique")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.k {
        op.set_attr_int("k", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TopKV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TopKV2 {
    pub sorted: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl TopKV2 {
    /// Creates a new `TopKV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// top_kv2 with default options.
pub fn top_kv2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    k: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TopKV2::new();
    top_kv2_with_args(ctx, input, k, &__args)
}

/// top_kv2 with options.
pub fn top_kv2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    k: T1,
    __args: &TopKV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TopKV2")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;
    op.add_input(&k.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.sorted {
        op.set_attr_bool("sorted", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// TopKWithUnique
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TopKWithUnique {
    pub k: ::std::option::Option<i64>,
}

impl TopKWithUnique {
    /// Creates a new `TopKWithUnique`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// top_kwith_unique with default options.
pub fn top_kwith_unique<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = TopKWithUnique::new();
    top_kwith_unique_with_args(ctx, input, &__args)
}

/// top_kwith_unique with options.
pub fn top_kwith_unique_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &TopKWithUnique,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TopKWithUnique")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.k {
        op.set_attr_int("k", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Transpose
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Transpose {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tperm: ::std::option::Option<crate::DataType>,
}

impl Transpose {
    /// Creates a new `Transpose`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// transpose with default options.
pub fn transpose<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    perm: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Transpose::new();
    transpose_with_args(ctx, x, perm, &__args)
}

/// transpose with options.
pub fn transpose_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    perm: T1,
    __args: &Transpose,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Transpose")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&perm.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tperm {
        op.set_attr_type("Tperm", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TridiagonalMatMul
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TridiagonalMatMul {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TridiagonalMatMul {
    /// Creates a new `TridiagonalMatMul`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tridiagonal_mat_mul with default options.
pub fn tridiagonal_mat_mul<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    superdiag: T0,
    maindiag: T1,
    subdiag: T2,
    rhs: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = TridiagonalMatMul::new();
    tridiagonal_mat_mul_with_args(ctx, superdiag, maindiag, subdiag, rhs, &__args)
}

/// tridiagonal_mat_mul with options.
pub fn tridiagonal_mat_mul_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    superdiag: T0,
    maindiag: T1,
    subdiag: T2,
    rhs: T3,
    __args: &TridiagonalMatMul,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TridiagonalMatMul")?;

    // Required input arguments
    op.add_input(&superdiag.to_handle()?)?;
    op.add_input(&maindiag.to_handle()?)?;
    op.add_input(&subdiag.to_handle()?)?;
    op.add_input(&rhs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TridiagonalSolve
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TridiagonalSolve {
    pub partial_pivoting: ::std::option::Option<bool>,
    pub perturb_singular: ::std::option::Option<bool>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl TridiagonalSolve {
    /// Creates a new `TridiagonalSolve`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// tridiagonal_solve with default options.
pub fn tridiagonal_solve<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    diagonals: T0,
    rhs: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TridiagonalSolve::new();
    tridiagonal_solve_with_args(ctx, diagonals, rhs, &__args)
}

/// tridiagonal_solve with options.
pub fn tridiagonal_solve_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    diagonals: T0,
    rhs: T1,
    __args: &TridiagonalSolve,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TridiagonalSolve")?;

    // Required input arguments
    op.add_input(&diagonals.to_handle()?)?;
    op.add_input(&rhs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.partial_pivoting {
        op.set_attr_bool("partial_pivoting", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.perturb_singular {
        op.set_attr_bool("perturb_singular", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TruncateDiv
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TruncateDiv {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TruncateDiv {
    /// Creates a new `TruncateDiv`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// truncate_div with default options.
pub fn truncate_div<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TruncateDiv::new();
    truncate_div_with_args(ctx, x, y, &__args)
}

/// truncate_div with options.
pub fn truncate_div_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &TruncateDiv,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TruncateDiv")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TruncateMod
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TruncateMod {
    pub T: ::std::option::Option<crate::DataType>,
}

impl TruncateMod {
    /// Creates a new `TruncateMod`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// truncate_mod with default options.
pub fn truncate_mod<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = TruncateMod::new();
    truncate_mod_with_args(ctx, x, y, &__args)
}

/// truncate_mod with options.
pub fn truncate_mod_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &TruncateMod,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TruncateMod")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// TruncatedNormal
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TruncatedNormal {
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
    pub dtype: ::std::option::Option<crate::DataType>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl TruncatedNormal {
    /// Creates a new `TruncatedNormal`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// truncated_normal with default options.
pub fn truncated_normal<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = TruncatedNormal::new();
    truncated_normal_with_args(ctx, shape, &__args)
}

/// truncated_normal with options.
pub fn truncated_normal_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    shape: T0,
    __args: &TruncatedNormal,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "TruncatedNormal")?;

    // Required input arguments
    op.add_input(&shape.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Unbatch
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Unbatch {
    pub timeout_micros: ::std::option::Option<i64>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl Unbatch {
    /// Creates a new `Unbatch`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unbatch with default options.
pub fn unbatch<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    batched_tensor: T0,
    batch_index: T1,
    id: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = Unbatch::new();
    unbatch_with_args(ctx, batched_tensor, batch_index, id, &__args)
}

/// unbatch with options.
pub fn unbatch_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    batched_tensor: T0,
    batch_index: T1,
    id: T2,
    __args: &Unbatch,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Unbatch")?;

    // Required input arguments
    op.add_input(&batched_tensor.to_handle()?)?;
    op.add_input(&batch_index.to_handle()?)?;
    op.add_input(&id.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.timeout_micros {
        op.set_attr_int("timeout_micros", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UnbatchDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnbatchDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl UnbatchDataset {
    /// Creates a new `UnbatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unbatch_dataset with default options.
pub fn unbatch_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = UnbatchDataset::new();
    unbatch_dataset_with_args(ctx, input_dataset, &__args)
}

/// unbatch_dataset with options.
pub fn unbatch_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &UnbatchDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnbatchDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UnbatchGrad
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnbatchGrad {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl UnbatchGrad {
    /// Creates a new `UnbatchGrad`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unbatch_grad with default options.
pub fn unbatch_grad<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    original_input: T0,
    batch_index: T1,
    grad: T2,
    id: T3,
) -> Result<crate::eager::TensorHandle> {
    let __args = UnbatchGrad::new();
    unbatch_grad_with_args(ctx, original_input, batch_index, grad, id, &__args)
}

/// unbatch_grad with options.
pub fn unbatch_grad_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    original_input: T0,
    batch_index: T1,
    grad: T2,
    id: T3,
    __args: &UnbatchGrad,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnbatchGrad")?;

    // Required input arguments
    op.add_input(&original_input.to_handle()?)?;
    op.add_input(&batch_index.to_handle()?)?;
    op.add_input(&grad.to_handle()?)?;
    op.add_input(&id.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UncompressElement
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UncompressElement {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl UncompressElement {
    /// Creates a new `UncompressElement`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// uncompress_element with default options.
pub fn uncompress_element<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    compressed: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = UncompressElement::new();
    uncompress_element_with_args(ctx, compressed, &__args)
}

/// uncompress_element with options.
pub fn uncompress_element_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    compressed: T0,
    __args: &UncompressElement,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UncompressElement")?;

    // Required input arguments
    op.add_input(&compressed.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UnicodeDecode
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnicodeDecode {
    pub input_encoding: ::std::option::Option<::std::string::String>,
    pub errors: ::std::option::Option<::std::string::String>,
    pub replacement_char: ::std::option::Option<i64>,
    pub replace_control_characters: ::std::option::Option<bool>,
    pub Tsplits: ::std::option::Option<crate::DataType>,
}

impl UnicodeDecode {
    /// Creates a new `UnicodeDecode`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unicode_decode with default options.
pub fn unicode_decode<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = UnicodeDecode::new();
    unicode_decode_with_args(ctx, input, &__args)
}

/// unicode_decode with options.
pub fn unicode_decode_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &UnicodeDecode,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnicodeDecode")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.input_encoding {
        op.set_attr_string("input_encoding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.errors {
        op.set_attr_string("errors", value);
    }
    if let ::std::option::Option::Some(value) = &__args.replacement_char {
        op.set_attr_int("replacement_char", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.replace_control_characters {
        op.set_attr_bool("replace_control_characters", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsplits {
        op.set_attr_type("Tsplits", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// UnicodeDecodeWithOffsets
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnicodeDecodeWithOffsets {
    pub input_encoding: ::std::option::Option<::std::string::String>,
    pub errors: ::std::option::Option<::std::string::String>,
    pub replacement_char: ::std::option::Option<i64>,
    pub replace_control_characters: ::std::option::Option<bool>,
    pub Tsplits: ::std::option::Option<crate::DataType>,
}

impl UnicodeDecodeWithOffsets {
    /// Creates a new `UnicodeDecodeWithOffsets`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unicode_decode_with_offsets with default options.
pub fn unicode_decode_with_offsets<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = UnicodeDecodeWithOffsets::new();
    unicode_decode_with_offsets_with_args(ctx, input, &__args)
}

/// unicode_decode_with_offsets with options.
pub fn unicode_decode_with_offsets_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &UnicodeDecodeWithOffsets,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnicodeDecodeWithOffsets")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.input_encoding {
        op.set_attr_string("input_encoding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.errors {
        op.set_attr_string("errors", value);
    }
    if let ::std::option::Option::Some(value) = &__args.replacement_char {
        op.set_attr_int("replacement_char", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.replace_control_characters {
        op.set_attr_bool("replace_control_characters", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsplits {
        op.set_attr_type("Tsplits", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// UnicodeEncode
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnicodeEncode {
    pub errors: ::std::option::Option<::std::string::String>,
    pub output_encoding: ::std::option::Option<::std::string::String>,
    pub replacement_char: ::std::option::Option<i64>,
    pub Tsplits: ::std::option::Option<crate::DataType>,
}

impl UnicodeEncode {
    /// Creates a new `UnicodeEncode`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unicode_encode with default options.
pub fn unicode_encode<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_values: T0,
    input_splits: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = UnicodeEncode::new();
    unicode_encode_with_args(ctx, input_values, input_splits, &__args)
}

/// unicode_encode with options.
pub fn unicode_encode_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_values: T0,
    input_splits: T1,
    __args: &UnicodeEncode,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnicodeEncode")?;

    // Required input arguments
    op.add_input(&input_values.to_handle()?)?;
    op.add_input(&input_splits.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.errors {
        op.set_attr_string("errors", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_encoding {
        op.set_attr_string("output_encoding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.replacement_char {
        op.set_attr_int("replacement_char", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tsplits {
        op.set_attr_type("Tsplits", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UnicodeScript
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnicodeScript {}

impl UnicodeScript {
    /// Creates a new `UnicodeScript`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unicode_script with default options.
pub fn unicode_script<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = UnicodeScript::new();
    unicode_script_with_args(ctx, input, &__args)
}

/// unicode_script with options.
pub fn unicode_script_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &UnicodeScript,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnicodeScript")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UnicodeTranscode
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnicodeTranscode {
    pub input_encoding: ::std::option::Option<::std::string::String>,
    pub output_encoding: ::std::option::Option<::std::string::String>,
    pub errors: ::std::option::Option<::std::string::String>,
    pub replacement_char: ::std::option::Option<i64>,
    pub replace_control_characters: ::std::option::Option<bool>,
}

impl UnicodeTranscode {
    /// Creates a new `UnicodeTranscode`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unicode_transcode with default options.
pub fn unicode_transcode<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = UnicodeTranscode::new();
    unicode_transcode_with_args(ctx, input, &__args)
}

/// unicode_transcode with options.
pub fn unicode_transcode_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &UnicodeTranscode,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnicodeTranscode")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.input_encoding {
        op.set_attr_string("input_encoding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_encoding {
        op.set_attr_string("output_encoding", value);
    }
    if let ::std::option::Option::Some(value) = &__args.errors {
        op.set_attr_string("errors", value);
    }
    if let ::std::option::Option::Some(value) = &__args.replacement_char {
        op.set_attr_int("replacement_char", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.replace_control_characters {
        op.set_attr_bool("replace_control_characters", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UniformCandidateSampler
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UniformCandidateSampler {
    pub num_true: ::std::option::Option<i64>,
    pub num_sampled: ::std::option::Option<i64>,
    pub unique: ::std::option::Option<bool>,
    pub range_max: ::std::option::Option<i64>,
    pub seed: ::std::option::Option<i64>,
    pub seed2: ::std::option::Option<i64>,
}

impl UniformCandidateSampler {
    /// Creates a new `UniformCandidateSampler`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// uniform_candidate_sampler with default options.
pub fn uniform_candidate_sampler<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = UniformCandidateSampler::new();
    uniform_candidate_sampler_with_args(ctx, true_classes, &__args)
}

/// uniform_candidate_sampler with options.
pub fn uniform_candidate_sampler_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    true_classes: T0,
    __args: &UniformCandidateSampler,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UniformCandidateSampler")?;

    // Required input arguments
    op.add_input(&true_classes.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num_true {
        op.set_attr_int("num_true", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.num_sampled {
        op.set_attr_int("num_sampled", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.unique {
        op.set_attr_bool("unique", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.range_max {
        op.set_attr_int("range_max", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed {
        op.set_attr_int("seed", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.seed2 {
        op.set_attr_int("seed2", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Unique
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Unique {
    pub T: ::std::option::Option<crate::DataType>,
    pub out_idx: ::std::option::Option<crate::DataType>,
}

impl Unique {
    /// Creates a new `Unique`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unique with default options.
pub fn unique<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = Unique::new();
    unique_with_args(ctx, x, &__args)
}

/// unique with options.
pub fn unique_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &Unique,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Unique")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_idx {
        op.set_attr_type("out_idx", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// UniqueDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UniqueDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl UniqueDataset {
    /// Creates a new `UniqueDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unique_dataset with default options.
pub fn unique_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = UniqueDataset::new();
    unique_dataset_with_args(ctx, input_dataset, &__args)
}

/// unique_dataset with options.
pub fn unique_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    __args: &UniqueDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UniqueDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UniqueV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UniqueV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub Taxis: ::std::option::Option<crate::DataType>,
    pub out_idx: ::std::option::Option<crate::DataType>,
}

impl UniqueV2 {
    /// Creates a new `UniqueV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unique_v2 with default options.
pub fn unique_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    axis: T1,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let __args = UniqueV2::new();
    unique_v2_with_args(ctx, x, axis, &__args)
}

/// unique_v2 with options.
pub fn unique_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    axis: T1,
    __args: &UniqueV2,
) -> Result<[crate::eager::TensorHandle; 2]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UniqueV2")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Taxis {
        op.set_attr_type("Taxis", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_idx {
        op.set_attr_type("out_idx", *value);
    }

    // Execute Op
    let mut num_output = 2;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 2];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// UniqueWithCounts
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UniqueWithCounts {
    pub T: ::std::option::Option<crate::DataType>,
    pub out_idx: ::std::option::Option<crate::DataType>,
}

impl UniqueWithCounts {
    /// Creates a new `UniqueWithCounts`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unique_with_counts with default options.
pub fn unique_with_counts<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = UniqueWithCounts::new();
    unique_with_counts_with_args(ctx, x, &__args)
}

/// unique_with_counts with options.
pub fn unique_with_counts_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &UniqueWithCounts,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UniqueWithCounts")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_idx {
        op.set_attr_type("out_idx", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// UniqueWithCountsV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UniqueWithCountsV2 {
    pub T: ::std::option::Option<crate::DataType>,
    pub Taxis: ::std::option::Option<crate::DataType>,
    pub out_idx: ::std::option::Option<crate::DataType>,
}

impl UniqueWithCountsV2 {
    /// Creates a new `UniqueWithCountsV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unique_with_counts_v2 with default options.
pub fn unique_with_counts_v2<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    axis: T1,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let __args = UniqueWithCountsV2::new();
    unique_with_counts_v2_with_args(ctx, x, axis, &__args)
}

/// unique_with_counts_v2 with options.
pub fn unique_with_counts_v2_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    axis: T1,
    __args: &UniqueWithCountsV2,
) -> Result<[crate::eager::TensorHandle; 3]> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UniqueWithCountsV2")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&axis.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Taxis {
        op.set_attr_type("Taxis", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_idx {
        op.set_attr_type("out_idx", *value);
    }

    // Execute Op
    let mut num_output = 3;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 3];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe {
            [
                crate::eager::TensorHandle::from_tensor_handle(res[0]),
                crate::eager::TensorHandle::from_tensor_handle(res[1]),
                crate::eager::TensorHandle::from_tensor_handle(res[2]),
            ]
        };
        return Ok(ret);
    }
    Err(status)
}

/// Unpack
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Unpack {
    pub num: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
    pub axis: ::std::option::Option<i64>,
}

impl Unpack {
    /// Creates a new `Unpack`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unpack with default options.
pub fn unpack<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Unpack::new();
    unpack_with_args(ctx, value, &__args)
}

/// unpack with options.
pub fn unpack_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    value: T0,
    __args: &Unpack,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Unpack")?;

    // Required input arguments
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.num {
        op.set_attr_int("num", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.axis {
        op.set_attr_int("axis", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UnravelIndex
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnravelIndex {
    pub Tidx: ::std::option::Option<crate::DataType>,
}

impl UnravelIndex {
    /// Creates a new `UnravelIndex`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unravel_index with default options.
pub fn unravel_index<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    indices: T0,
    dims: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = UnravelIndex::new();
    unravel_index_with_args(ctx, indices, dims, &__args)
}

/// unravel_index with options.
pub fn unravel_index_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    indices: T0,
    dims: T1,
    __args: &UnravelIndex,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnravelIndex")?;

    // Required input arguments
    op.add_input(&indices.to_handle()?)?;
    op.add_input(&dims.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tidx {
        op.set_attr_type("Tidx", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UnsortedSegmentJoin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnsortedSegmentJoin {
    pub separator: ::std::option::Option<::std::string::String>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub Tnumsegments: ::std::option::Option<crate::DataType>,
}

impl UnsortedSegmentJoin {
    /// Creates a new `UnsortedSegmentJoin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unsorted_segment_join with default options.
pub fn unsorted_segment_join<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    inputs: T0,
    segment_ids: T1,
    num_segments: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = UnsortedSegmentJoin::new();
    unsorted_segment_join_with_args(ctx, inputs, segment_ids, num_segments, &__args)
}

/// unsorted_segment_join with options.
pub fn unsorted_segment_join_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    inputs: T0,
    segment_ids: T1,
    num_segments: T2,
    __args: &UnsortedSegmentJoin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnsortedSegmentJoin")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;
    op.add_input(&num_segments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.separator {
        op.set_attr_string("separator", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tnumsegments {
        op.set_attr_type("Tnumsegments", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UnsortedSegmentMax
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnsortedSegmentMax {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub Tnumsegments: ::std::option::Option<crate::DataType>,
}

impl UnsortedSegmentMax {
    /// Creates a new `UnsortedSegmentMax`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unsorted_segment_max with default options.
pub fn unsorted_segment_max<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    num_segments: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = UnsortedSegmentMax::new();
    unsorted_segment_max_with_args(ctx, data, segment_ids, num_segments, &__args)
}

/// unsorted_segment_max with options.
pub fn unsorted_segment_max_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    num_segments: T2,
    __args: &UnsortedSegmentMax,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnsortedSegmentMax")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;
    op.add_input(&num_segments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tnumsegments {
        op.set_attr_type("Tnumsegments", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UnsortedSegmentMin
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnsortedSegmentMin {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub Tnumsegments: ::std::option::Option<crate::DataType>,
}

impl UnsortedSegmentMin {
    /// Creates a new `UnsortedSegmentMin`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unsorted_segment_min with default options.
pub fn unsorted_segment_min<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    num_segments: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = UnsortedSegmentMin::new();
    unsorted_segment_min_with_args(ctx, data, segment_ids, num_segments, &__args)
}

/// unsorted_segment_min with options.
pub fn unsorted_segment_min_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    num_segments: T2,
    __args: &UnsortedSegmentMin,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnsortedSegmentMin")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;
    op.add_input(&num_segments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tnumsegments {
        op.set_attr_type("Tnumsegments", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UnsortedSegmentProd
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnsortedSegmentProd {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub Tnumsegments: ::std::option::Option<crate::DataType>,
}

impl UnsortedSegmentProd {
    /// Creates a new `UnsortedSegmentProd`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unsorted_segment_prod with default options.
pub fn unsorted_segment_prod<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    num_segments: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = UnsortedSegmentProd::new();
    unsorted_segment_prod_with_args(ctx, data, segment_ids, num_segments, &__args)
}

/// unsorted_segment_prod with options.
pub fn unsorted_segment_prod_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    num_segments: T2,
    __args: &UnsortedSegmentProd,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnsortedSegmentProd")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;
    op.add_input(&num_segments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tnumsegments {
        op.set_attr_type("Tnumsegments", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UnsortedSegmentSum
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnsortedSegmentSum {
    pub T: ::std::option::Option<crate::DataType>,
    pub Tindices: ::std::option::Option<crate::DataType>,
    pub Tnumsegments: ::std::option::Option<crate::DataType>,
}

impl UnsortedSegmentSum {
    /// Creates a new `UnsortedSegmentSum`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unsorted_segment_sum with default options.
pub fn unsorted_segment_sum<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    num_segments: T2,
) -> Result<crate::eager::TensorHandle> {
    let __args = UnsortedSegmentSum::new();
    unsorted_segment_sum_with_args(ctx, data, segment_ids, num_segments, &__args)
}

/// unsorted_segment_sum with options.
pub fn unsorted_segment_sum_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    data: T0,
    segment_ids: T1,
    num_segments: T2,
    __args: &UnsortedSegmentSum,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnsortedSegmentSum")?;

    // Required input arguments
    op.add_input(&data.to_handle()?)?;
    op.add_input(&segment_ids.to_handle()?)?;
    op.add_input(&num_segments.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tindices {
        op.set_attr_type("Tindices", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.Tnumsegments {
        op.set_attr_type("Tnumsegments", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Unstage
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Unstage {
    pub capacity: ::std::option::Option<i64>,
    pub memory_limit: ::std::option::Option<i64>,
    pub dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl Unstage {
    /// Creates a new `Unstage`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unstage with default options.
pub fn unstage(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = Unstage::new();
    unstage_with_args(ctx, &__args)
}

/// unstage with options.
pub fn unstage_with_args(
    ctx: &crate::eager::Context,
    __args: &Unstage,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Unstage")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.capacity {
        op.set_attr_int("capacity", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.memory_limit {
        op.set_attr_int("memory_limit", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtypes {
        op.set_attr_type_list("dtypes", value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UnwrapDatasetVariant
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnwrapDatasetVariant {}

impl UnwrapDatasetVariant {
    /// Creates a new `UnwrapDatasetVariant`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// unwrap_dataset_variant with default options.
pub fn unwrap_dataset_variant<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = UnwrapDatasetVariant::new();
    unwrap_dataset_variant_with_args(ctx, input_handle, &__args)
}

/// unwrap_dataset_variant with options.
pub fn unwrap_dataset_variant_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    __args: &UnwrapDatasetVariant,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UnwrapDatasetVariant")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// UpperBound
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UpperBound {
    pub T: ::std::option::Option<crate::DataType>,
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl UpperBound {
    /// Creates a new `UpperBound`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// upper_bound with default options.
pub fn upper_bound<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sorted_inputs: T0,
    values: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = UpperBound::new();
    upper_bound_with_args(ctx, sorted_inputs, values, &__args)
}

/// upper_bound with options.
pub fn upper_bound_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    sorted_inputs: T0,
    values: T1,
    __args: &UpperBound,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "UpperBound")?;

    // Required input arguments
    op.add_input(&sorted_inputs.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// VarHandleOp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct VarHandleOp {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
    pub dtype: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
    pub allowed_devices: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}

impl VarHandleOp {
    /// Creates a new `VarHandleOp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// var_handle_op with default options.
pub fn var_handle_op(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = VarHandleOp::new();
    var_handle_op_with_args(ctx, &__args)
}

/// var_handle_op with options.
pub fn var_handle_op_with_args(
    ctx: &crate::eager::Context,
    __args: &VarHandleOp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "VarHandleOp")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.allowed_devices {
        op.set_attr_string_list("allowed_devices", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// VarIsInitializedOp
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct VarIsInitializedOp {}

impl VarIsInitializedOp {
    /// Creates a new `VarIsInitializedOp`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// var_is_initialized_op with default options.
pub fn var_is_initialized_op<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = VarIsInitializedOp::new();
    var_is_initialized_op_with_args(ctx, resource, &__args)
}

/// var_is_initialized_op with options.
pub fn var_is_initialized_op_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    resource: T0,
    __args: &VarIsInitializedOp,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "VarIsInitializedOp")?;

    // Required input arguments
    op.add_input(&resource.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Variable
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Variable {
    pub shape: ::std::option::Option<crate::Shape>,
    pub dtype: ::std::option::Option<crate::DataType>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl Variable {
    /// Creates a new `Variable`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// variable with default options.
pub fn variable(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = Variable::new();
    variable_with_args(ctx, &__args)
}

/// variable with options.
pub fn variable_with_args(
    ctx: &crate::eager::Context,
    __args: &Variable,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Variable")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// VariableShape
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct VariableShape {
    pub out_type: ::std::option::Option<crate::DataType>,
}

impl VariableShape {
    /// Creates a new `VariableShape`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// variable_shape with default options.
pub fn variable_shape<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = VariableShape::new();
    variable_shape_with_args(ctx, input, &__args)
}

/// variable_shape with options.
pub fn variable_shape_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &VariableShape,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "VariableShape")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.out_type {
        op.set_attr_type("out_type", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// VariableV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct VariableV2 {
    pub shape: ::std::option::Option<crate::Shape>,
    pub dtype: ::std::option::Option<crate::DataType>,
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl VariableV2 {
    /// Creates a new `VariableV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// variable_v2 with default options.
pub fn variable_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = VariableV2::new();
    variable_v2_with_args(ctx, &__args)
}

/// variable_v2 with options.
pub fn variable_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &VariableV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "VariableV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.dtype {
        op.set_attr_type("dtype", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Where
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Where {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Where {
    /// Creates a new `Where`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// where_ with default options.
pub fn where_<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Where::new();
    where__with_args(ctx, input, &__args)
}

/// where_ with options.
pub fn where__with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &Where,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Where")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// While
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct While {
    pub T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub cond: ::std::option::Option<::std::string::String>,
    pub body: ::std::option::Option<::std::string::String>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub parallel_iterations: ::std::option::Option<i64>,
}

impl While {
    /// Creates a new `While`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// while_ with default options.
pub fn while_<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = While::new();
    while__with_args(ctx, input, &__args)
}

/// while_ with options.
pub fn while__with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &While,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "While")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type_list("T", value);
    }
    if let ::std::option::Option::Some(value) = &__args.cond {
        op.set_attr_string("cond", value);
    }
    if let ::std::option::Option::Some(value) = &__args.body {
        op.set_attr_string("body", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.parallel_iterations {
        op.set_attr_int("parallel_iterations", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// WholeFileReader
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WholeFileReader {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl WholeFileReader {
    /// Creates a new `WholeFileReader`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// whole_file_reader with default options.
pub fn whole_file_reader(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = WholeFileReader::new();
    whole_file_reader_with_args(ctx, &__args)
}

/// whole_file_reader with options.
pub fn whole_file_reader_with_args(
    ctx: &crate::eager::Context,
    __args: &WholeFileReader,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WholeFileReader")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// WholeFileReaderV2
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WholeFileReaderV2 {
    pub container: ::std::option::Option<::std::string::String>,
    pub shared_name: ::std::option::Option<::std::string::String>,
}

impl WholeFileReaderV2 {
    /// Creates a new `WholeFileReaderV2`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// whole_file_reader_v2 with default options.
pub fn whole_file_reader_v2(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = WholeFileReaderV2::new();
    whole_file_reader_v2_with_args(ctx, &__args)
}

/// whole_file_reader_v2 with options.
pub fn whole_file_reader_v2_with_args(
    ctx: &crate::eager::Context,
    __args: &WholeFileReaderV2,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WholeFileReaderV2")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.container {
        op.set_attr_string("container", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shared_name {
        op.set_attr_string("shared_name", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Window
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Window {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub Tinputs: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
}

impl Window {
    /// Creates a new `Window`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// window with default options.
pub fn window<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = Window::new();
    window_with_args(ctx, inputs, &__args)
}

/// window with options.
pub fn window_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &Window,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Window")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.Tinputs {
        op.set_attr_type_list("Tinputs", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// WindowDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WindowDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
}

impl WindowDataset {
    /// Creates a new `WindowDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// window_dataset with default options.
pub fn window_dataset<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    size: T1,
    shift: T2,
    stride: T3,
    drop_remainder: T4,
) -> Result<crate::eager::TensorHandle> {
    let __args = WindowDataset::new();
    window_dataset_with_args(
        ctx,
        input_dataset,
        size,
        shift,
        stride,
        drop_remainder,
        &__args,
    )
}

/// window_dataset with options.
pub fn window_dataset_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    input_dataset: T0,
    size: T1,
    shift: T2,
    stride: T3,
    drop_remainder: T4,
    __args: &WindowDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WindowDataset")?;

    // Required input arguments
    op.add_input(&input_dataset.to_handle()?)?;
    op.add_input(&size.to_handle()?)?;
    op.add_input(&shift.to_handle()?)?;
    op.add_input(&stride.to_handle()?)?;
    op.add_input(&drop_remainder.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// WorkerHeartbeat
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WorkerHeartbeat {}

impl WorkerHeartbeat {
    /// Creates a new `WorkerHeartbeat`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// worker_heartbeat with default options.
pub fn worker_heartbeat<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    request: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = WorkerHeartbeat::new();
    worker_heartbeat_with_args(ctx, request, &__args)
}

/// worker_heartbeat with options.
pub fn worker_heartbeat_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    request: T0,
    __args: &WorkerHeartbeat,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WorkerHeartbeat")?;

    // Required input arguments
    op.add_input(&request.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// WrapDatasetVariant
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WrapDatasetVariant {}

impl WrapDatasetVariant {
    /// Creates a new `WrapDatasetVariant`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// wrap_dataset_variant with default options.
pub fn wrap_dataset_variant<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = WrapDatasetVariant::new();
    wrap_dataset_variant_with_args(ctx, input_handle, &__args)
}

/// wrap_dataset_variant with options.
pub fn wrap_dataset_variant_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_handle: T0,
    __args: &WrapDatasetVariant,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WrapDatasetVariant")?;

    // Required input arguments
    op.add_input(&input_handle.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// WriteAudioSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteAudioSummary {
    pub max_outputs: ::std::option::Option<i64>,
}

impl WriteAudioSummary {
    /// Creates a new `WriteAudioSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// write_audio_summary with default options.
pub fn write_audio_summary<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tag: T2,
    tensor: T3,
    sample_rate: T4,
) -> Result<()> {
    let __args = WriteAudioSummary::new();
    write_audio_summary_with_args(ctx, writer, step, tag, tensor, sample_rate, &__args)
}

/// write_audio_summary with options.
pub fn write_audio_summary_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tag: T2,
    tensor: T3,
    sample_rate: T4,
    __args: &WriteAudioSummary,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WriteAudioSummary")?;

    // Required input arguments
    op.add_input(&writer.to_handle()?)?;
    op.add_input(&step.to_handle()?)?;
    op.add_input(&tag.to_handle()?)?;
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&sample_rate.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.max_outputs {
        op.set_attr_int("max_outputs", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// WriteFile
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteFile {}

impl WriteFile {
    /// Creates a new `WriteFile`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// write_file with default options.
pub fn write_file<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    filename: T0,
    contents: T1,
) -> Result<()> {
    let __args = WriteFile::new();
    write_file_with_args(ctx, filename, contents, &__args)
}

/// write_file with options.
pub fn write_file_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    filename: T0,
    contents: T1,
    __args: &WriteFile,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WriteFile")?;

    // Required input arguments
    op.add_input(&filename.to_handle()?)?;
    op.add_input(&contents.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// WriteGraphSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteGraphSummary {}

impl WriteGraphSummary {
    /// Creates a new `WriteGraphSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// write_graph_summary with default options.
pub fn write_graph_summary<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tensor: T2,
) -> Result<()> {
    let __args = WriteGraphSummary::new();
    write_graph_summary_with_args(ctx, writer, step, tensor, &__args)
}

/// write_graph_summary with options.
pub fn write_graph_summary_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tensor: T2,
    __args: &WriteGraphSummary,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WriteGraphSummary")?;

    // Required input arguments
    op.add_input(&writer.to_handle()?)?;
    op.add_input(&step.to_handle()?)?;
    op.add_input(&tensor.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// WriteHistogramSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteHistogramSummary {
    pub T: ::std::option::Option<crate::DataType>,
}

impl WriteHistogramSummary {
    /// Creates a new `WriteHistogramSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// write_histogram_summary with default options.
pub fn write_histogram_summary<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tag: T2,
    values: T3,
) -> Result<()> {
    let __args = WriteHistogramSummary::new();
    write_histogram_summary_with_args(ctx, writer, step, tag, values, &__args)
}

/// write_histogram_summary with options.
pub fn write_histogram_summary_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tag: T2,
    values: T3,
    __args: &WriteHistogramSummary,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WriteHistogramSummary")?;

    // Required input arguments
    op.add_input(&writer.to_handle()?)?;
    op.add_input(&step.to_handle()?)?;
    op.add_input(&tag.to_handle()?)?;
    op.add_input(&values.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// WriteImageSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteImageSummary {
    pub max_images: ::std::option::Option<i64>,
    pub T: ::std::option::Option<crate::DataType>,
}

impl WriteImageSummary {
    /// Creates a new `WriteImageSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// write_image_summary with default options.
pub fn write_image_summary<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tag: T2,
    tensor: T3,
    bad_color: T4,
) -> Result<()> {
    let __args = WriteImageSummary::new();
    write_image_summary_with_args(ctx, writer, step, tag, tensor, bad_color, &__args)
}

/// write_image_summary with options.
pub fn write_image_summary_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tag: T2,
    tensor: T3,
    bad_color: T4,
    __args: &WriteImageSummary,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WriteImageSummary")?;

    // Required input arguments
    op.add_input(&writer.to_handle()?)?;
    op.add_input(&step.to_handle()?)?;
    op.add_input(&tag.to_handle()?)?;
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&bad_color.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.max_images {
        op.set_attr_int("max_images", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// WriteRawProtoSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteRawProtoSummary {}

impl WriteRawProtoSummary {
    /// Creates a new `WriteRawProtoSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// write_raw_proto_summary with default options.
pub fn write_raw_proto_summary<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tensor: T2,
) -> Result<()> {
    let __args = WriteRawProtoSummary::new();
    write_raw_proto_summary_with_args(ctx, writer, step, tensor, &__args)
}

/// write_raw_proto_summary with options.
pub fn write_raw_proto_summary_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tensor: T2,
    __args: &WriteRawProtoSummary,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WriteRawProtoSummary")?;

    // Required input arguments
    op.add_input(&writer.to_handle()?)?;
    op.add_input(&step.to_handle()?)?;
    op.add_input(&tensor.to_handle()?)?;

    // Attributes

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// WriteScalarSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteScalarSummary {
    pub T: ::std::option::Option<crate::DataType>,
}

impl WriteScalarSummary {
    /// Creates a new `WriteScalarSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// write_scalar_summary with default options.
pub fn write_scalar_summary<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tag: T2,
    value: T3,
) -> Result<()> {
    let __args = WriteScalarSummary::new();
    write_scalar_summary_with_args(ctx, writer, step, tag, value, &__args)
}

/// write_scalar_summary with options.
pub fn write_scalar_summary_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tag: T2,
    value: T3,
    __args: &WriteScalarSummary,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WriteScalarSummary")?;

    // Required input arguments
    op.add_input(&writer.to_handle()?)?;
    op.add_input(&step.to_handle()?)?;
    op.add_input(&tag.to_handle()?)?;
    op.add_input(&value.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// WriteSummary
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteSummary {
    pub T: ::std::option::Option<crate::DataType>,
}

impl WriteSummary {
    /// Creates a new `WriteSummary`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// write_summary with default options.
pub fn write_summary<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tensor: T2,
    tag: T3,
    summary_metadata: T4,
) -> Result<()> {
    let __args = WriteSummary::new();
    write_summary_with_args(ctx, writer, step, tensor, tag, summary_metadata, &__args)
}

/// write_summary with options.
pub fn write_summary_with_args<
    T0: crate::eager::ToHandle,
    T1: crate::eager::ToHandle,
    T2: crate::eager::ToHandle,
    T3: crate::eager::ToHandle,
    T4: crate::eager::ToHandle,
>(
    ctx: &crate::eager::Context,
    writer: T0,
    step: T1,
    tensor: T2,
    tag: T3,
    summary_metadata: T4,
    __args: &WriteSummary,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "WriteSummary")?;

    // Required input arguments
    op.add_input(&writer.to_handle()?)?;
    op.add_input(&step.to_handle()?)?;
    op.add_input(&tensor.to_handle()?)?;
    op.add_input(&tag.to_handle()?)?;
    op.add_input(&summary_metadata.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Xdivy
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Xdivy {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Xdivy {
    /// Creates a new `Xdivy`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// xdivy with default options.
pub fn xdivy<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Xdivy::new();
    xdivy_with_args(ctx, x, y, &__args)
}

/// xdivy with options.
pub fn xdivy_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Xdivy,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Xdivy")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// XlaHostCompute
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct XlaHostCompute {
    pub Tinputs: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub Toutputs: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub ancestors: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub shape_inference_graph: ::std::option::Option<::std::string::String>,
    pub key: ::std::option::Option<::std::string::String>,
    pub send_key: ::std::option::Option<::std::string::String>,
    pub recv_key: ::std::option::Option<::std::string::String>,
    pub cost_estimate_ns: ::std::option::Option<i64>,
    pub tpu_core: ::std::option::Option<i64>,
}

impl XlaHostCompute {
    /// Creates a new `XlaHostCompute`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// xla_host_compute with default options.
pub fn xla_host_compute<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = XlaHostCompute::new();
    xla_host_compute_with_args(ctx, inputs, &__args)
}

/// xla_host_compute with options.
pub fn xla_host_compute_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    inputs: T0,
    __args: &XlaHostCompute,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "XlaHostCompute")?;

    // Required input arguments
    op.add_input(&inputs.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinputs {
        op.set_attr_type_list("Tinputs", value);
    }
    if let ::std::option::Option::Some(value) = &__args.Toutputs {
        op.set_attr_type_list("Toutputs", value);
    }
    if let ::std::option::Option::Some(value) = &__args.ancestors {
        op.set_attr_string_list("ancestors", value);
    }
    if let ::std::option::Option::Some(value) = &__args.shapes {
        op.set_attr_shape_list("shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.shape_inference_graph {
        op.set_attr_string("shape_inference_graph", value);
    }
    if let ::std::option::Option::Some(value) = &__args.key {
        op.set_attr_string("key", value);
    }
    if let ::std::option::Option::Some(value) = &__args.send_key {
        op.set_attr_string("send_key", value);
    }
    if let ::std::option::Option::Some(value) = &__args.recv_key {
        op.set_attr_string("recv_key", value);
    }
    if let ::std::option::Option::Some(value) = &__args.cost_estimate_ns {
        op.set_attr_int("cost_estimate_ns", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.tpu_core {
        op.set_attr_int("tpu_core", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// XlaRecvFromHost
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct XlaRecvFromHost {
    pub Toutput: ::std::option::Option<crate::DataType>,
    pub shape: ::std::option::Option<crate::Shape>,
    pub key: ::std::option::Option<::std::string::String>,
}

impl XlaRecvFromHost {
    /// Creates a new `XlaRecvFromHost`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// xla_recv_from_host with default options.
pub fn xla_recv_from_host(ctx: &crate::eager::Context) -> Result<crate::eager::TensorHandle> {
    let __args = XlaRecvFromHost::new();
    xla_recv_from_host_with_args(ctx, &__args)
}

/// xla_recv_from_host with options.
pub fn xla_recv_from_host_with_args(
    ctx: &crate::eager::Context,
    __args: &XlaRecvFromHost,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "XlaRecvFromHost")?;

    // Required input arguments

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Toutput {
        op.set_attr_type("Toutput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.shape {
        op.set_attr_shape("shape", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.key {
        op.set_attr_string("key", value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// XlaSendToHost
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct XlaSendToHost {
    pub Tinput: ::std::option::Option<crate::DataType>,
    pub key: ::std::option::Option<::std::string::String>,
}

impl XlaSendToHost {
    /// Creates a new `XlaSendToHost`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// xla_send_to_host with default options.
pub fn xla_send_to_host<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
) -> Result<()> {
    let __args = XlaSendToHost::new();
    xla_send_to_host_with_args(ctx, input, &__args)
}

/// xla_send_to_host with options.
pub fn xla_send_to_host_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input: T0,
    __args: &XlaSendToHost,
) -> Result<()> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "XlaSendToHost")?;

    // Required input arguments
    op.add_input(&input.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.Tinput {
        op.set_attr_type("Tinput", *value);
    }
    if let ::std::option::Option::Some(value) = &__args.key {
        op.set_attr_string("key", value);
    }

    // Execute Op
    let mut num_output = 0;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 0];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        return Ok(());
    }
    Err(status)
}

/// Xlog1py
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Xlog1py {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Xlog1py {
    /// Creates a new `Xlog1py`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// xlog1py with default options.
pub fn xlog1py<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Xlog1py::new();
    xlog1py_with_args(ctx, x, y, &__args)
}

/// xlog1py with options.
pub fn xlog1py_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Xlog1py,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Xlog1py")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Xlogy
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Xlogy {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Xlogy {
    /// Creates a new `Xlogy`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// xlogy with default options.
pub fn xlogy<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Xlogy::new();
    xlogy_with_args(ctx, x, y, &__args)
}

/// xlogy with options.
pub fn xlogy_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    y: T1,
    __args: &Xlogy,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Xlogy")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&y.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ZerosLike
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ZerosLike {
    pub T: ::std::option::Option<crate::DataType>,
}

impl ZerosLike {
    /// Creates a new `ZerosLike`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// zeros_like with default options.
pub fn zeros_like<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ZerosLike::new();
    zeros_like_with_args(ctx, x, &__args)
}

/// zeros_like with options.
pub fn zeros_like_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    __args: &ZerosLike,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ZerosLike")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// Zeta
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Zeta {
    pub T: ::std::option::Option<crate::DataType>,
}

impl Zeta {
    /// Creates a new `Zeta`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// zeta with default options.
pub fn zeta<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    q: T1,
) -> Result<crate::eager::TensorHandle> {
    let __args = Zeta::new();
    zeta_with_args(ctx, x, q, &__args)
}

/// zeta with options.
pub fn zeta_with_args<T0: crate::eager::ToHandle, T1: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    x: T0,
    q: T1,
    __args: &Zeta,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "Zeta")?;

    // Required input arguments
    op.add_input(&x.to_handle()?)?;
    op.add_input(&q.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.T {
        op.set_attr_type("T", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}

/// ZipDataset
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ZipDataset {
    pub output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    pub output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    pub N: ::std::option::Option<i64>,
}

impl ZipDataset {
    /// Creates a new `ZipDataset`.
    pub fn new() -> Self {
        Self::default()
    }
}

/// zip_dataset with default options.
pub fn zip_dataset<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_datasets: T0,
) -> Result<crate::eager::TensorHandle> {
    let __args = ZipDataset::new();
    zip_dataset_with_args(ctx, input_datasets, &__args)
}

/// zip_dataset with options.
pub fn zip_dataset_with_args<T0: crate::eager::ToHandle>(
    ctx: &crate::eager::Context,
    input_datasets: T0,
    __args: &ZipDataset,
) -> Result<crate::eager::TensorHandle> {
    let status = Status::new();

    // Define Op
    let mut op = crate::eager::Op::new(ctx, "ZipDataset")?;

    // Required input arguments
    op.add_input(&input_datasets.to_handle()?)?;

    // Attributes
    if let ::std::option::Option::Some(value) = &__args.output_types {
        op.set_attr_type_list("output_types", value);
    }
    if let ::std::option::Option::Some(value) = &__args.output_shapes {
        op.set_attr_shape_list("output_shapes", value)?;
    }
    if let ::std::option::Option::Some(value) = &__args.N {
        op.set_attr_int("N", *value);
    }

    // Execute Op
    let mut num_output = 1;
    let mut res = [std::ptr::null_mut::<tf::TFE_TensorHandle>(); 1];
    unsafe {
        tf::TFE_Execute(
            op.inner,
            res.as_mut_ptr(),
            (&mut num_output) as *mut i32,
            status.inner,
        );
    };
    if status.is_ok() {
        let ret = unsafe { crate::eager::TensorHandle::from_tensor_handle(res[0]) };
        return Ok(ret);
    }
    Err(status)
}
